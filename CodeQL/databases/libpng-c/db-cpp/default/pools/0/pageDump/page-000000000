C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeCompilerABI.hconst charconst char *char *info_archINFO:arch[x86_64]"INFO"
                               ":"
                               "arch[" ARCHITECTURE_ID "]"char[18]staticconst unsigned shortconst unsigned short[]unsigned short[]info_byte_order_little_endianconst unsigned short[16]unsigned short[16]200410x4E49202940x4F46251460x623A298170x7479244210x5F65292950x726F259560x6564234100x5B72187640x494C215880x5454177400x454C177590x455F174860x444E167130x4149238860x5D4E00x0000info_byte_order_big_endianconst unsigned short[15]unsigned short[15]187660x494E179990x464F149460x3A62310920x7974259510x655F285300x6F72257010x6465292750x725B169690x4249182710x475F177420x454E174810x4449167180x414E238080x5D00const char[]char[]info_sizeof_dptrconst char[21]char[21]73'I'78'N'70'F'79'O'58':'115's'105'i'122'z'101'e'111'o'102'f'95'_'100'd'112'p'116't'114'r'91'['48'0'void *8SIZEOF_DPTR10(SIZEOF_DPTR / 10)(SIZEOF_DPTR / 10) % 10((SIZEOF_DPTR / 10) % 10)'0' + ((SIZEOF_DPTR / 10) % 10)('0' + ((SIZEOF_DPTR / 10) % 10))(SIZEOF_DPTR % 10)56'0' + (SIZEOF_DPTR % 10)('0' + (SIZEOF_DPTR % 10))93']''\0'ARCHITECTURE_ID"x86_64"(sizeof(void*))defined(__GNU__) && defined(__ELF__) && defined(__ARM_EABI__)defined(__GNU__) && defined(__ELF__) && defined(__ARMEB__)defined(__GNU__) && defined(__ELF__) && defined(__ARMEL__)defined(__linux__) && defined(__ELF__) && defined(__amd64__) && defined(__ILP32__)defined(__ELF__)defined(__APPLE__) && defined(__arm64__)defined(__ARM64_ARCH_8_32__)defined(__arm64e__)defined(_MSC_VER) && defined(_M_ARM64EC)defined(_MSC_VER) && defined(_M_ARM64)defined(__arm64ec__)defined(__aarch64__)__ARM_ARCH == 7 || _M_ARM == 7 || defined(__ARM_ARCH_7__) || defined(__TI_ARM_V7__)defined(__APPLE__) && defined(__ARM_ARCH_7K__)defined(__APPLE__) && defined(__ARM_ARCH_7S__)__ARM_ARCH == 6 || _M_ARM == 6 || defined(__ARM_ARCH_6__) || defined(__TI_ARM_V6__)__ARM_ARCH == 5 || _M_ARM == 5 || defined(__ARM_ARCH_5__) || defined(__TI_ARM_V5__)defined(__alpha) || defined(__alpha) || defined(_M_ALPHA)defined(__x86_64) || defined(__x86_64__) || defined(__amd64) || defined(__amd64__) || defined(_M_X64) || defined(_M_AMD64)defined(__i686) || defined(__i686__) || _M_IX86 == 600defined(__i586) || defined(__i586__) || _M_IX86 == 500defined(__i486) || defined(__i486__) || _M_IX86 == 400defined(__i386) || defined(__i386__) || defined(_M_IX86)defined(__ia64) || defined(__ia64__) || defined(_M_IA64)defined(__loongarch64)defined(__loongarch__)defined(__m68k__)defined(__mips64) || defined(__mips64__)defined(_MIPSEL)defined(__mips) || defined(__mips__)defined(__riscv) && __riscv_xlen == 64defined(__riscv) && __riscv_xlen == 32defined(__sw_64)defined(__s390x__)defined(__s390__)defined(__sparcv9) || defined(__sparcv9__) || defined(__sparc64__)defined(__sparc) || defined(__sparc__)defined(__hppa) || defined(__hppa__)defined(__LP64__)defined(__ppc64__) || defined(__powerpc64__) || defined(__PPC64__) || defined(_ARCH_PPC64)defined(_LITTLE_ENDIAN) || defined(__LITTLE_ENDIAN__)defined(__ppc__) || defined(__powerpc__) || defined(__PPC__) || defined(_ARCH_PPC)defined(__wasm64) || defined(__wasm64__)defined(__wasm32) || defined(__wasm32__)defined(ABI_ID)defined(ARCHITECTURE_ID)_M_AMD64_M_X64_MSC_VER1943/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  *//* Sync with:
 *   Help/variable/CMAKE_LANG_COMPILER_ARCHITECTURE_ID.rst
 *   Modules/CMakeFortranCompilerABI.F
 *   Modules/CMakeFortranCompilerABI.F90
 *   Modules/Internal/CMakeParseCompilerArchitectureId.cmake
 *//* Check for (some) ARM ABIs.
 * See e.g. http://wiki.debian.org/ArmEabiPort for some information on this. *//* Application Binary Interface.  *//* INFO:byte_order string for LITTLE_ENDIAN *//* INFO:byte_order string for BIG_ENDIAN *//* Byte order.  Only one of these will have bytes in the right order.  *//* clang-format on *//* clang-format off *//* Size of a pointer-to-data in bytes.  */C:/Program Files/CMake/share/cmake-4.2/ModulesC:/Program Files/CMake/share/cmake-4.2C:/Program Files/CMake/shareC:/Program Files/CMakeC:/Program FilesC:/2.23.86.7compiled as c1C:/Program Files/CMake/share/cmake-4.2/Modules/CMakeCCompilerABI.c"CMakeCompilerABI.h"mainchar *[]c_linkagerequire 0const unsigned short *unsigned short *char **__cplusplus__CLASSIC_C__argcargverrorunknownvoiddecltype(nullptr)boolwchar_tchar8_tchar16_tchar32_tcharunsigned charsigned charshortunsigned shortsigned shortintunsigned intsigned intlongunsigned longsigned longlong longunsigned long longsigned long long__int128unsigned __int128signed __int128_Float16__fp16floatdoublelong double__float128_Decimal32_Decimal64_Decimal128__bf16std::float16_t_Float32_Float32x_Float64_Float64x_Float128__SVCount_t__mfp8_Complex _Float16_Complex __fp16_Complex __bf16_Complex std::float16_t_Complex float_Complex _Float32x_Complex double_Complex _Float64x_Complex long double_Complex __float128_Complex _Float32_Complex _Float64_Complex _Float128_Imaginary float_Imaginary double_Imaginary long doubleauto__superpublicprotectedprivatepurevirtualdeclared_virtualinlineexplicitconstvolatilerestrictatomicnullablenonnullnull_unspecifiedfinaloverrideoptionalis_constexpris_constevalis_thread_localdeclared_constexprdeclared_constinitnoreturn&&&externregister__blocknearfarsealedabstract__interfaceunaligneddllimportdllexportthreadnakedmicrosoft_inlineforceinlineselectanynothrownovtablenoinlinenoalias__ptr32__ptr64__sptr__uptrcdeclfastcallstdcallthiscallvectorcallclrcallvarargsimplicit_inthas_trailing_return_typeD:/PracticeInCodeQL/libpng/build/CMakeFiles/4.2.1/CompilerIdC/CMakeCCompilerId.cconst char[59]char[59]info_language_extensions_defaultINFO:extensions_default[OFF]"INFO" ":" "extensions_default["
#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
     defined(__TI_COMPILER_VERSION__) || defined(__RENESAS__)) &&             \
  !defined(__STRICT_ANSI__)
  "ON"
#else
  "OFF"
#endif
"]"char[29]info_language_standard_defaultINFO:standard_default[90]"INFO" ":" "standard_default[" C_VERSION "]"char[26]INFO:arch[x64]"INFO" ":" "arch[" ARCHITECTURE_ID "]"char[15]info_platformINFO:platform[Windows]"INFO" ":" "platform[" PLATFORM_ID "]"char[23]info_version_MSC_VER / 1001943 / 100_MSC_VER % 1001943 % 100_MSC_FULL_VER % 100000194334808 % 100000_MSC_BUILD99'c'109'm'108'l'118'v'110'n'191000000010000001000001000010004995746'.'4345235119433480834808343483480D:/PracticeInCodeQL/libpng/build/CMakeFiles/4.2.1/CompilerIdCD:/PracticeInCodeQL/libpng/build/CMakeFiles/4.2.1D:/PracticeInCodeQL/libpng/build/CMakeFilesD:/PracticeInCodeQL/libpng/buildD:/PracticeInCodeQL/libpngD:/PracticeInCodeQLD:/info_compilerINFO:compiler[MSVC]"INFO" ":" "compiler[" COMPILER_ID "]"char[20]C_VERSION"90"C_STD__STDC_VERSION__C_STD_23202311LC_STD_17201710LC_STD_11201112LC_STD_99199901LHEX(n)('0' + ((n)>>28 & 0xF)), ('0' + ((n)>>24 & 0xF)), ('0' + ((n)>>20 & 0xF)), ('0' + ((n)>>16 & 0xF)), ('0' + ((n)>>12 & 0xF)), ('0' + ((n)>>8 & 0xF)), ('0' + ((n)>>4 & 0xF)), ('0' + ((n) & 0xF))DEC(n)('0' + (((n) / 10000000)%10)), ('0' + (((n) / 1000000)%10)), ('0' + (((n) / 100000)%10)), ('0' + (((n) / 10000)%10)), ('0' + (((n) / 1000)%10)), ('0' + (((n) / 100)%10)), ('0' + (((n) / 10)%10)), ('0' + ((n) % 10))"x64"PLATFORM_ID"Windows"STRINGIFY(X)STRINGIFY_HELPER(X)#XCOMPILER_VERSION_TWEAKDEC(_MSC_BUILD)COMPILER_VERSION_PATCHDEC(_MSC_FULL_VER % 100000)COMPILER_VERSION_MINORDEC(_MSC_VER % 100)COMPILER_VERSION_MAJORDEC(_MSC_VER / 100)COMPILER_ID"MSVC"defined(__18CXX)defined(__CLASSIC_C__)!defined(__has_include)defined(__INTEL_COMPILER) || defined(__ICC)defined(_MSC_VER)defined(__GNUC__)__INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111defined(__INTEL_COMPILER_UPDATE)defined(__INTEL_COMPILER_BUILD_DATE)defined(__GNUG__)defined(__GNUC_MINOR__)defined(__GNUC_PATCHLEVEL__)(defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)__INTEL_LLVM_COMPILER < 1000000Ldefined(__PATHCC__)defined(__PATHCC_PATCHLEVEL__)defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)defined(__BORLANDC__)defined(__WATCOMC__) && __WATCOMC__ < 1200(__WATCOMC__ % 10) > 0defined(__WATCOMC__)defined(__SUNPRO_C)__SUNPRO_C >= 0x5100defined(__HP_cc)defined(__DECC)defined(__IBMC__) && defined(__COMPILER_VER__)defined(__open_xl__) && defined(__clang__)defined(__ibmxl__) && defined(__clang__)defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ >= 800defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ < 800defined(__NVCOMPILER)defined(__NVCOMPILER_PATCHLEVEL__)defined(__PGI)defined(__PGIC_PATCHLEVEL__)defined(__clang__) && defined(__cray__)defined(_CRAYC)defined(__TI_COMPILER_VERSION__)defined(__CLANG_FUJITSU)defined(__FUJITSU)defined(__FCC_version__)defined(__FCC_major__)defined(__fcc_version)defined(__FCC_VERSION)defined(__ghs__)__GHS_VERSION_NUMBERdefined(__TASKING__)defined(__ORANGEC__)defined(__RENESAS__)defined(__TINYC__)defined(__BCC__)defined(__SCO_VERSION__)defined(__ARMCC_VERSION) && !defined(__clang__)__ARMCC_VERSION >= 1000000defined(__clang__) && defined(__apple_build_version__)defined(__clang__) && defined(__ARMCOMPILER_VERSION)defined(__clang__) && defined(__ti__)defined(__clang__)defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))defined(__LCC_MINOR__)defined(__GNUC__) && defined(__GNUC_MINOR__)defined(_MSC_FULL_VER)_MSC_VER >= 1400defined(_MSC_BUILD)defined(_ADI_COMPILER)defined(__VERSIONNUM__)defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)defined(__VER__) && defined(__ICCARM__)defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))defined(__DCC__) && defined(_DIAB_TOOL)defined(__SDCC_VERSION_MAJOR) || defined(SDCC)defined(__SDCC_VERSION_MAJOR)defined(__hpux) || defined(__hpua)SIMULATE_ID__QNXNTO__defined(__CRAYXT_COMPUTE_LINUX_TARGET)defined(__linux) || defined(__linux__) || defined(linux)defined(__MSYS__)defined(__CYGWIN__)defined(__MINGW32__)defined(__APPLE__)defined(_WIN32) || defined(__WIN32__) || defined(WIN32)defined(__FreeBSD__) || defined(__FreeBSD)defined(__NetBSD__) || defined(__NetBSD)defined(__OpenBSD__) || defined(__OPENBSD)defined(__sun) || defined(sun)defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)defined(__hpux) || defined(__hpux__)defined(__HAIKU__)defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)defined(__QNX__) || defined(__QNXNTO__)defined(__tru64) || defined(_tru64) || defined(__TRU64__)defined(__riscos) || defined(__riscos__)defined(__sinix) || defined(__sinix__) || defined(__SINIX__)defined(__UNIX_SV__)defined(__bsdos__)defined(_MPRAS) || defined(MPRAS)defined(__osf) || defined(__osf__)defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)defined(__XENIX__) || defined(_XENIX) || defined(XENIX)defined(__LINUX__)defined(__DOS__)defined(__OS2__)defined(__WINDOWS__)defined(__VXWORKS__)defined(__INTEGRITY)defined(INT_178B)defined(_WIN32) && defined(_MSC_VER)defined(_M_IA64)defined(_M_ARM64EC)defined(_M_X64) || defined(_M_AMD64)defined(_M_IX86)defined(_M_ARM64)defined(_M_ARM)_M_ARM == 4_M_ARM == 5defined(_M_MIPS)defined(_M_SH)defined(_M_I86)defined(__ICCARM__)defined(__ICCRX__)defined(__ICCRH850__)defined(__ICCRL78__)defined(__ICCRISCV__)defined(__ICCAVR__)defined(__ICC430__)defined(__ICCV850__)defined(__ICC8051__)defined(__ICCSTM8__)defined(__PPC64__)defined(__ppc__)defined(__ARM__)defined(__x86_64__)defined(__i386__)defined(__ARM_ARCH)defined(__TI_ARM__)defined(__MSP430__)defined(__TMS320C28XX__)defined(__TMS320C6X__) || defined(_TMS320C6X)defined(__ADSPSHARC__)defined(__ADSPBLACKFIN__)defined(__CTC__) || defined(__CPTC__)defined(__CMCS__)defined(__CARM__) || defined(__CPARM__)defined(__CARC__)defined(__C51__)defined(__CPCP__)defined(__CCRX__)defined(__CCRL__)defined(__CCRH__)COMPILER_VERSIONdefined(COMPILER_VERSION_MAJOR)COMPILER_VERSION_INTERNALdefined(COMPILER_VERSION_INTERNAL_STR)SIMULATE_VERSION_MAJORSIMULATE_VERSION_MINORSIMULATE_VERSION_PATCHSIMULATE_VERSION_TWEAK!defined(__STDC__) && !defined(__clang__) && !defined(__RENESAS__)defined(_MSC_VER) || defined(__ibmxl__) || defined(__IBMC__)C_STD > C_STD_17C_STD > C_STD_11C_STD > C_STD_99C_STD >= C_STD_99(defined(__clang__) || defined(__GNUC__) || defined(__xlC__) || defined(__TI_COMPILER_VERSION__) || defined(__RENESAS__)) && !defined(__STRICT_ANSI__)ID_VOID_MAINdefined(COMPILER_VERSION_INTERNAL) || defined(COMPILER_VERSION_INTERNAL_STR)199409L_MSC_FULL_VER_WIN32/*--------------------------------------------------------------------------*//* Construct a string literal encoding the version number components. *//* Construct a string literal encoding the internal version number. *//* Construct a string literal encoding the version number. *//* Convert integer to hex digit literals.  *//* Convert integer to decimal digit literals.  *//* unknown architecture *//* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*//* unknown platform *//* regular Integrity *//* Identify known platforms by name.  *//* unknown compiler *//* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  *//* SDCC = VRP *//* __VERSIONNUM__ = 0xVVRRPPTT *//* _MSC_FULL_VER = VVRRPPPP *//* _MSC_FULL_VER = VVRRPPPPP *//* _MSC_VER = VVRR *//* __ARMCC_VERSION = VRPPPP *//* __ARMCC_VERSION = VRRPPPP *//* __RENESAS_VERSION__ = 0xVVRRPP00 *//* __GHS_VERSION_NUMBER = VVVVRP *//* __TI_COMPILER_VERSION__ = VVVRRRPPP *//* __IBMC__ = VRP *//* __DECC_VER = VVRRTPPPP *//* __HP_cc = VVRRPP *//* __SUNPRO_CC = 0xVRP *//* __SUNPRO_C = 0xVRRP *//* __WATCOMC__ = VVRP + 1100 *//* __WATCOMC__ = VVRR *//* __BORLANDC__ = 0xVRR *//* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 *//* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD *//* The third version component from --version is an update index,
      but no macro is provided for it.  *//* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  *//* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  *//* If the compiler does not have __has_include, pretend the answer is
   always no.  *//* cv-qualifiers did not exist in K&R C */D:/PracticeInCodeQL/libpng/build/CMakeFiles/CMakeScratch/TryCompile-ct3v1q/src.cvoid_param_listsym2sym1D:/PracticeInCodeQL/libpng/build/CMakeFiles/CMakeScratch/TryCompile-ct3v1qD:/PracticeInCodeQL/libpng/build/CMakeFiles/CMakeScratchD:/PracticeInCodeQL/libpng/build/CMakeFiles/CMakeScratch/TryCompile-xln7jj/src.cD:/PracticeInCodeQL/libpng/build/CMakeFiles/CMakeScratch/TryCompile-xln7jjC:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.43.34808/include/vadefs.hva_list__va_startva_list *uintptr_t__crt_va_start(ap,x)__crt_va_start_a(ap, x)__crt_va_end(ap)((void)(ap = (va_list)0))__crt_va_arg(ap,t)((sizeof(t) > sizeof(__int64) || (sizeof(t) & (sizeof(t) - 1)) != 0) ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64)) : *(t* )((ap += sizeof(__int64)) - sizeof(__int64)))__crt_va_start_a(ap,x)((void)(__va_start(&ap, x)))_APALIGN(t,ap)(__alignof(t))_SLOTSIZEOF(t)(sizeof(t))_ADDRESSOF(v)(&(v))_UINTPTR_T_DEFINED_W64_VCRUNTIME_DISABLED_WARNINGS_VCRUNTIME_DISABLED_WARNING_4339 _VCRUNTIME_DISABLED_WARNING_4412 4514 4820 _VCRUNTIME_EXTRA_DISABLED_WARNINGS_VCRUNTIME_EXTRA_DISABLED_WARNINGS_VCRUNTIME_DISABLED_WARNING_4412_VCRUNTIME_DISABLED_WARNING_4339_CRT_PACKING_INC_VADEFSoncepack(push, _CRT_PACKING)_M_CEE_PUREwarning(push)warning(disable: _VCRUNTIME_DISABLED_WARNINGS)!defined _W64_WIN64_VA_LIST_DEFINED(defined _M_ARM || defined _M_HYBRID_X86_ARM64) && !defined _M_CEE_PURE(defined _M_ARM64 || defined _M_ARM64EC) && !defined _M_CEE_PUREdefined _M_CEE_PURE || (defined _M_CEE && !defined _M_ARM && !defined _M_ARM64)defined _M_IX86 && !defined _M_HYBRID_X86_ARM64defined _M_ARMdefined _M_HYBRID_X86_ARM64defined _M_ARM64defined _M_ARM64ECdefined _M_X64defined __cplusplus && !defined _CRT_NO_VA_START_VALIDATIONwarning(pop)pack(pop)// _VCRUNTIME_DISABLED_WARNINGS// ^^^ __cplusplus ^^^ // vvv !__cplusplus vvv //// extern "C++"// extern "C"//a hybrid va arg, to account for the shift in calling convention, with the alignment of ARM64//take the ARM64 va_start (for now)// C4820: '<typename>' : 'N' bytes padding added after data member (/Wall)// C4514: unreferenced inline function has been removed (/Wall)// Use _VCRUNTIME_EXTRA_DISABLED_WARNINGS to add additional warning suppressions to VCRuntime headers.//        C++ objects are unsafe to pass between pure code and mixed or native. (/Wall)// C4412: function signature contains type '<typename>';// C4339: '__type_info_node': use of undefined type detected in CLR meta-data (/Wall)//// that are used throughout the CRT.// explicitly or implicitly.  Therefore, this header also has several definitions// in the CRT header lattice, and is always the first CRT header to be included,// Definitions of macro helpers used by <stdarg.h>.  This is the topmost header//      Copyright (c) Microsoft Corporation. All rights reserved.// vadefs.hC:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.43.34808/includeC:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.43.34808C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVCC:/Program Files/Microsoft Visual Studio/2022/Community/VC/ToolsC:/Program Files/Microsoft Visual Studio/2022/Community/VCC:/Program Files/Microsoft Visual Studio/2022/CommunityC:/Program Files/Microsoft Visual Studio/2022C:/Program Files/Microsoft Visual StudioC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/corecrt_wstdio.h<corecrt_stdio_config.h><corecrt.h>_snwscanf_sconst wchar_tconst wchar_t *const wchar_t *constconst size_t_Result_ArgList_Format..(*)(..)const _locale_t__crt_locale_pointers *NULL_snwscanf_s_l_Locale_snwscanf_snwscanf_lswscanf_s_swscanf_s_lswscanf_swscanf_l_vsnwscanf_s_lunsigned long long *_CRT_INTERNAL_SCANF_SECURECRT_vsnwscanf_lvswscanf_s_vswscanf_s_l-118446744073709551615(size_t)-1vswscanf_vswscanf_l__stdio_common_vswscanf_scwprintf_p_scwprintf_p_l_scwprintf_scwprintf_l_snwprintf_swchar_t *wchar_t *const_snwprintf_s_l_snwprintf_snwprintf_l_swprintf_cC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrtC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0C:/Program Files (x86)/Windows Kits/10/IncludeC:/Program Files (x86)/Windows Kits/10C:/Program Files (x86)/Windows KitsC:/Program Files (x86)_Buffer_BufferCount_MaxCount_swprintf_c_l_swprintf_p_swprintf_p_lswprintf_s_swprintf_s_lswprintf_swprintf_swprintf_l__swprintf_l_vscwprintf_p_vscwprintf_p_lconst int2_CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR_vscwprintf_vscwprintf_l_vswprintf_p_vswprintf_p_lvswprintf_s_vswprintf_s_lvswprintf_vswprintf__vswprintf_l_vswprintf_l_vswprintf_c_vswprintf_c_l_vsnwprintf_vsnwprintf_s_vsnwprintf_s_l_vsnwprintf_l_CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION__stdio_common_vswprintf_p__stdio_common_vsnwprintf_s__stdio_common_vswprintf_s__stdio_common_vswprintfwscanf_sFILE *_iobuf *FILE *const_wscanf_s_lwscanf_wscanf_lfwscanf_s_fwscanf_s_lfwscanf_fwscanf_lvwscanf_s_vwscanf_s_lvwscanf_vwscanf_lvfwscanf_s_vfwscanf_s_lvfwscanf_vfwscanf_l__stdio_common_vfwscanf_wprintf_p_wprintf_p_lwprintf_s_wprintf_s_lwprintf_wprintf_l_fwprintf_p_fwprintf_p_lfwprintf_s_fwprintf_s_lfwprintf_Stream_fwprintf_l_vwprintf_p_vwprintf_p_lvwprintf_s_vwprintf_s_lvwprintf_vwprintf_l_vfwprintf_p_vfwprintf_p_lvfwprintf_s_vfwprintf_s_lvfwprintf_vfwprintf_l__stdio_common_vfwprintf_p__stdio_common_vfwprintf_s__stdio_common_vfwprintf_ungetwc_nolock_putwc_nolock_getwc_nolock_fputwc_nolock_fgetwc_nolock_wtmpnam_wtmpnam_s_wtempnam_wremove_wpopen_wfsopen_wfreopen_sFILE **_iobuf **_wfreopen_wfopen_s_wfopen_wfdopenungetwc_putwsputwcharputwc_getws_sfputwsfgetwsgetwchargetwc_fputwcharfputwc_fgetwcharfgetwc__acrt_iob_funcFILE_iobuf_Placeholder_SWPRINTFS_DEPRECATED_CRT_DEPRECATE_TEXT( "function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")WEOF((wint_t)(0xFFFF))stderr(__acrt_iob_func(2))stdout(__acrt_iob_func(1))stdin(__acrt_iob_func(0))_FILE_DEFINEDwarning(disable: _UCRT_DISABLED_WARNINGS)_CRT_FUNCTIONS_REQUIRED_CRT_USE_WINAPI_FAMILY_DESKTOP_APPpush_macro("_wtempnam")pop_macro("_wtempnam")defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL_M_CEE_MIXEDdefined _NO_CRT_STDIO_INLINE__STDC_WANT_SECURE_LIB___CRT_NON_CONFORMING_SWPRINTFS!defined RC_INVOKED && !defined __midl && !defined _INC_SWPRINTF_INL_warning(disable: 4141 6054)defined _CRT_NON_CONFORMING_SWPRINTFS && !defined __cplusplus_Success_(return >= 0) int__RETURN_POLICY_SAME_CRT_STDIO_INLINE__inline__CRTDECL__cdecl_Pre_notnull_ _Always_(_Post_z_)_In_z_ _Printf_format_string_ wchar_t const*wchar_t const*_Pre_notnull_ _Always_(_Post_z_) wchar_t_In_z_ _Printf_format_string_params_(2) wchar_t const*_In_opt_ _locale_t_locale_t_Pre_notnull_ _Post_maybez_ wchar_t_Out_writes_opt_(_BufferCount) _Post_maybez__In_ size_tsize_t_Success_(return != 0) wchar_t*wchar_t*__RETURN_POLICY_DST_ACRTIMP__declspec(dllimport)_Pre_maybenull_ _Always_(_Post_z_)_wperror_Prepost_valid_()_Pre_valid_ _Post_valid__SAL_nop_impl_XX _SAL_nop_impl_SAL_name"_Prepost_valid_""""1.1"_Post_valid__Post_valid_impl_"_Post_valid_""2"_Pre_valid__Pre1_impl_(__notnull_impl_notref) _Pre_valid_impl_"_Pre_valid_"__notnull_impl_notref_Inout__In_opt__Pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_ _Deref_pre_readonly_"_In_opt_"_Deref_pre_readonly__Deref_pre1_impl_(__readaccess_impl_notref)"_Deref_pre_readonly_"__readaccess_impl_notref__maybenull_impl_notref_Printf_format_string_params_(0)_Format_string_impl_("printf", 0)"_Printf_format_string_params_""printf"SAL_IsFormatString2_In_z__In_ _Pre1_impl_(__zterm_impl)"_In_z_"__zterm_impl_In__Pre1_impl_(__notnull_impl_notref) _Pre_valid_impl_ _Deref_pre1_impl_(__readaccess_impl_notref)"_In_""_Inout_"_Printf_format_string__Printf_format_string_impl_"_Printf_format_string_"_Scanf_s_format_string_params_(2)_Format_string_impl_("scanf_s", 2)"_Scanf_s_format_string_params_""scanf_s"_Pre_z__Pre1_impl_(__zterm_impl) _Pre_valid_impl_"_Pre_z_"_In_reads_(_BufferCount)_Pre_count_(_BufferCount) _Deref_pre_readonly_"_In_reads_"_Pre_count__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_impl(_BufferCount)) _Pre_valid_impl_"_Pre_count_"__count_impl(_BufferCount)return >= 0_Success_(return >= 0)_Success_impl_(return >= 0)"_Success_"_Scanf_format_string_params__Format_string_impl_("scanf", 2)"_Scanf_format_string_params_""scanf"_Scanf_s_format_string__Scanf_s_format_string_impl_"_Scanf_s_format_string_"_Format_string_impl_("scanf", 0)_Format_string_impl_("scanf_s", 0)_Scanf_format_string__Scanf_format_string_impl_"_Scanf_format_string_"_Check_return__Check_return_impl_"_Check_return_"_Out_writes__Pre_cap_(_BufferCount) _Post_valid_impl_"_Out_writes_"_Pre_cap__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(_BufferCount))"_Pre_cap_"__cap_impl(_BufferCount)(1)_Format_string_impl_("printf", 1)_Post_z__Post1_impl_(__zterm_impl) _Post_valid_impl_"_Post_z_"_Out_writes_opt__Pre_opt_cap_(_BufferCount) _Post_valid_impl_"_Out_writes_opt_"_Pre_opt_cap__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(_BufferCount))"_Pre_opt_cap_"_In_z_ wchar_t_Always_(_Post_z_) wchar_t_Post_maybez__Post1_impl_(__maybezterm_impl)"_Post_maybez_"__maybezterm_impl_Pre_notnull__Pre1_impl_(__notnull_impl_notref)"_Pre_notnull_"__swprintf_l_s_Format_string_impl_("printf", 2)_Out_writes_opt_z__Pre_opt_cap_(_BufferCount) _Post_valid_impl_ _Post_z_"_Out_writes_opt_z_"_Out_writes_z__Pre_cap_(_BufferCount) _Post_valid_impl_ _Post_z_"_Out_writes_z_"_Pre_maybenull__Pre1_impl_(__maybenull_impl_notref)"_Pre_maybenull_"_DLL_In_opt_z__In_opt_ _Pre1_impl_(__zterm_impl)"_In_opt_z_"return != 0(return != 0)_Success_impl_(return != 0)_Success_(return == 0) errno_treturn == 0(return == 0)_Success_impl_(return == 0)_Outptr_result_maybenull__Out_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(1))_Out_impl__Out_impl_ _SAL_nop_impl__Out_impl_ X_Out_impl_ X _SAL_nop_impl_"_Outptr_result_maybenull_"__count_impl(1)return == _Buffer(return == _Buffer)_Success_impl_(return == _Buffer)// _UCRT_DISABLED_WARNINGS// _CRT_FUNCTIONS_REQUIRED// SCANF//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+// Wide Character Formatted Input Functions (String)// !_INC_SWPRINTF_INL_// __cplusplus// C6054: string may not be zero-terminated// C4141: double deprecation// Wide Character Formatted Output Functions (String)// Wide Character Formatted Input Functions (Stream)// Wide Character Formatted Output Functions (Stream)// Variadic functions are not supported in managed code under /clr// I/O Synchronization and _nolock family of I/O functions// Wide Character Stream I/O Functions// Stream I/O Declarations Required by this Header// also shared by those two headers.// <stdio.h> and <wchar.h>.  It also defines several core I/O types, which are// This file declares the wide character (wchar_t) I/O functionality, shared by// corecrt_wstdio.h_Options_Args_Characterallocator_Directory_FilePrefix_FileName_Command_Mode_ErrorMessage_ShFlag_OldStream_FileHandle_IxC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/stdio.h<corecrt_wstdio.h>rmtmpputwgetwfputcharflushallfilenofgetcharfdopenfclosealltempnam_snscanf_sconst char *const_snscanf_s_l_snscanf_snscanf_lsscanf_s_sscanf_s_lsscanf_sscanf_lvsscanf_s_vsscanf_s_lvsscanf_vsscanf_l__stdio_common_vsscanf_scprintf_p_scprintf_p_l_scprintf_scprintf_l_snprintf_schar *const_snprintf_s_l_snprintf_c_snprintf_c_l_snprintfsnprintf_snprintf_l_sprintf_p_sprintf_p_lsprintf_s_sprintf_s_lsprintf_sprintf_l_vsnprintf_c_vsnprintf_c_l_vscprintf_p_vscprintf_p_l_vscprintf_vscprintf_lvsnprintf_s_vsnprintf_s_vsnprintf_s_l_vsprintf_p_vsprintf_p_lvsprintf_s_vsprintf_s_lvsprintf_vsprintf_lvsnprintf_vsnprintf_vsnprintf_l__stdio_common_vsprintf_p__stdio_common_vsnprintf_s__stdio_common_vsprintf_s__stdio_common_vsprintfscanf_s_scanf_s_lscanf_scanf_lfscanf_s_fscanf_s_lfscanf_fscanf_lvscanf_s_vscanf_s_lvscanf_vscanf_lvfscanf_s_vfscanf_s_lvfscanf_vfscanf_l__stdio_common_vfscanf_printf_p_printf_p_lprintf_s_printf_s_lprintf_printf_l_fprintf_p_fprintf_p_lfprintf_s_fprintf_s_l_get_printf_count_output_set_printf_count_outputfprintf_fprintf_l_vprintf_p_vprintf_p_lvprintf_s_vprintf_s_lvprintf_vprintf_l_vfprintf_p_vfprintf_p_lvfprintf_s_vfprintf_s_lvfprintf_vfprintf_l__stdio_common_vfprintf_p__stdio_common_vfprintf_s__stdio_common_vfprintfint *__p__commode_ungetc_nolock_putc_nolock_getc_nolock_fwrite_nolockconst voidconst void *_ftelli64_nolock_ftell_nolock_fseeki64_nolock_fseek_nolock_fread_nolock_s_fread_nolock_fputc_nolock_fgetc_nolock_fflush_nolock_fclose_nolock_unlock_file_lock_fileungetctmpnamtmpfile_tempnamsetvbuf_setmaxstdiosetbuf_rmtmprewindunlink_unlinkrenameremove_putwputsputcharputc_popen_pclose_getw_getmaxstdiogetchargetcfwrite_ftelli64ftell_fseeki64fseekfsetposconst fpos_tconst fpos_t *long long *_fsopenfreopenfreadfputs_fputcharfputcfopen_flushall_filenofgetsfgetposfpos_t *_fgetcharfgetcfflushferrorfeof_fdopen_fcloseallfcloseclearerrtmpnam_stmpfile_sgets_sfreopen_sfread_sfopen_sclearerr_s_get_stream_buffer_pointerschar ***int **fpos_tSYS_OPEN_SYS_OPEN_commode(*__p__commode())_putwchar_nolock(_Ch)_putwc_nolock(_Ch, stdout)_getwchar_nolock()_getwc_nolock(stdin)_putchar_nolock(_Ch)_putc_nolock(_Ch, stdout)_getchar_nolock()_getc_nolock(stdin)_TMP_MAX_STMP_MAXTMP_MAX_S_CRT_INT_MAX20FOPEN_MAXFILENAME_MAX260SEEK_SETSEEK_ENDSEEK_CURL_tmpnam_sL_tmpnam_IONBF0x0004_IOLBF0x0040_IOFBFEOF(-1)_IOB_ENTRIES_NSTREAM_512_NFILEBUFSIZ_INC_STDIOdefined _CRT_USE_WINAPI_FAMILY_DESKTOP_APPdefined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMESdefined _DEBUG && defined _CRTDBG_MAP_ALLOC_CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLYdefined _M_CEE_MIXEDdefined vsnprintfdefined snprintfwarning(disable: 6530)__EMPTY_DECLSPEC_Pre_notnull_ _Post_maybez_ char_In_z_ _Printf_format_string_ char const*char const*_Success_(return != 0) char*char*perror_Always_(_Post_z_) char_In_reads_bytes__Pre_bytecount_(_BufferCount) _Deref_pre_readonly_"_In_reads_bytes_"_Pre_bytecount__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_impl(_BufferCount)) _Pre_valid_impl_"_Pre_bytecount_"__bytecount_impl(_BufferCount)_DEBUG_In_z_ char const>=_ElementSize * _ElementCount_In_range_(>=,_ElementSize * _ElementCount)_In_range_impl_(>=,_ElementSize * _ElementCount)"_In_range_"_BufferSize_Out_writes_bytes_to_(_BufferSize,_ElementSize * _ElementCount)_Pre_bytecap_(_BufferSize) _Post_valid_impl_ _Post_bytecount_(_ElementSize * _ElementCount)"_Out_writes_bytes_to_"_Post_bytecount_(_ElementSize * _ElementCount)_Post1_impl_(__bytecount_impl(_ElementSize * _ElementCount)) _Post_valid_impl_"_Post_bytecount_"__bytecount_impl(_ElementSize * _ElementCount)_Pre_bytecap_(_BufferSize)_Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl(_BufferSize))"_Pre_bytecap_"__bytecap_impl(_BufferSize)_Pre_bytecount_(_ElementSize * _ElementCount) _Deref_pre_readonly__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_impl(_ElementSize * _ElementCount)) _Pre_valid_impl_return != EOFreturn != (-1)(return != (-1))_Success_impl_(return != (-1))_Out_writes_bytes__Pre_bytecap_(_ElementSize * _ElementCount) _Post_valid_impl_"_Out_writes_bytes_"_Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl(_ElementSize * _ElementCount))__bytecap_impl(_ElementSize * _ElementCount)_Inout_opt__Prepost_opt_valid_"_Inout_opt_"_Pre_opt_valid_ _Post_valid_"_Prepost_opt_valid_"_Pre_opt_valid__Pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_"_Pre_opt_valid_"_Size_Inout_updates_opt_(_Size)_Pre_opt_cap_(_Size) _Pre_valid_impl_ _Post_valid_impl_"_Inout_updates_opt_"_Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(_Size))__cap_impl(_Size)_Post_readable_size__Post1_impl_(__count_impl(0)) _Post_valid_impl_"_Post_readable_size_"__count_impl(0)(512)_Pre_opt_cap_(512) _Pre_valid_impl_ _Post_valid_impl__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(512))__cap_impl(512)(_MaxCount)_Pre_cap_(_MaxCount) _Post_valid_impl_ _Post_z__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(_MaxCount))__cap_impl(_MaxCount)_Out_"_Out_"return != -1(return != -1)_Success_impl_(return != -1)__null_impl_notref_Deref_post_null__Deref_post1_impl_(__null_impl_notref)_Outptr__Out_impl_ _Deref_post2_impl_(__notnull_impl_notref, __count_impl(1))"_Outptr_"_Outptr_result_nullonfailure__Outptr_ _On_failure_(_Deref_post_null_)_Out_opt__Out_opt_impl__Out_opt_impl_ _SAL_nop_impl__Out_opt_impl_ X_Out_opt_impl_ X _SAL_nop_impl_"_Out_opt_"_Pre_cap_(_Size) _Post_valid_impl_ _Post_z__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(_Size))_Deref_post_valid__Deref_post1_impl_(__notnull_impl_notref) _Post_valid_impl_"_Deref_post_valid_""_Outptr_result_nullonfailure_""_Deref_post_null_"// _INC_STDIO// _CRT_INTERNAL_NONSTDC_NAMES// Non-ANSI Names for Compatibility// Unrecognized SAL format string// Narrow Character Formatted Input Functions (String)// macro redefinition// of snprintf was.  This makes it easier to find where snprintf was defined.// redefinition" with a subsequent line indicating where the previous definition// This definition of snprintf will generate "warning C4005: 'snprintf': macro// of vsnprintf was.  This makes it easier to find where vsnprintf was defined.// This definition of vsnprintf will generate "warning C4005: 'vsnprintf': macro// Narrow Character Formatted Output Functions (String)// Narrow Character Formatted Input Functions (Stream)// Narrow Character Formatted Output Functions (Stream)// Narrow Character Stream I/O Functions/* Seek method constants */// _MAX_PATH/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 *//*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 *//* Buffered I/O macros */// include guard for 3rd party interop// The C Standard Library <stdio.h> header.// stdio.h_Ch_Arglist_Value_ElementSize_ElementCount_Offset_Origin_DirectoryName_Maximum_OldFileName_NewFileName_Word_Position_Base_Pointer_CountD:/PracticeInCodeQL/libpng/png.h"pngconf.h""pnglibconf.h"png_write_frame_tailpng_struct *png_struct_def *png_info *png_info_def *png_write_frame_headpng_byte *unsigned char *png_byte **unsigned char **png_set_progressive_frame_fnpng_read_frame_headpng_set_first_frame_is_hiddenpng_get_first_frame_is_hiddenpng_get_next_frame_blend_oppng_get_next_frame_dispose_oppng_get_next_frame_delay_denpng_get_next_frame_delay_numpng_get_next_frame_y_offsetpng_get_next_frame_x_offsetpng_get_next_frame_heightpng_get_next_frame_widthpng_set_next_frame_fcTLpng_get_next_frame_fcTLpng_uint_32 *unsigned int *png_uint_16 *png_get_num_playspng_get_num_framespng_set_acTLpng_get_acTLpng_set_optionpng_image_write_to_memorypng_image *struct <unnamed> *png_alloc_size_t *png_image_write_to_stdiopng_image_write_to_filepng_image_freepng_image_finish_readconst png_colorconst png_color *png_color_struct *png_image_begin_read_from_memorypng_image_begin_read_from_stdiopng_image_begin_read_from_filepng_get_palette_maxconst png_structconst png_struct *const png_infoconst png_info *png_set_check_for_invalid_indexpng_save_uint_16png_save_int_32png_save_uint_32png_get_uint_31const png_byteconst png_byte *png_get_int_32png_get_uint_16png_get_uint_32png_get_io_chunk_typepng_get_io_statepng_get_pHYs_dpipng_get_y_offset_inches_fixedpng_get_y_offset_inchespng_get_x_offset_inches_fixedpng_get_x_offset_inchespng_get_y_pixels_per_inchpng_get_x_pixels_per_inchpng_get_pixels_per_inchpng_get_chunk_malloc_maxpng_set_chunk_malloc_maxpng_get_chunk_cache_maxpng_set_chunk_cache_maxpng_get_user_height_maxpng_get_user_width_maxpng_set_user_limitspng_permit_mng_featurespng_get_libpng_verpng_get_header_versionpng_get_header_verpng_get_copyrightpng_write_pngpng_read_pngpng_set_invalidpng_get_unknown_chunkspng_unknown_chunk *png_unknown_chunk_t *png_unknown_chunk **png_unknown_chunk_t **png_set_unknown_chunk_locationpng_set_unknown_chunksconst png_unknown_chunkconst png_unknown_chunk *png_handle_as_unknownpng_set_keep_unknown_chunkspng_set_sCAL_spng_set_sCAL_fixedpng_set_sCALpng_get_sCAL_spng_get_sCAL_fixedpng_fixed_point *png_get_sCALdouble *png_set_tRNSconst png_color_16const png_color_16 *png_color_16_struct *png_get_tRNSpng_color_16 *png_color_16 **png_color_16_struct **png_set_tIMEconst png_timeconst png_time *png_time_struct *png_get_tIMEpng_time *png_time **png_time_struct **png_set_textconst png_textconst png_text *png_text_struct *png_get_textpng_text *png_text **png_text_struct **png_set_sPLTconst png_sPLT_tconst png_sPLT_t *png_sPLT_struct *png_get_sPLTpng_sPLT_t *png_sPLT_t **png_sPLT_struct **png_set_iCCPpng_get_iCCPpng_set_sRGB_gAMA_and_cHRMpng_set_sRGBpng_get_sRGBpng_set_sBITconst png_color_8const png_color_8 *png_color_8_struct *png_get_sBITpng_color_8 *png_color_8 **png_color_8_struct **png_set_PLTEpng_get_PLTEpng_color *png_color **png_color_struct **png_set_pHYspng_get_pHYspng_set_pCALpng_get_pCALpng_int_32 *png_set_oFFspng_get_oFFspng_set_mDCV_fixedpng_set_mDCVpng_get_mDCV_fixedpng_get_mDCVpng_set_IHDRpng_get_IHDRpng_set_hISTconst png_uint_16const png_uint_16 *png_get_hISTpng_uint_16 **unsigned short **png_set_gAMA_fixedpng_set_gAMApng_get_gAMA_fixedpng_get_gAMApng_set_eXIf_1png_get_eXIf_1png_set_cLLI_fixedpng_set_cLLIpng_get_cLLI_fixedpng_get_cLLIpng_set_cICPpng_get_cICPpng_set_cHRM_XYZ_fixedpng_set_cHRM_fixedpng_set_cHRM_XYZpng_set_cHRMpng_get_cHRM_XYZ_fixedpng_get_cHRM_fixedpng_get_cHRM_XYZpng_get_cHRMpng_set_bKGDpng_get_bKGDpng_get_signaturepng_get_y_offset_micronspng_get_x_offset_micronspng_get_y_offset_pixelspng_get_x_offset_pixelspng_get_pixel_aspect_ratio_fixedpng_get_pixel_aspect_ratiopng_get_y_pixels_per_meterpng_get_x_pixels_per_meterpng_get_pixels_per_meterpng_get_compression_typepng_get_interlace_typepng_get_filter_typepng_get_color_typepng_get_bit_depthpng_get_image_heightpng_get_image_widthpng_get_channelspng_set_rowspng_get_rowspng_get_rowbytespng_get_validpng_set_benign_errorspng_chunk_benign_errorpng_benign_errorpng_chunk_warningpng_warningpng_chunk_errorpng_errorpng_free_defaultpng_malloc_defaultpng_data_freerpng_free_datapng_freepng_malloc_warnpng_callocpng_mallocpng_progressive_combine_rowpng_process_data_skippng_process_data_pausepng_process_datapng_get_progressive_ptrpng_set_progressive_read_fnpng_get_user_chunk_ptrpng_set_read_user_chunk_fnpng_get_current_pass_numberpng_get_current_row_numberpng_get_user_transform_ptrpng_set_user_transform_infopng_set_write_user_transform_fnpng_set_read_user_transform_fnpng_get_mem_ptrpng_set_mem_fnpng_set_write_status_fnpng_set_read_status_fnpng_get_io_ptrpng_set_read_fnpng_set_write_fnpng_get_error_ptrpng_set_error_fnpng_init_iopng_set_text_compression_methodpng_set_text_compression_window_bitspng_set_text_compression_strategypng_set_text_compression_mem_levelpng_set_text_compression_levelpng_set_compression_methodpng_set_compression_window_bitspng_set_compression_strategypng_set_compression_mem_levelpng_set_compression_levelpng_set_filterpng_set_crc_actionpng_destroy_write_structpng_struct **png_struct_def **png_info **png_info_def **png_destroy_read_structpng_destroy_info_structpng_read_endpng_write_endpng_write_imagepng_write_rowspng_write_rowpng_read_imagepng_read_rowpng_read_rowspng_read_update_infopng_start_read_imagepng_write_flushpng_set_flushpng_set_gamma_fixedpng_set_gammapng_set_quantizepng_set_strip_16png_set_scale_16png_set_background_fixedpng_set_backgroundpng_set_invert_monopng_set_interlace_handlingpng_set_shiftpng_set_packswappng_set_packingpng_set_swappng_set_add_alphapng_set_fillerpng_set_invert_alphapng_set_swap_alphapng_set_strip_alphapng_set_alpha_mode_fixedpng_set_alpha_modepng_build_grayscale_palettepng_get_rgb_to_gray_statuspng_set_rgb_to_gray_fixedpng_set_rgb_to_graypng_set_gray_to_rgbpng_set_bgrpng_set_expand_16png_set_tRNS_to_alphapng_set_palette_to_rgbpng_set_expand_gray_1_2_4_to_8png_set_expandpng_convert_from_time_tpng_convert_from_struct_tmconst tmconst tm *tm *png_convert_to_rfc1123_buffer(char out[29], const png_time *ptime)29png_read_infopng_write_infopng_write_info_before_PLTEpng_info_init_3png_create_info_structpng_write_chunk_endpng_write_chunk_datapng_write_chunk_startpng_write_chunkpng_write_sigpng_create_write_struct_2png_create_read_struct_2png_reset_zstreampng_longjmpjmp_buf *_SETJMP_FLOAT128[16]16_SETJMP_FLOAT128(*)[16]png_set_longjmp_fnpng_set_compression_buffer_sizepng_get_compression_buffer_sizepng_create_write_structpng_create_read_structpng_sig_cmppng_set_sig_bytespng_access_version_numberpng_imageppng_image(unnamed class/struct/union)png_control *png_control_def *png_controlppng_controlpng_control_defpng_free_ptr*png_free_ptr(png_struct *, void *)png_malloc_ptr*png_malloc_ptr(png_struct *, png_alloc_size_t)_JBTYPE *_SETJMP_FLOAT128 *png_longjmp_ptr(*png_longjmp_ptr)(jmp_buf, int)typedefpng_user_chunk_ptr*png_user_chunk_ptr(png_struct *, png_unknown_chunk *)png_row_info *png_row_info_struct *png_user_transform_ptr*png_user_transform_ptr(png_struct *, png_row_info *, png_byte *)png_progressive_row_ptr*png_progressive_row_ptr(png_struct *, png_byte *, png_uint_32, int)png_progressive_frame_ptr*png_progressive_frame_ptr(png_struct *, png_uint_32)png_progressive_end_ptr*png_progressive_end_ptr(png_struct *, png_info *)png_progressive_info_ptr*png_progressive_info_ptrpng_write_status_ptr*png_write_status_ptr(png_struct *, png_uint_32, int)png_read_status_ptr*png_read_status_ptrpng_flush_ptr*png_flush_ptr(png_struct *)png_rw_ptr*png_rw_ptr(png_struct *, png_byte *, size_t)png_error_ptr*png_error_ptr(png_struct *, const char *)png_row_info **png_row_info_struct **png_row_infopppng_row_infoppng_row_infopng_row_info_structpng_unknown_chunkpppng_const_unknown_chunkppng_unknown_chunkppng_unknown_chunkpng_unknown_chunk_tpng_timepppng_const_timeppng_timeppng_timepng_time_structpng_textpppng_const_textppng_textppng_textpng_text_structpng_sPLT_tpppng_const_sPLT_tppng_sPLT_tppng_sPLT_tpng_sPLT_structpng_sPLT_entry *png_sPLT_entry_struct *png_sPLT_entry **png_sPLT_entry_struct **png_sPLT_entryppconst png_sPLT_entryconst png_sPLT_entry *png_const_sPLT_entryppng_sPLT_entryppng_sPLT_entrypng_sPLT_entry_structpng_color_8pppng_const_color_8ppng_color_8ppng_color_8png_color_8_structpng_color_16pppng_const_color_16ppng_color_16ppng_color_16png_color_16_structpng_colorpppng_const_colorppng_colorppng_colorpng_color_structconst png_info *restrictpng_const_inforppng_info *restrictpng_inforppng_infopppng_const_infoppng_infoppng_infopng_info_defconst png_struct *restrictpng_const_structrppng_struct *restrictpng_structrppng_structpppng_structppng_const_structppng_structpng_struct_defpng_libpng_version_1_8_0_gitchar[64]64messagewarning_or_errorcolormap_entriesflagsformatheightwidthversionopaquepixel_depthchannelsbit_depthcolor_typerowbyteslocationsizedatapng_byte[5]unsigned char[5]5namesecondminutehourdaymonthyearlang_keylangitxt_lengthtext_lengthtextkeycompressionnentriesentriesdepthfrequencyalphabluegreenredgrayindexPNG_OPTION_ONPNG_OPTION_OFFPNG_OPTION_INVALIDPNG_OPTION_UNSETPNG_OPTION_NEXTPNG_SKIP_sRGB_CHECK_PROFILE6PNG_MAXIMUM_INFLATE_WINDOWPNG_MIPS_MMIPNG_RISCV_RVVPNG_POWERPC_VSXPNG_MIPS_MSAPNG_ARM_NEONPNG_TARGET_SPECIFIC_CODEPNG_SET_OPTION_SUPPORTEDPNG_IMAGE_PNG_SIZE_MAX(image)PNG_IMAGE_PNG_SIZE_MAX_(image, PNG_IMAGE_COMPRESSED_SIZE_MAX(image))PNG_IMAGE_PNG_SIZE_MAX_(image,image_size)((8U +25U +16U +44U +12U + (((image).format&PNG_FORMAT_FLAG_COLORMAP)? 12U+3U*(image).colormap_entries + (((image).format&PNG_FORMAT_FLAG_ALPHA)? 12U +(image).colormap_entries:0U):0U)+ 12U)+(12U*((image_size)/PNG_ZBUF_SIZE)) +(image_size))PNG_IMAGE_COMPRESSED_SIZE_MAX(image)PNG_ZLIB_MAX_SIZE((png_alloc_size_t)PNG_IMAGE_DATA_SIZE(image))PNG_ZLIB_MAX_SIZE(b)((b)+(((b)+7U)>>3)+(((b)+63U)>>6)+11U)PNG_IMAGE_DATA_SIZE(image)(PNG_IMAGE_SIZE(image)+(image).height)png_image_write_get_memory_size(image,size,convert_to_8_bit,buffer,row_stride,colormap)png_image_write_to_memory(&(image), 0, &(size), convert_to_8_bit, buffer, row_stride, colormap)PNG_IMAGE_FLAG_16BIT_sRGB0x04PNG_IMAGE_FLAG_FAST0x02PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB0x01PNG_IMAGE_COLORMAP_SIZE(image)(PNG_IMAGE_SAMPLE_SIZE((image).format) * (image).colormap_entries)PNG_IMAGE_SIZE(image)PNG_IMAGE_BUFFER_SIZE(image, PNG_IMAGE_ROW_STRIDE(image))PNG_IMAGE_BUFFER_SIZE(image,row_stride)(PNG_IMAGE_PIXEL_COMPONENT_SIZE((image).format)*(image).height*(row_stride))PNG_IMAGE_ROW_STRIDE(image)(PNG_IMAGE_PIXEL_CHANNELS((image).format) * (image).width)PNG_IMAGE_PIXEL_SIZE(fmt)PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_SIZE,fmt)PNG_IMAGE_PIXEL_COMPONENT_SIZE(fmt)PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_COMPONENT_SIZE,fmt)PNG_IMAGE_PIXEL_CHANNELS(fmt)PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_CHANNELS,fmt)PNG_IMAGE_PIXEL_(test,fmt)(((fmt)&PNG_FORMAT_FLAG_COLORMAP)?1:test(fmt))PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(fmt)(PNG_IMAGE_SAMPLE_CHANNELS(fmt) * 256)PNG_IMAGE_SAMPLE_SIZE(fmt)(PNG_IMAGE_SAMPLE_CHANNELS(fmt) * PNG_IMAGE_SAMPLE_COMPONENT_SIZE(fmt))PNG_IMAGE_SAMPLE_COMPONENT_SIZE(fmt)((((fmt) & PNG_FORMAT_FLAG_LINEAR) >> 2)+1)PNG_IMAGE_SAMPLE_CHANNELS(fmt)(((fmt)&(PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA))+1)PNG_FORMAT_ABGR_COLORMAP(PNG_FORMAT_ABGR|PNG_FORMAT_FLAG_COLORMAP)PNG_FORMAT_BGRA_COLORMAP(PNG_FORMAT_BGRA|PNG_FORMAT_FLAG_COLORMAP)PNG_FORMAT_ARGB_COLORMAP(PNG_FORMAT_ARGB|PNG_FORMAT_FLAG_COLORMAP)PNG_FORMAT_RGBA_COLORMAP(PNG_FORMAT_RGBA|PNG_FORMAT_FLAG_COLORMAP)PNG_FORMAT_BGR_COLORMAP(PNG_FORMAT_BGR|PNG_FORMAT_FLAG_COLORMAP)PNG_FORMAT_RGB_COLORMAP(PNG_FORMAT_RGB|PNG_FORMAT_FLAG_COLORMAP)PNG_FORMAT_LINEAR_RGB_ALPHA(PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA)PNG_FORMAT_LINEAR_RGB(PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLOR)PNG_FORMAT_LINEAR_Y_ALPHA(PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_ALPHA)PNG_FORMAT_LINEAR_YPNG_FORMAT_FLAG_LINEARPNG_FORMAT_ABGR(PNG_FORMAT_BGRA|PNG_FORMAT_FLAG_AFIRST)PNG_FORMAT_BGRA(PNG_FORMAT_BGR|PNG_FORMAT_FLAG_ALPHA)PNG_FORMAT_ARGB(PNG_FORMAT_RGBA|PNG_FORMAT_FLAG_AFIRST)PNG_FORMAT_RGBA(PNG_FORMAT_RGB|PNG_FORMAT_FLAG_ALPHA)PNG_FORMAT_BGR(PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_BGR)PNG_FORMAT_RGBPNG_FORMAT_FLAG_COLORPNG_FORMAT_AG(PNG_FORMAT_GA|PNG_FORMAT_FLAG_AFIRST)PNG_FORMAT_GAPNG_FORMAT_FLAG_ALPHAPNG_FORMAT_GRAYPNG_FORMAT_FLAG_ASSOCIATED_ALPHA0x40UPNG_FORMAT_FLAG_AFIRST0x20UPNG_FORMAT_FLAG_BGR0x10UPNG_FORMAT_FLAG_COLORMAP0x08U0x04U0x02U0x01UPNG_IMAGE_FAILED(png_cntrl)((((png_cntrl).warning_or_error)&0x03)>1)PNG_IMAGE_ERRORPNG_IMAGE_WARNINGPNG_IMAGE_VERSIONpng_get_int_32(buf)PNG_get_int_32(buf)png_get_uint_16(buf)PNG_get_uint_16(buf)png_get_uint_32(buf)PNG_get_uint_32(buf)((png_int_32)((*(buf) & 0x80) ? -((png_int_32)(((png_get_uint_32(buf)^0xffffffffU)+1U)&0x7fffffffU)) : (png_int_32)png_get_uint_32(buf)))((png_uint_16) (((unsigned int)(*(buf)) << 8) + ((unsigned int)(*((buf) + 1)))))(((png_uint_32)(*(buf)) << 24) + ((png_uint_32)(*((buf) + 1)) << 16) + ((png_uint_32)(*((buf) + 2)) << 8) + ((png_uint_32)(*((buf) + 3))))png_composite_16(composite,fg,alpha,bg){ png_uint_32 temp = (png_uint_32)((png_uint_32)(fg) * (png_uint_32)(alpha) + (png_uint_32)(bg)*(65535 - (png_uint_32)(alpha)) + 32768); (composite) = (png_uint_16)(0xffff & ((temp + (temp >> 16)) >> 16)); }png_composite(composite,fg,alpha,bg){ png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) * (png_uint_16)(alpha) + (png_uint_16)(bg)*(png_uint_16)(255 - (png_uint_16)(alpha)) + 128); (composite) = (png_byte)(((temp + (temp >> 8)) >> 8) & 0xff); }PNG_COL_IN_INTERLACE_PASS(x,pass)((PNG_PASS_MASK(pass,1) >> ((x)&7)) & 1)PNG_ROW_IN_INTERLACE_PASS(y,pass)((PNG_PASS_MASK(pass,0) >> ((y)&7)) & 1)PNG_PASS_MASK(pass,off)( ((0x110145AF>>(((7-(off))-(pass))<<2)) & 0xF) | ((0x01145AF0>>(((7-(off))-(pass))<<2)) & 0xF0))PNG_COL_FROM_PASS_COL(x_in,pass)(((x_in)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))PNG_ROW_FROM_PASS_ROW(y_in,pass)(((y_in)<<PNG_PASS_ROW_SHIFT(pass))+PNG_PASS_START_ROW(pass))PNG_PASS_COLS(width,pass)(((width)+(((1<<PNG_PASS_COL_SHIFT(pass)) -1)-PNG_PASS_START_COL(pass)))>>PNG_PASS_COL_SHIFT(pass))PNG_PASS_ROWS(height,pass)(((height)+(((1<<PNG_PASS_ROW_SHIFT(pass)) -1)-PNG_PASS_START_ROW(pass)))>>PNG_PASS_ROW_SHIFT(pass))PNG_PASS_COL_SHIFT(pass)((pass)>1?(7-(pass))>>1:3)PNG_PASS_ROW_SHIFT(pass)((pass)>2?(8-(pass))>>1:3)PNG_PASS_COL_OFFSET(pass)(1<<((7-(pass))>>1))PNG_PASS_ROW_OFFSET(pass)((pass)>2?(8>>(((pass)-1)>>1)):8)PNG_PASS_START_COL(pass)(((1& (pass))<<(3-(((pass)+1)>>1)))&7)PNG_PASS_START_ROW(pass)(((1&~(pass))<<(3-((pass)>>1)))&7)PNG_INTERLACE_ADAM7_PASSES7PNG_IO_MASK_LOC0x00f0PNG_IO_MASK_OP0x000fPNG_IO_CHUNK_CRC0x0080PNG_IO_CHUNK_DATAPNG_IO_CHUNK_HDR0x0020PNG_IO_SIGNATURE0x0010PNG_IO_WRITING0x0002PNG_IO_READING0x0001PNG_IO_NONEPNG_HANDLE_CHUNK_LASTPNG_HANDLE_CHUNK_ALWAYSPNG_HANDLE_CHUNK_IF_SAFEPNG_HANDLE_CHUNK_NEVERPNG_HANDLE_CHUNK_AS_DEFAULTPNG_FREE_MUL0x4220UPNG_FREE_ALL0xffffUPNG_FREE_EXIF0x8000UPNG_FREE_TEXT0x4000UPNG_FREE_TRNS0x2000UPNG_FREE_PLTE0x1000UPNG_FREE_UNKN0x0200UPNG_FREE_SCAL0x0100UPNG_FREE_PCAL0x0080UPNG_FREE_ROWS0x0040UPNG_FREE_SPLT0x0020UPNG_FREE_ICCP0x0010UPNG_FREE_HIST0x0008UPNG_USER_WILL_FREE_DATAPNG_SET_WILL_FREE_DATAPNG_DESTROY_WILL_FREE_DATAPNG_FILTER_VALUE_LASTPNG_FILTER_VALUE_PAETHPNG_FILTER_VALUE_AVGPNG_FILTER_VALUE_UPPNG_FILTER_VALUE_SUBPNG_FILTER_VALUE_NONEPNG_ALL_FILTERS(PNG_FAST_FILTERS | PNG_FILTER_AVG | PNG_FILTER_PAETH)PNG_FAST_FILTERS(PNG_FILTER_NONE | PNG_FILTER_SUB | PNG_FILTER_UP)PNG_FILTER_PAETH0x80PNG_FILTER_AVG0x40PNG_FILTER_UP0x20PNG_FILTER_SUB0x10PNG_FILTER_NONE0x08PNG_NO_FILTERS0x00PNG_CRC_NO_CHANGEPNG_CRC_QUIET_USEPNG_CRC_WARN_USEPNG_CRC_WARN_DISCARDPNG_CRC_ERROR_QUITPNG_CRC_DEFAULTPNG_GAMMA_THRESHOLD(PNG_GAMMA_THRESHOLD_FIXED*.00001)PNG_READ_16_TO_8_SUPPORTEDPNG_BACKGROUND_GAMMA_UNIQUEPNG_BACKGROUND_GAMMA_FILEPNG_BACKGROUND_GAMMA_SCREENPNG_BACKGROUND_GAMMA_UNKNOWNPNG_FILLER_AFTERPNG_FILLER_BEFOREPNG_GAMMA_LINEARPNG_FP_1PNG_GAMMA_sRGB220000PNG_GAMMA_MAC_18-2PNG_DEFAULT_sRGBPNG_ALPHA_BROKENPNG_ALPHA_OPTIMIZEDPNG_ALPHA_PREMULTIPLIEDPNG_ALPHA_ASSOCIATEDPNG_ALPHA_STANDARDPNG_ALPHA_PNGPNG_RGB_TO_GRAY_DEFAULTPNG_ERROR_ACTION_ERRORPNG_ERROR_ACTION_WARNPNG_ERROR_ACTION_NONEpng_jmpbuf(png_ptr)(*png_set_longjmp_fn((png_ptr), longjmp, (sizeof (jmp_buf))))PNG_ALL_MNG_FEATURES0x05PNG_FLAG_MNG_FILTER_64PNG_FLAG_MNG_EMPTY_PLTEPNG_TRANSFORM_SCALE_160x8000PNG_TRANSFORM_EXPAND_160x4000PNG_TRANSFORM_GRAY_TO_RGB0x2000PNG_TRANSFORM_STRIP_FILLER_AFTER0x1000PNG_TRANSFORM_STRIP_FILLER_BEFOREPNG_TRANSFORM_STRIP_FILLER0x0800PNG_TRANSFORM_INVERT_ALPHA0x0400PNG_TRANSFORM_SWAP_ENDIAN0x0200PNG_TRANSFORM_SWAP_ALPHA0x0100PNG_TRANSFORM_BGRPNG_TRANSFORM_SHIFTPNG_TRANSFORM_INVERT_MONOPNG_TRANSFORM_EXPANDPNG_TRANSFORM_PACKSWAP0x0008PNG_TRANSFORM_PACKINGPNG_TRANSFORM_STRIP_ALPHAPNG_TRANSFORM_STRIP_16PNG_TRANSFORM_IDENTITYPNG_INFO_fdAT0x400000UPNG_INFO_fcTL0x200000UPNG_INFO_acTL0x100000UPNG_INFO_mDCV0x80000UPNG_INFO_cLLI0x40000UPNG_INFO_cICP0x20000UPNG_INFO_eXIf0x10000UPNG_INFO_IDATPNG_INFO_sCALPNG_INFO_sPLTPNG_INFO_iCCPPNG_INFO_sRGB0x0800UPNG_INFO_pCAL0x0400UPNG_INFO_tIMEPNG_INFO_oFFsPNG_INFO_pHYsPNG_INFO_hISTPNG_INFO_bKGDPNG_INFO_tRNSPNG_INFO_PLTEPNG_INFO_cHRM0x0004UPNG_INFO_sBIT0x0002UPNG_INFO_gAMA0x0001UPNG_MAX_PALETTE_LENGTH256PNG_KEYWORD_MAX_LENGTHPNG_fcTL_BLEND_OP_LASTPNG_fcTL_BLEND_OP_OVERPNG_fcTL_BLEND_OP_SOURCEPNG_fcTL_DISPOSE_OP_LASTPNG_fcTL_DISPOSE_OP_PREVIOUSPNG_fcTL_DISPOSE_OP_BACKGROUNDPNG_fcTL_DISPOSE_OP_NONEPNG_sRGB_INTENT_LASTPNG_sRGB_INTENT_ABSOLUTEPNG_sRGB_INTENT_SATURATIONPNG_sRGB_INTENT_RELATIVEPNG_sRGB_INTENT_PERCEPTUALPNG_RESOLUTION_LASTPNG_RESOLUTION_METERPNG_RESOLUTION_UNKNOWNPNG_SCALE_LASTPNG_SCALE_RADIANPNG_SCALE_METERPNG_SCALE_UNKNOWNPNG_EQUATION_LASTPNG_EQUATION_HYPERBOLICPNG_EQUATION_ARBITRARYPNG_EQUATION_BASE_EPNG_EQUATION_LINEARPNG_OFFSET_LASTPNG_OFFSET_MICROMETERPNG_OFFSET_PIXELPNG_INTERLACE_LASTPNG_INTERLACE_ADAM7PNG_INTERLACE_NONEPNG_FILTER_TYPE_DEFAULTPNG_FILTER_TYPE_BASEPNG_INTRAPIXEL_DIFFERENCINGPNG_COMPRESSION_TYPE_DEFAULTPNG_COMPRESSION_TYPE_BASEPNG_COLOR_TYPE_GAPNG_COLOR_TYPE_GRAY_ALPHAPNG_COLOR_TYPE_RGBAPNG_COLOR_TYPE_RGB_ALPHA(PNG_COLOR_MASK_ALPHA)(PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)PNG_COLOR_TYPE_RGB(PNG_COLOR_MASK_COLOR)PNG_COLOR_TYPE_PALETTE(PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)PNG_COLOR_TYPE_GRAYPNG_COLOR_MASK_ALPHAPNG_COLOR_MASK_COLORPNG_COLOR_MASK_PALETTEPNG_FP_MIN(-PNG_FP_MAX)PNG_FP_MAX((png_fixed_point)0x7fffffffL)PNG_FP_HALF50000PNG_SIZE_MAX((size_t)(-1))PNG_UINT_32_MAX((png_uint_32)(-1))PNG_UINT_31_MAX((png_uint_32)0x7fffffffL)PNG_AFTER_IDATPNG_HAVE_PLTEPNG_HAVE_IHDRPNG_TEXT_COMPRESSION_LASTPNG_ITXT_COMPRESSION_zTXtPNG_ITXT_COMPRESSION_NONEPNG_TEXT_COMPRESSION_zTXtPNG_TEXT_COMPRESSION_NONEPNG_TEXT_COMPRESSION_zTXt_WRPNG_TEXT_COMPRESSION_NONE_WR-3png_libpng_verpng_get_header_ver(NULL)PNG_LIBPNG_BUILD_TYPE(PNG_LIBPNG_BUILD_BASE_TYPE)PNG_LIBPNG_VER10800PNG_LIBPNG_BUILD_BASE_TYPEPNG_LIBPNG_BUILD_BETAPNG_LIBPNG_BUILD_SPECIAL32PNG_LIBPNG_BUILD_PRIVATEPNG_LIBPNG_BUILD_PATCHPNG_LIBPNG_BUILD_RELEASE_STATUS_MASKPNG_LIBPNG_BUILD_STABLEPNG_LIBPNG_BUILD_RCPNG_LIBPNG_BUILD_ALPHAPNG_LIBPNG_VER_BUILDPNG_LIBPNG_VER_DLLNUMPNG_LIBPNG_VER_SHAREDLIBPNG_LIBPNG_VER_SONUM18PNG_LIBPNG_VER_RELEASEPNG_LIBPNG_VER_MINORPNG_LIBPNG_VER_MAJORPNG_HEADER_VERSION_STRING" libpng version " PNG_LIBPNG_VER_STRING "\n"PNG_LIBPNG_VER_STRING"1.8.0.git"PNG_HPNGLCONF_HPNG_VERSION_INFO_ONLYPNG_USER_PRIVATEBUILDPNG_LIBPNG_SPECIALBUILDPNG_TEXT_SUPPORTEDdefined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED) || defined(PNG_USER_CHUNKS_SUPPORTED)PNG_PROGRESSIVE_READ_SUPPORTEDPNG_APNG_SUPPORTEDdefined(PNG_READ_USER_TRANSFORM_SUPPORTED) || defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)PNG_USER_CHUNKS_SUPPORTEDPNG_UNKNOWN_CHUNKS_SUPPORTEDPNG_SETJMP_SUPPORTED~0U > 0xffffUPNG_READ_SUPPORTEDPNG_USER_MEM_SUPPORTEDPNG_SEQUENTIAL_READ_SUPPORTEDPNG_TIME_RFC1123_SUPPORTEDPNG_CONVERT_tIME_SUPPORTEDPNG_READ_EXPAND_SUPPORTEDPNG_READ_EXPAND_16_SUPPORTEDdefined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)PNG_READ_GRAY_TO_RGB_SUPPORTEDPNG_READ_RGB_TO_GRAY_SUPPORTEDPNG_BUILD_GRAYSCALE_PALETTE_SUPPORTEDPNG_READ_ALPHA_MODE_SUPPORTEDdefined(PNG_GAMMA_SUPPORTED) || defined(PNG_READ_ALPHA_MODE_SUPPORTED)PNG_READ_STRIP_ALPHA_SUPPORTEDdefined(PNG_READ_SWAP_ALPHA_SUPPORTED) || defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)defined(PNG_READ_PACKSWAP_SUPPORTED) || defined(PNG_WRITE_PACKSWAP_SUPPORTED)defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)defined(PNG_READ_INTERLACING_SUPPORTED) || defined(PNG_WRITE_INTERLACING_SUPPORTED)defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)PNG_READ_BACKGROUND_SUPPORTEDPNG_READ_SCALE_16_TO_8_SUPPORTEDPNG_READ_STRIP_16_TO_8_SUPPORTEDPNG_READ_QUANTIZE_SUPPORTEDPNG_READ_GAMMA_SUPPORTEDPNG_WRITE_FLUSH_SUPPORTEDPNG_WRITE_SUPPORTEDPNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTEDPNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTEDPNG_STDIO_SUPPORTEDPNG_READ_USER_TRANSFORM_SUPPORTEDPNG_WRITE_USER_TRANSFORM_SUPPORTEDPNG_USER_TRANSFORM_PTR_SUPPORTEDPNG_USER_TRANSFORM_INFO_SUPPORTEDPNG_READ_USER_CHUNKS_SUPPORTEDPNG_STORE_UNKNOWN_CHUNKS_SUPPORTEDPNG_ERROR_TEXT_SUPPORTEDPNG_WARNINGS_SUPPORTEDPNG_BENIGN_ERRORS_SUPPORTEDPNG_ALLOW_BENIGN_ERRORSPNG_INFO_IMAGE_SUPPORTEDPNG_EASY_ACCESS_SUPPORTEDPNG_bKGD_SUPPORTEDPNG_cHRM_SUPPORTEDPNG_cICP_SUPPORTEDPNG_cLLI_SUPPORTEDPNG_eXIf_SUPPORTEDPNG_gAMA_SUPPORTEDPNG_hIST_SUPPORTEDPNG_mDCV_SUPPORTEDPNG_oFFs_SUPPORTEDPNG_pCAL_SUPPORTEDPNG_pHYs_SUPPORTEDPNG_sBIT_SUPPORTEDPNG_sRGB_SUPPORTEDPNG_iCCP_SUPPORTEDPNG_sPLT_SUPPORTEDPNG_tIME_SUPPORTEDPNG_tRNS_SUPPORTEDPNG_sCAL_SUPPORTEDdefined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || defined(PNG_FLOATING_POINT_SUPPORTED)PNG_SET_UNKNOWN_CHUNKS_SUPPORTEDPNG_HANDLE_AS_UNKNOWN_SUPPORTEDPNG_MNG_FEATURES_SUPPORTEDPNG_SET_USER_LIMITS_SUPPORTEDdefined(PNG_INCH_CONVERSIONS_SUPPORTED)PNG_FIXED_POINT_SUPPORTEDPNG_IO_STATE_SUPPORTEDPNG_READ_COMPOSITE_NODIV_SUPPORTEDPNG_READ_INT_FUNCTIONS_SUPPORTEDPNG_WRITE_INT_FUNCTIONS_SUPPORTEDPNG_SAVE_INT_32_SUPPORTEDPNG_USE_READ_MACROSPNG_PREFIXPNG_CHECK_FOR_INVALID_INDEX_SUPPORTEDPNG_GET_PALETTE_MAX_SUPPORTEDdefined(PNG_SIMPLIFIED_READ_SUPPORTED) || defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)PNG_FORMAT_BGR_SUPPORTEDPNG_FORMAT_AFIRST_SUPPORTEDPNG_SIMPLIFIED_READ_SUPPORTEDPNG_SIMPLIFIED_WRITE_SUPPORTEDPNG_SIMPLIFIED_WRITE_STDIO_SUPPORTEDPNG_ZLIB_MAX_SIZEPNG_DISABLE_ADLER32_CHECK_SUPPORTEDPNG_READ_APNG_SUPPORTEDPNG_WRITE_APNG_SUPPORTED(png_struct *png_ptr, png_info *info_ptr)(png_struct *png_ptr, png_info *info_ptr, png_byte **row_pointers, png_uint_32 width, png_uint_32 height, png_uint_32 x_offset, png_uint_32 y_offset, png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op, png_byte blend_op)(png_struct *png_ptr, png_progressive_frame_ptr frame_info_fn, png_progressive_frame_ptr frame_end_fn)png_uint_32(png_struct *png_ptr, png_info *info_ptr, png_byte is_hidden)png_bytepng_uint_16(png_struct *png_ptr, png_info *info_ptr, png_uint_32 width, png_uint_32 height, png_uint_32 x_offset, png_uint_32 y_offset, png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op, png_byte blend_op)(png_struct *png_ptr, png_info *info_ptr, png_uint_32 *width, png_uint_32 *height, png_uint_32 *x_offset, png_uint_32 *y_offset, png_uint_16 *delay_num, png_uint_16 *delay_den, png_byte *dispose_op, png_byte *blend_op)(png_struct *png_ptr, png_info *info_ptr, png_uint_32 num_frames, png_uint_32 num_plays)(png_struct *png_ptr, png_info *info_ptr, png_uint_32 *num_frames, png_uint_32 *num_plays)(png_struct *png_ptr, int option, int onoff)(png_image *image, void *memory, png_alloc_size_t *memory_bytes, int convert_to_8_bit, const void *buffer, png_int_32 row_stride, const void *colormap)(png_image *image, FILE *file, int convert_to_8_bit, const void *buffer, png_int_32 row_stride, const void *colormap)(png_image *image, const char *file, int convert_to_8bit, const void *buffer, png_int_32 row_stride, const void *colormap)(png_image *image)(png_image *image, const png_color *background, void *buffer, png_int_32 row_stride, void *colormap)(png_image *image, const void *memory, size_t size)(png_image *image, FILE *file)(png_image *image, const char *file_name)(const png_struct *png_ptr, const png_info *info_ptr)(png_struct *png_ptr, int allowed)(png_byte *buf, unsigned int i)(png_byte *buf, png_int_32 i)(png_byte *buf, png_uint_32 i)(const png_struct *png_ptr, const png_byte *buf)png_int_32(const png_byte *buf)(const png_struct *png_ptr)(const png_struct *png_ptr, const png_info *info_ptr, png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)png_ptrinfo_ptrrow_pointersx_offsety_offsetdelay_numdelay_dendispose_opblend_opframe_info_fnframe_end_fnis_hiddennum_framesnum_playsoptiononoffimagememorymemory_bytesconvert_to_8_bitbufferrow_stridecolormapfileconvert_to_8bitbackgroundfile_nameallowedbufires_xpng_fixed_pointpng_alloc_size_t(png_struct *png_ptr, png_alloc_size_t user_chunk_cache_max)(png_struct *png_ptr, png_uint_32 user_chunk_cache_max)(png_struct *png_ptr, png_uint_32 user_width_max, png_uint_32 user_height_max)(png_struct *png_ptr, png_uint_32 mng_features_permitted)(png_struct *png_ptr, png_info *info_ptr, int transforms, void *params)(const png_struct *png_ptr, png_info *info_ptr, int mask)(const png_struct *png_ptr, png_info *info_ptr, png_unknown_chunk **entries)(const png_struct *png_ptr, png_info *info_ptr, int chunk, int location)(const png_struct *png_ptr, png_info *info_ptr, const png_unknown_chunk *unknowns, int num_unknowns)(const png_struct *png_ptr, const png_byte *chunk_name)(png_struct *png_ptr, int keep, const png_byte *chunk_list, int num_chunks)(const png_struct *png_ptr, png_info *info_ptr, int unit, const char *swidth, const char *sheight)(const png_struct *png_ptr, png_info *info_ptr, int unit, png_fixed_point width, png_fixed_point height)(const png_struct *png_ptr, png_info *info_ptr, int unit, double width, double height)(const png_struct *png_ptr, const png_info *info_ptr, int *unit, char **swidth, char **sheight)(const png_struct *png_ptr, const png_info *info_ptr, int *unit, png_fixed_point *width, png_fixed_point *height)(const png_struct *png_ptr, const png_info *info_ptr, int *unit, double *width, double *height)(png_struct *png_ptr, png_info *info_ptr, const png_byte *trans_alpha, int num_trans, const png_color_16 *trans_color)(const png_struct *png_ptr, png_info *info_ptr, png_byte **trans_alpha, int *num_trans, png_color_16 **trans_color)(const png_struct *png_ptr, png_info *info_ptr, const png_time *mod_time)(const png_struct *png_ptr, png_info *info_ptr, png_time **mod_time)(const png_struct *png_ptr, png_info *info_ptr, const png_text *text_ptr, int num_text)(const png_struct *png_ptr, png_info *info_ptr, png_text **text_ptr, int *num_text)(const png_struct *png_ptr, png_info *info_ptr, const png_sPLT_t *entries, int nentries)(const png_struct *png_ptr, png_info *info_ptr, png_sPLT_t **entries)(const png_struct *png_ptr, png_info *info_ptr, const char *name, int compression_type, const png_byte *profile, png_uint_32 proflen)(const png_struct *png_ptr, png_info *info_ptr, char **name, int *compression_type, png_byte **profile, png_uint_32 *proflen)(const png_struct *png_ptr, png_info *info_ptr, int srgb_intent)(const png_struct *png_ptr, const png_info *info_ptr, int *file_srgb_intent)(const png_struct *png_ptr, png_info *info_ptr, const png_color_8 *sig_bit)(const png_struct *png_ptr, png_info *info_ptr, png_color_8 **sig_bit)(png_struct *png_ptr, png_info *info_ptr, const png_color *palette, int num_palette)(const png_struct *png_ptr, png_info *info_ptr, png_color **palette, int *num_palette)(const png_struct *png_ptr, png_info *info_ptr, png_uint_32 res_x, png_uint_32 res_y, int unit_type)(const png_struct *png_ptr, png_info *info_ptr, const char *purpose, png_int_32 X0, png_int_32 X1, int type, int nparams, const char *units, char **params)(const png_struct *png_ptr, png_info *info_ptr, char **purpose, png_int_32 *X0, png_int_32 *X1, int *type, int *nparams, char **units, char ***params)(const png_struct *png_ptr, png_info *info_ptr, png_int_32 offset_x, png_int_32 offset_y, int unit_type)(const png_struct *png_ptr, const png_info *info_ptr, png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)(const png_struct *png_ptr, png_info *info_ptr, png_fixed_point int_white_x, png_fixed_point int_white_y, png_fixed_point int_red_x, png_fixed_point int_red_y, png_fixed_point int_green_x, png_fixed_point int_green_y, png_fixed_point int_blue_x, png_fixed_point int_blue_y, png_uint_32 mastering_display_maximum_luminance_scaled_by_10000, png_uint_32 mastering_display_minimum_luminance_scaled_by_10000)(const png_struct *png_ptr, png_info *info_ptr, double white_x, double white_y, double red_x, double red_y, double green_x, double green_y, double blue_x, double blue_y, double mastering_display_maximum_luminance, double mastering_display_minimum_luminance)(const png_struct *png_ptr, const png_info *info_ptr, png_fixed_point *int_white_x, png_fixed_point *int_white_y, png_fixed_point *int_red_x, png_fixed_point *int_red_y, png_fixed_point *int_green_x, png_fixed_point *int_green_y, png_fixed_point *int_blue_x, png_fixed_point *int_blue_y, png_uint_32 *mastering_display_maximum_luminance_scaled_by_10000, png_uint_32 *mastering_display_minimum_luminance_scaled_by_10000)(const png_struct *png_ptr, const png_info *info_ptr, double *white_x, double *white_y, double *red_x, double *red_y, double *green_x, double *green_y, double *blue_x, double *blue_y, double *mastering_display_maximum_luminance, double *mastering_display_minimum_luminance)(const png_struct *png_ptr, png_info *info_ptr, png_uint_32 width, png_uint_32 height, int bit_depth, int color_type, int interlace_method, int compression_method, int filter_method)(const png_struct *png_ptr, const png_info *info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method)(const png_struct *png_ptr, png_info *info_ptr, const png_uint_16 *hist)(const png_struct *png_ptr, png_info *info_ptr, png_uint_16 **hist)(const png_struct *png_ptr, png_info *info_ptr, png_fixed_point int_file_gamma)(const png_struct *png_ptr, png_info *info_ptr, double file_gamma)(const png_struct *png_ptr, const png_info *info_ptr, png_fixed_point *int_file_gamma)(const png_struct *png_ptr, const png_info *info_ptr, double *file_gamma)(const png_struct *png_ptr, png_info *info_ptr, png_uint_32 num_exif, png_byte *exif)(const png_struct *png_ptr, const png_info *info_ptr, png_uint_32 *num_exif, png_byte **exif)(const png_struct *png_ptr, png_info *info_ptr, png_uint_32 maximum_content_light_level_scaled_by_10000, png_uint_32 maximum_frame_average_light_level_scaled_by_10000)(const png_struct *png_ptr, png_info *info_ptr, double maximum_content_light_level, double maximum_frame_average_light_level)(const png_struct *png_ptr, const png_info *info_ptr, png_uint_32 *maximum_content_light_level_scaled_by_10000, png_uint_32 *maximum_frame_average_light_level_scaled_by_10000)(const png_struct *png_ptr, const png_info *info_ptr, double *maximum_content_light_level, double *maximum_frame_average_light_level)(const png_struct *png_ptr, png_info *info_ptr, png_byte colour_primaries, png_byte transfer_function, png_byte matrix_coefficients, png_byte video_full_range_flag)(const png_struct *png_ptr, const png_info *info_ptr, png_byte *colour_primaries, png_byte *transfer_function, png_byte *matrix_coefficients, png_byte *video_full_range_flag)(const png_struct *png_ptr, png_info *info_ptr, png_fixed_point int_red_X, png_fixed_point int_red_Y, png_fixed_point int_red_Z, png_fixed_point int_green_X, png_fixed_point int_green_Y, png_fixed_point int_green_Z, png_fixed_point int_blue_X, png_fixed_point int_blue_Y, png_fixed_point int_blue_Z)(const png_struct *png_ptr, png_info *info_ptr, png_fixed_point int_white_x, png_fixed_point int_white_y, png_fixed_point int_red_x, png_fixed_point int_red_y, png_fixed_point int_green_x, png_fixed_point int_green_y, png_fixed_point int_blue_x, png_fixed_point int_blue_y)(const png_struct *png_ptr, png_info *info_ptr, double red_X, double red_Y, double red_Z, double green_X, double green_Y, double green_Z, double blue_X, double blue_Y, double blue_Z)(const png_struct *png_ptr, png_info *info_ptr, double white_x, double white_y, double red_x, double red_y, double green_x, double green_y, double blue_x, double blue_y)(const png_struct *png_ptr, const png_info *info_ptr, png_fixed_point *int_red_X, png_fixed_point *int_red_Y, png_fixed_point *int_red_Z, png_fixed_point *int_green_X, png_fixed_point *int_green_Y, png_fixed_point *int_green_Z, png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y, png_fixed_point *int_blue_Z)(const png_struct *png_ptr, const png_info *info_ptr, png_fixed_point *int_white_x, png_fixed_point *int_white_y, png_fixed_point *int_red_x, png_fixed_point *int_red_y, png_fixed_point *int_green_x, png_fixed_point *int_green_y, png_fixed_point *int_blue_x, png_fixed_point *int_blue_y)(const png_struct *png_ptr, const png_info *info_ptr, double *red_X, double *red_Y, double *red_Z, double *green_X, double *green_Y, double *green_Z, double *blue_X, double *blue_Y, double *blue_Z)(const png_struct *png_ptr, const png_info *info_ptr, double *white_x, double *white_y, double *red_x, double *red_y, double *green_x, double *green_y, double *blue_x, double *blue_y)(const png_struct *png_ptr, png_info *info_ptr, const png_color_16 *background)(const png_struct *png_ptr, png_info *info_ptr, png_color_16 **background)(const png_struct *png_ptr, png_info *info_ptr, png_byte **row_pointers)(const png_struct *png_ptr, const png_info *info_ptr, png_uint_32 flag)(const png_struct *png_ptr, const char *warning_message)(const png_struct *png_ptr, const char *error_message)PNG_NORETURN__declspec(noreturn)(const png_struct *png_ptr, void *ptr)PNG_DEPRECATED__declspec(deprecated)(const png_struct *png_ptr, png_alloc_size_t size)PNG_ALLOCATED PNG_DEPRECATED__declspec(restrict) __declspec(deprecated)(const png_struct *png_ptr, png_info *info_ptr, int freer, png_uint_32 mask)(const png_struct *png_ptr, png_info *info_ptr, png_uint_32 free_me, int num)PNG_ALLOCATED__declspec(restrict)(const png_struct *png_ptr, png_byte *old_row, const png_byte *new_row)(png_struct *, int save)(png_struct *png_ptr, png_info *info_ptr, png_byte *buffer, size_t buffer_size)(png_struct *png_ptr, void *progressive_ptr, png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn, png_progressive_end_ptr end_fn)(png_struct *png_ptr, void *user_chunk_ptr, png_user_chunk_ptr read_user_chunk_fn)(const png_struct *)(png_struct *png_ptr, void *user_transform_ptr, int user_transform_depth, int user_transform_channels)(png_struct *png_ptr, png_user_transform_ptr write_user_transform_fn)(png_struct *png_ptr, png_user_transform_ptr read_user_transform_fn)(png_struct *png_ptr, void *mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn)(png_struct *png_ptr, png_write_status_ptr write_row_fn)(png_struct *png_ptr, png_read_status_ptr read_row_fn)(png_struct *png_ptr, void *io_ptr, png_rw_ptr read_data_fn)(png_struct *png_ptr, void *io_ptr, png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn)(png_struct *png_ptr, void *error_ptr, png_error_ptr error_fn, png_error_ptr warning_fn)(png_struct *png_ptr, FILE *fp)(png_struct *png_ptr, int method)(png_struct *png_ptr, int window_bits)(png_struct *png_ptr, int strategy)(png_struct *png_ptr, int mem_level)(png_struct *png_ptr, int level)(png_struct *png_ptr, int method, int filters)(png_struct *png_ptr, int crit_action, int ancil_action)(png_struct **png_ptr_ptr, png_info **info_ptr_ptr)(png_struct **png_ptr_ptr, png_info **info_ptr_ptr, png_info **end_info_ptr_ptr)(const png_struct *png_ptr, png_info **info_ptr_ptr)(png_struct *png_ptr, png_byte **image)(png_struct *png_ptr, png_byte **row, png_uint_32 num_rows)(png_struct *png_ptr, const png_byte *row)(png_struct *png_ptr, png_byte *row, png_byte *display_row)(png_struct *png_ptr, png_byte **row, png_byte **display_row, png_uint_32 num_rows)(png_struct *png_ptr)(png_struct *png_ptr, int nrows)(png_struct *png_ptr, png_fixed_point screen_gamma, png_fixed_point override_file_gamma)(png_struct *png_ptr, double screen_gamma, double override_file_gamma)(png_struct *png_ptr, png_color *palette, int num_palette, int maximum_colors, const png_uint_16 *histogram, int full_quantize)(png_struct *png_ptr, const png_color_16 *background_color, int background_gamma_code, int need_expand, png_fixed_point background_gamma)(png_struct *png_ptr, const png_color_16 *background_color, int background_gamma_code, int need_expand, double background_gamma)(png_struct *png_ptr, const png_color_8 *true_bits)(png_struct *png_ptr, png_uint_32 filler, int flags)(png_struct *png_ptr, int mode, png_fixed_point output_gamma)(png_struct *png_ptr, int mode, double output_gamma)(int bit_depth, png_color *palette)(png_struct *png_ptr, int error_action, png_fixed_point red, png_fixed_point green)(png_struct *png_ptr, int error_action, double red, double green)(png_time *ptime, time_t ttime)(png_time *ptime, const struct tm * ttime)(png_struct *png_ptr, const png_info *info_ptr)(png_info **info_ptr, size_t png_info_struct_size)(png_struct *png_ptr, const png_byte *data, size_t length)(png_struct *png_ptr, const png_byte *chunk_name, png_uint_32 length)(png_struct *png_ptr, const png_byte *chunk_name, const png_byte *data, size_t length)(const char *user_png_ver, void *error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn, void *mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn)(const png_struct *png_ptr, int val)jmp_buf*(png_struct *png_ptr, png_longjmp_ptr longjmp_fn, size_t jmp_buf_size)(png_struct *png_ptr, size_t size)(const char *user_png_ver, void *error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn)(const png_byte *sig, size_t start, size_t num_to_check)(png_struct *png_ptr, int num_bytes)(void)PNG_EMPTYPNG_EXPORT_TYPE(void)(png_convert_from_time_t)PNG_LINKAGE_API(png_convert_from_struct_tm)png_convert_to_rfc1123(png_struct *png_ptr, const png_time *ptime)PNG_EXPORT_TYPE(int)(png_convert_to_rfc1123_buffer)(png_read_info)(png_write_info)(png_write_info_before_PLTE)(png_info_init_3)PNG_LINKAGE_API __declspec(deprecated)extern __declspec(deprecated)PNG_EXPORT_TYPE(png_info *)(png_create_info_struct)PNG_LINKAGE_API __declspec(restrict)extern __declspec(restrict)(png_write_chunk_end)(png_write_chunk_data)(png_write_chunk_start)(png_write_chunk)(png_write_sig)PNG_EXPORT_TYPE(png_struct *)(png_create_write_struct_2)(png_create_read_struct_2)(png_reset_zstream)(png_longjmp)PNG_LINKAGE_API __declspec(noreturn)extern __declspec(noreturn)(png_set_sRGB_gAMA_and_cHRM)(png_set_sRGB)PNG_EXPORT_TYPE(png_uint_32)(png_get_sRGB)(png_set_sBIT)(png_get_sBIT)(png_set_PLTE)(png_get_PLTE)(png_set_pHYs)(png_get_pHYs)(png_set_pCAL)(png_get_pCAL)(png_set_oFFs)(png_get_oFFs)(png_set_mDCV_fixed)(png_get_next_frame_y_offset)(png_get_next_frame_x_offset)(png_get_next_frame_height)(png_get_next_frame_width)(png_set_next_frame_fcTL)(png_get_next_frame_fcTL)(png_get_num_plays)(png_get_num_frames)(png_set_acTL)(png_get_acTL)(png_set_option)(png_image_write_to_memory)(png_image_write_to_stdio)(png_image_write_to_file)(png_image_free)(png_image_finish_read)(png_write_frame_tail)(png_write_frame_head)(png_set_progressive_frame_fn)(png_read_frame_head)(png_set_first_frame_is_hidden)PNG_EXPORT_TYPE(png_byte)(png_get_first_frame_is_hidden)(png_get_next_frame_blend_op)(png_get_next_frame_dispose_op)PNG_EXPORT_TYPE(png_uint_16)(png_get_next_frame_delay_den)(png_get_next_frame_delay_num)(png_get_pHYs_dpi)PNG_EXPORT_TYPE(png_fixed_point)(png_get_y_offset_inches_fixed)PNG_EXPORT_TYPE(float)(png_get_y_offset_inches)(png_get_x_offset_inches_fixed)(png_get_x_offset_inches)(png_get_y_pixels_per_inch)(png_get_x_pixels_per_inch)(png_get_pixels_per_inch)PNG_EXPORT_TYPE(png_alloc_size_t)(png_get_chunk_malloc_max)(png_set_chunk_malloc_max)(png_get_chunk_cache_max)(png_set_chunk_cache_max)(png_get_user_height_max)(png_get_user_width_max)(png_set_user_limits)(png_image_begin_read_from_memory)(png_image_begin_read_from_stdio)(png_image_begin_read_from_file)(png_get_palette_max)(png_set_check_for_invalid_index)(png_save_uint_16)(png_save_int_32)(png_save_uint_32)(png_get_uint_31)PNG_EXPORT_TYPE(png_int_32)(png_get_int_32)(png_get_uint_16)(png_get_uint_32)(png_get_io_chunk_type)png_get_io_chunk_name(png_get_io_state)(png_permit_mng_features)PNG_EXPORT_TYPE(const char *)(png_get_libpng_ver)(png_get_header_version)(png_get_header_ver)(png_get_copyright)(png_write_png)(png_read_png)(png_set_invalid)(png_get_unknown_chunks)(png_set_unknown_chunk_location)(png_set_unknown_chunks)(png_handle_as_unknown)(png_set_keep_unknown_chunks)(png_set_sCAL_s)(png_set_sCAL_fixed)(png_set_sCAL)(png_get_sCAL_s)(png_get_sCAL_fixed)(png_get_sCAL)(png_set_tRNS)(png_get_tRNS)(png_set_tIME)(png_get_tIME)(png_set_text)(png_get_text)(png_set_sPLT)(png_get_sPLT)(png_set_iCCP)(png_get_iCCP)(png_data_freer)(png_free_data)(png_free)PNG_EXPORT_TYPE(void *)(png_malloc_warn)(png_calloc)(png_malloc)(png_progressive_combine_row)(png_process_data_skip)PNG_EXPORT_TYPE(size_t)(png_process_data_pause)(png_process_data)(png_get_progressive_ptr)(png_set_progressive_read_fn)(png_get_user_chunk_ptr)(png_set_read_user_chunk_fn)(png_get_current_pass_number)(png_get_current_row_number)(png_set_cLLI)(png_get_cLLI_fixed)(png_get_cLLI)(png_set_cICP)(png_get_cICP)(png_set_cHRM_XYZ_fixed)(png_set_cHRM_fixed)(png_set_cHRM_XYZ)(png_set_cHRM)(png_get_cHRM_XYZ_fixed)(png_get_cHRM_fixed)(png_get_cHRM_XYZ)(png_get_cHRM)(png_set_bKGD)(png_set_mDCV)(png_get_mDCV_fixed)(png_get_mDCV)(png_set_IHDR)(png_get_IHDR)(png_set_hIST)(png_get_hIST)(png_set_gAMA_fixed)(png_set_gAMA)(png_get_gAMA_fixed)(png_get_gAMA)(png_set_eXIf_1)(png_get_eXIf_1)png_set_eXIf(const png_struct *png_ptr, png_info *info_ptr, png_byte *exif)png_get_eXIf(const png_struct *png_ptr, png_info *info_ptr, png_byte **exif)(png_set_cLLI_fixed)(png_get_bKGD)PNG_EXPORT_TYPE(const png_byte *)(png_get_signature)(png_get_y_offset_microns)(png_get_x_offset_microns)(png_get_y_offset_pixels)(png_get_x_offset_pixels)(png_get_pixel_aspect_ratio_fixed)(png_get_pixel_aspect_ratio)(png_get_y_pixels_per_meter)(png_get_x_pixels_per_meter)(png_get_pixels_per_meter)(png_get_compression_type)(png_get_interlace_type)(png_get_filter_type)(png_get_color_type)(png_get_bit_depth)(png_get_image_height)(png_get_image_width)(png_get_channels)(png_set_rows)PNG_EXPORT_TYPE(png_byte **)(png_get_rows)(png_get_rowbytes)(png_get_valid)(png_set_benign_errors)(png_chunk_benign_error)(png_benign_error)(png_chunk_warning)(png_warning)(png_chunk_error)(png_error)(png_free_default)(png_malloc_default)PNG_LINKAGE_API __declspec(restrict) __declspec(deprecated)extern __declspec(restrict) __declspec(deprecated)(png_write_end)(png_write_image)(png_write_rows)(png_write_row)(png_read_image)(png_read_row)(png_read_rows)(png_read_update_info)(png_start_read_image)(png_write_flush)(png_set_flush)(png_set_gamma_fixed)(png_set_gamma)(png_set_quantize)(png_set_strip_16)(png_get_user_transform_ptr)(png_set_user_transform_info)(png_set_write_user_transform_fn)(png_set_read_user_transform_fn)(png_get_mem_ptr)(png_set_mem_fn)(png_set_write_status_fn)(png_set_read_status_fn)(png_get_io_ptr)(png_set_read_fn)(png_set_write_fn)(png_get_error_ptr)(png_set_error_fn)(png_init_io)png_set_filter_heuristics_fixed(png_struct *png_ptr, int heuristic_method, int num_weights, const png_fixed_point *filter_weights, const png_fixed_point *filter_costs)png_set_filter_heuristics(png_struct *png_ptr, int heuristic_method, int num_weights, const double *filter_weights, const double *filter_costs)(png_set_text_compression_method)(png_set_text_compression_window_bits)(png_set_text_compression_strategy)(png_set_text_compression_mem_level)(png_set_text_compression_level)(png_set_compression_method)(png_set_compression_window_bits)(png_set_compression_strategy)(png_set_compression_mem_level)(png_set_compression_level)(png_set_filter)(png_set_crc_action)(png_destroy_write_struct)(png_destroy_read_struct)(png_destroy_info_struct)(png_read_end)(png_set_scale_16)(png_set_background_fixed)(png_set_background)(png_set_invert_mono)(png_set_interlace_handling)(png_set_shift)(png_set_packswap)(png_set_packing)(png_set_swap)(png_set_add_alpha)(png_set_filler)(png_set_invert_alpha)(png_set_swap_alpha)(png_set_strip_alpha)(png_set_alpha_mode_fixed)(png_set_alpha_mode)(png_build_grayscale_palette)(png_get_rgb_to_gray_status)(png_set_rgb_to_gray_fixed)(png_set_rgb_to_gray)(png_set_gray_to_rgb)(png_set_bgr)(png_set_expand_16)(png_set_tRNS_to_alpha)(png_set_palette_to_rgb)(png_set_expand_gray_1_2_4_to_8)(png_set_expand)PNG_EXPORT_TYPE(jmp_buf*)(png_set_longjmp_fn)(png_set_compression_buffer_size)(png_get_compression_buffer_size)(png_create_write_struct)(png_create_read_struct)(png_sig_cmp)(png_set_sig_bytes)(png_access_version_number)/* PNG_H *//* Do not put anything past this line *//* PNG_VERSION_INFO_ONLY *//* Maintainer: Put new public prototypes here ^, in libpng.3, in project
 * defs, and in scripts/symbols.def.
 *//* PNG_APNG_SUPPORTED *//* PNG_WRITE_APNG_SUPPORTED *//* PNG_READ_APNG_SUPPORTED *//* PNG_PROGRESSIVE_READ_SUPPORTED *//*******************************************************************************
 *  END OF HARDWARE AND SOFTWARE OPTIONS
 ******************************************************************************//* Option number out of range *//* Unset - defaults as above *//* Return values: NOTE: there are four values and 'off' is *not* zero *//* This has to be disabled in some builds because of the lack of
    * functionality in zlib.  Check the _SUPPORTED macro.
    *//* SOFTWARE: Disable Adler32 check on IDAT *//* SOFTWARE: Check ICC profile for sRGB *//* SOFTWARE: Force maximum window *//* HARDWARE: MIPS: chose MMI over MSA *//* HARDWARE: compatibility *//* HARDWARE: disable cpu specific code *//*******************************************************************************
 * Section 6: IMPLEMENTATION OPTIONS
 *******************************************************************************
 *
 * Support for arbitrary implementation-specific optimizations.  The API allows
 * particular options to be turned on or off.  'Option' is the number of the
 * option and 'onoff' is 0 (off) or non-0 (on).  The value returned is given
 * by the PNG_OPTION_ defines below.
 *
 * HARDWARE: [[changed in libpng 1.8]]
 *           Hardware options are now controlled globally to be 'on' or 'off'.
 *           For backward compatibility the original options are defined as
 *           the 'new' hardware option.  libpng can be compiled without
 *           hardware support (check PNG_TARGET_SPECIFIC_CODE_SUPPORTED and
 *           the documenation in pngtarget.h).
 *
 * SOFTWARE: sometimes software optimizations actually result in performance
 *           decrease on some architectures or systems, or with some sets of
 *           PNG images.  'Software' options allow such optimizations to be
 *           selected at run time.
 *
 * The initial setting for HARDWARE is determined by whether or not any
 * hardware-specific optimizations are available; the setting will be "ON" if
 * so otherwise it will be UNSET.
 *
 * the option starts of UNSET and this is treated as OFF.
 *//* SIMPLIFIED_{READ|WRITE} *//*******************************************************************************
 *  END OF SIMPLIFIED API
 ******************************************************************************//* SIMPLIFIED_WRITE *//* An upper bound on the total length of the PNG data stream for 'image'.
    * The result is of type png_alloc_size_t, on 32-bit systems this may
    * overflow even though PNG_IMAGE_DATA_SIZE does not overflow; the write will
    * run out of buffer space but return a corrected size which should work.
    *//* A helper for the following macro; if your compiler cannot handle the
    * following macro use this one with the result of
    * PNG_IMAGE_COMPRESSED_SIZE_MAX(image) as the second argument (most
    * compilers should handle this just fine.)
    *//*IDAT*//*tRNS*//*PLTE data*//*colormap: PLTE, tRNS*//*IEND*//*cHRM*//*gAMA*//*IHDR*//*sig*//* An upper bound on the size of the data in the PNG IDAT chunks. *//* An upper bound on the number of compressed bytes given 'b' uncompressed
    * bytes.  This is based on deflateBounds() in zlib; different
    * implementations of zlib compression may conceivably produce more data so
    * if your zlib implementation is not zlib itself redefine this macro
    * appropriately.
    *//* The number of uncompressed bytes in the PNG byte encoding of the image;
    * uncompressing the PNG IDAT data will give this number of bytes.
    *
    * NOTE: while PNG_IMAGE_SIZE cannot overflow for an image in memory this
    * macro can because of the extra bytes used in the PNG byte encoding.  You
    * need to avoid this macro if your image size approaches 2^30 in width or
    * height.  The same goes for the remainder of these macros; they all produce
    * bigger numbers than the actual in-memory image size.
    *//* You can pre-allocate the buffer by making sure it is of sufficient size
 * regardless of the amount of compression achieved.  The buffer size will
 * always be bigger than the original image and it will never be filled.  The
 * following macros are provided to assist in allocating the buffer.
 *//* Return the amount of memory in 'size' required to compress this image.
    * The png_image structure 'image' must be filled in as in the above
    * function and must not be changed before the actual write call, the buffer
    * and all other parameters must also be identical to that in the final
    * write call.  The 'size' variable need not be initialized.
    *
    * NOTE: the macro returns true/false, if false is returned 'size' will be
    * set to zero and the write failed and probably will fail if tried again.
    *//* Write the image to the given memory buffer.  The function both writes the
    * whole PNG data stream to *memory and updates *memory_bytes with the count
    * of bytes written.
    *
    * 'memory' may be NULL.  In this case *memory_bytes is not read however on
    * success the number of bytes which would have been written will still be
    * stored in *memory_bytes.  On failure *memory_bytes will contain 0.
    *
    * If 'memory' is not NULL it must point to memory[*memory_bytes] of
    * writeable memory.
    *
    * If the function returns success memory[*memory_bytes] (if 'memory' is not
    * NULL) contains the written PNG data.  *memory_bytes will always be less
    * than or equal to the original value.
    *
    * If the function returns false and *memory_bytes was not changed an error
    * occurred during write.  If *memory_bytes was changed, or is not 0 if
    * 'memory' was NULL, the write would have succeeded but for the memory
    * buffer being too small.  *memory_bytes contains the required number of
    * bytes and will be bigger that the original value.
    *//* With all write APIs if image is in one of the linear formats with 16-bit
 * data then setting convert_to_8_bit will cause the output to be an 8-bit PNG
 * gamma encoded according to the sRGB specification, otherwise a 16-bit linear
 * encoded PNG file is written.
 *
 * With color-mapped data formats the colormap parameter point to a color-map
 * with at least image->colormap_entries encoded in the specified format.  If
 * the format is linear the written PNG color-map will be converted to sRGB
 * regardless of the convert_to_8_bit flag.
 *
 * With all APIs row_stride is handled as in the read APIs - it is the spacing
 * from one row to the next in component sized units (1 or 2 bytes) and if
 * negative indicates a bottom-up row layout in the buffer.  If row_stride is
 * zero, libpng will calculate it for you from the image width and number of
 * channels.
 *
 * Note that the write API does not support interlacing, sub-8-bit pixels or
 * most ancillary chunks.  If you need to write text chunks (e.g. for copyright
 * notices) you need to use one of the other APIs.
 *//* SIMPLIFIED_WRITE_STDIO *//* Write the image to the given FILE object. *//* Write the image to the named file. *//* WRITE APIS
 * ----------
 * For write you must initialize a png_image structure to describe the image to
 * be written.  To do this use memset to set the whole structure to 0 then
 * initialize fields describing your image.
 *
 * version: must be set to PNG_IMAGE_VERSION
 * opaque: must be initialized to NULL
 * width: image width in pixels
 * height: image height in rows
 * format: the format of the data (image and color-map) you wish to write
 * flags: set to 0 unless one of the defined flags applies; set
 *    PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB for color format images where the RGB
 *    values do not correspond to the colors in sRGB.
 * colormap_entries: set to the number of entries in the color-map (0 to 256)
 *//* SIMPLIFIED_READ *//* Free any data allocated by libpng in image->opaque, setting the pointer to
    * NULL.  May be called at any time after the structure is initialized.
    *//* Finish reading the image into the supplied buffer and clean up the
    * png_image structure.
    *
    * row_stride is the step, in byte or 2-byte units as appropriate,
    * between adjacent rows.  A positive stride indicates that the top-most row
    * is first in the buffer - the normal top-down arrangement.  A negative
    * stride indicates that the bottom-most row is first in the buffer.
    *
    * background need only be supplied if an alpha channel must be removed from
    * a png_byte format and the removal is to be done by compositing on a solid
    * color; otherwise it may be NULL and any composition will be done directly
    * onto the buffer.  The value is an sRGB color to use for the background,
    * for grayscale output the green channel is used.
    *
    * background must be supplied when an alpha channel must be removed from a
    * single byte color-mapped output format, in other words if:
    *
    * 1) The original format from png_image_begin_read_from_* had
    *    PNG_FORMAT_FLAG_ALPHA set.
    * 2) The format set by the application does not.
    * 3) The format set by the application has PNG_FORMAT_FLAG_COLORMAP set and
    *    PNG_FORMAT_FLAG_LINEAR *not* set.
    *
    * For linear output removing the alpha channel is always done by compositing
    * on black and background is ignored.
    *
    * colormap must be supplied when PNG_FORMAT_FLAG_COLORMAP is set.  It must
    * be at least the size (in bytes) returned by PNG_IMAGE_COLORMAP_SIZE.
    * image->colormap_entries will be updated to the actual number of entries
    * written to the colormap; this may be less than the original value.
    *//* The PNG header is read from the given memory buffer. *//* STDIO *//* The PNG header is read from the stdio FILE object. *//* The named file is opened for read and the image header is filled in
    * from the PNG header in the file.
    *//* READ APIs
 * ---------
 *
 * The png_image passed to the read APIs must have been initialized by setting
 * the png_control* field 'opaque' to NULL (or, safer, memset the whole thing.)
 *//* On read if the image is a 16-bit per component image and there is no gAMA
    * or sRGB chunk assume that the components are sRGB encoded.  Notice that
    * images output by the simplified API always have gamma information; setting
    * this flag only affects the interpretation of 16-bit images from an
    * external source.  It is recommended that the application expose this flag
    * to the user; the user can normally easily recognize the difference between
    * linear and sRGB encoding.  This flag has no effect on write - the data
    * passed to the write APIs must have the correct encoding (as defined
    * above.)
    *
    * If the flag is not set (the default) input 16-bit per component data is
    * assumed to be linear.
    *
    * NOTE: the flag can only be set after the png_image_begin_read_ call,
    * because that call initializes the 'flags' field.
    *//* On write emphasise speed over compression; the resultant PNG file will be
    * larger but will be produced significantly faster, particular for large
    * images.  Do not use this option for images which will be distributed, only
    * used it when producing intermediate files that will be read back in
    * repeatedly.  For a typical 24-bit image the option will double the read
    * speed at the cost of increasing the image size by 25%, however for many
    * more compressible images the PNG file can be 10 times larger with only a
    * slight speed gain.
    *//* This indicates that the RGB values of the in-memory bitmap do not
    * correspond to the red, green and blue end-points defined by sRGB.
    *//* PNG_IMAGE_FLAG_*
 *
 * Flags containing additional information about the image are held in the
 * 'flags' field of png_image.
 *//* Return the size, in bytes, of the color-map of this image.  If the image
    * format is not a color-map format this will return a size sufficient for
    * 256 entries in the given format; check PNG_FORMAT_FLAG_COLORMAP if
    * you don't want to allocate a color-map in this case.
    *//* Return the size, in bytes, of the image in memory given just a png_image;
    * the row stride is the minimum stride required for the image.
    *//* Return the size, in bytes, of an image buffer given a png_image and a row
    * stride - the number of components to leave space for in each row.
    *
    * WARNING: this macro overflows a 32-bit integer for some large PNG images,
    * libpng will refuse to process an image where such an overflow would occur.
    *//* Return the total number of components in a single row of the image; this
    * is the minimum 'row stride', the minimum count of components between each
    * row.  For a color-mapped image this is the minimum number of bytes in a
    * row.
    *
    * WARNING: this macro overflows for some images with more than one component
    * and very large image widths.  libpng will refuse to process an image where
    * this macro would overflow.
    *//* Information about the whole row, or whole image *//* The size, in bytes, of a complete pixel; 1 for a color-mapped image. *//* The size, in bytes, of each component in a pixel; 1 for a color-mapped
    * image.
    *//* The number of separate channels (components) in a pixel; 1 for a
    * color-mapped image.
    *//* Corresponding information about the pixels *//* The maximum size of the color-map required by the format expressed in a
    * count of components.  This can be used to compile-time allocate a
    * color-map:
    *
    * png_uint_16 colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(linear_fmt)];
    *
    * png_byte colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(sRGB_fmt)];
    *
    * Alternatively use the PNG_IMAGE_COLORMAP_SIZE macro below to use the
    * information from one of the png_image_begin_read_ APIs and dynamically
    * allocate the required memory.
    *//* This is the size of the sample data for one sample.  If the image is
    * color-mapped it is the size of one color-map entry (and image pixels are
    * one byte in size), otherwise it is the size of one image pixel.
    *//* Return the size in bytes of a single component of a pixel or color-map
    * entry (as appropriate) in the image: 1 or 2.
    *//* Return the total number of channels in a given format: 1..4 *//* PNG_IMAGE macros
 *
 * These are convenience macros to derive information from a png_image
 * structure.  The PNG_IMAGE_SAMPLE_ macros return values appropriate to the
 * actual image sample values - either the entries in the color-map or the
 * pixels in the image.  The PNG_IMAGE_PIXEL_ macros return corresponding values
 * for the pixels and will always return 1 for color-mapped formats.  The
 * remaining macros return information about the rows in the image and the
 * complete image.
 *
 * NOTE: All the macros that take a png_image::format parameter are compile time
 * constants if the format parameter is, itself, a constant.  Therefore these
 * macros can be used in array declarations and case labels where required.
 * Similarly the macros are also pre-processor constants (sizeof is not used) so
 * they can be used in #if tests.
 *
 * First the information about the samples.
 *//* With color-mapped formats the image data is one byte for each pixel, the byte
 * is an index into the color-map which is formatted as above.  To obtain a
 * color-mapped format it is sufficient just to add the PNG_FOMAT_FLAG_COLORMAP
 * to one of the above definitions, or you can use one of the definitions below.
 *//* Then the linear 2-byte formats.  When naming these "Y" is used to
 * indicate a luminance (gray) channel.
 *//* Commonly used formats have predefined macros.
 *
 * First the single byte (sRGB) formats:
 *//* alpha channel is associated *//* alpha channel comes first *//* BGR colors, else order is RGB *//* image data is color-mapped *//* 2-byte channels else 1-byte *//* color format: otherwise grayscale *//* format with an alpha channel *//* PNG_FORMAT_*
 *
 * #defines to be used in png_image::format.  Each #define identifies a
 * particular layout of sample data and, if present, alpha values.  There are
 * separate defines for each of the two component encodings.
 *
 * A format is built up using single bit flag values.  All combinations are
 * valid.  Formats can be built up from the flag values or you can use one of
 * the predefined values below.  When testing formats always use the FORMAT_FLAG
 * macros to test for individual features - future versions of the library may
 * add new flags.
 *
 * When reading or writing color-mapped images the format should be set to the
 * format of the entries in the color-map then png_image_{read,write}_colormap
 * called to read or write the color-map and set the format correctly for the
 * image data.  Do not set the PNG_FORMAT_FLAG_COLORMAP bit directly!
 *
 * NOTE: libpng can be built with particular features disabled. If you see
 * compiler errors because the definition of one of the following flags has been
 * compiled out it is because libpng does not have the required support.  It is
 * possible, however, for the libpng configuration to enable the format on just
 * read or just write; in that case you may see an error at run time.  You can
 * guard against this by checking for the definition of the appropriate
 * "_SUPPORTED" macro, one of:
 *
 *    PNG_SIMPLIFIED_{READ,WRITE}_{BGR,AFIRST}_SUPPORTED
 *//* The samples of the image have one to four channels whose components have
 * original values in the range 0 to 1.0:
 *
 * 1: A single gray or luminance channel (G).
 * 2: A gray/luminance channel and an alpha channel (GA).
 * 3: Three red, green, blue color channels (RGB).
 * 4: Three color channels and an alpha channel (RGBA).
 *
 * The components are encoded in one of two ways:
 *
 * a) As a small integer, value 0..255, contained in a single byte.  For the
 * alpha channel the original value is simply value/255.  For the color or
 * luminance channels the value is encoded according to the sRGB specification
 * and matches the 8-bit format expected by typical display devices.
 *
 * The color/gray channels are not scaled (pre-multiplied) by the alpha
 * channel and are suitable for passing to color management software.
 *
 * b) As a value in the range 0..65535, contained in a 2-byte integer.  All
 * channels can be converted to the original value by dividing by 65535; all
 * channels are linear.  Color channels use the RGB encoding (RGB end-points) of
 * the sRGB specification.  This encoding is identified by the
 * PNG_FORMAT_FLAG_LINEAR flag below.
 *
 * When the simplified API needs to convert between sRGB and linear colorspaces,
 * the actual sRGB transfer curve defined in the sRGB specification (see the
 * article at <https://en.wikipedia.org/wiki/SRGB>) is used, not the gamma=1/2.2
 * approximation used elsewhere in libpng.
 *
 * When an alpha channel is present it is expected to denote pixel coverage
 * of the color or luminance channels and is returned as an associated alpha
 * channel: the color/gray channels are scaled (pre-multiplied) by the alpha
 * value.
 *
 * The samples are either contained directly in the image data, between 1 and 8
 * bytes per pixel according to the encoding, or are held in a color-map indexed
 * by bytes in the image data.  In the case of a color-map the color-map entries
 * are individual samples, encoded as above, and the image data has one byte per
 * pixel to select the relevant sample from the color-map.
 *//* [Deprecated] *//*
    * The result is a two-bit code such that a value more than 1 indicates
    * a failure in the API just called:
    *
    *    0 - no warning or error
    *    1 - warning
    *    2 - error
    *    3 - error preceded by warning
    *//* In the event of an error or warning the following field will be set to a
    * non-zero value and the 'message' field will contain a '\0' terminated
    * string with the libpng error or warning message.  If both warnings and
    * an error were encountered, only the error is recorded.  If there
    * are multiple warnings, only the first one is recorded.
    *
    * The upper 30 bits of this value are reserved, the low two bits contain
    * a value as follows:
    *//* Number of entries in the color-map *//* A bit mask containing informational flags *//* Image format as defined below *//* Image height in pixels (rows) *//* Image width in pixels (columns) *//* Set to PNG_IMAGE_VERSION *//* Initialize to NULL, free with png_image_free *//* [Opaque] *//*******************************************************************************
 * Section 5: SIMPLIFIED API
 *******************************************************************************
 *
 * Please read the documentation in libpng-manual.txt (TODO: write said
 * documentation) if you don't understand what follows.
 *
 * The simplified API hides the details of both libpng and the PNG file format
 * itself.  It allows PNG files to be read into a very limited number of
 * in-memory bitmap formats or to be written from the same formats.  If these
 * formats do not accommodate your needs then you can, and should, use the more
 * sophisticated APIs above - these support a wide variety of in-memory formats
 * and a wide variety of sophisticated transformations to those formats as well
 * as a wide variety of APIs to manipulate ancillary information.
 *
 * To read a PNG file using the simplified API:
 *
 * 1) Declare a 'png_image' structure (see below) on the stack, set the
 *    version field to PNG_IMAGE_VERSION and the 'opaque' pointer to NULL
 *    (this is REQUIRED, your program may crash if you don't do it.)
 * 2) Call the appropriate png_image_begin_read... function.
 * 3) Set the png_image 'format' member to the required sample format.
 * 4) Allocate a buffer for the image and, if required, the color-map.
 * 5) Call png_image_finish_read to read the image and, if required, the
 *    color-map into your buffers.
 *
 * There are no restrictions on the format of the PNG input itself; all valid
 * color types, bit depths, and interlace methods are acceptable, and the
 * input image is transformed as necessary to the requested in-memory format
 * during the png_image_finish_read() step.  The only caveat is that if you
 * request a color-mapped image from a PNG that is full-color or makes
 * complex use of an alpha channel the transformation is extremely lossy and the
 * result may look terrible.
 *
 * To write a PNG file using the simplified API:
 *
 * 1) Declare a 'png_image' structure on the stack and memset() it to all zero.
 * 2) Initialize the members of the structure that describe the image, setting
 *    the 'format' member to the format of the image samples.
 * 3) Call the appropriate png_image_write... function with a pointer to the
 *    image and, if necessary, the color-map to write the PNG data.
 *
 * png_image is a structure that describes the in-memory format of an image
 * when it is being read or defines the in-memory format of an image that you
 * need to write:
 *//* CHECK_FOR_INVALID_INDEX *//* No macros; revert to the (redefined) function *//* If PNG_PREFIX is defined the same thing as below happens in pnglibconf.h,
 * but defining a macro name prefixed with PNG_PREFIX.
 *//* From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
    * function) incorrectly returned a value of type png_uint_32.
    *//* Inline macros to do direct reads of bytes from the input buffer.
 * The png_get_int_32() routine assumes we are using two's complement
 * format for negative values, which is almost certainly true.
 *//* No png_save_int_16 -- may be added if there's a real need for it. *//* Place a 16-bit number into a buffer in PNG byte order.
 * The parameter is declared unsigned int, not png_uint_16,
 * just to avoid potential problems on pre-ANSI C compilers.
 *//* Place a 32-bit number into a buffer in PNG byte order (big-endian). *//* No png_get_int_16 -- may be added if there's a real need for it. *//* READ_COMPOSITE_NODIV *//* Standard method using integer division *//* fg and bg should be in `gamma 1.0' space; alpha is the opacity *//* With these routines we avoid an integer divide, which will be slower on
 * most machines.  However, it does take more operations than the corresponding
 * divide method, so it may be slower on a few RISC systems.  There are two
 * shifts (by 8 or 16 bits) and an addition, versus a single integer divide.
 *
 * Note that the rounding factors are NOT supposed to be the same!  128 and
 * 32768 are correct for the NODIV code; 127 and 32767 are correct for the
 * standard method.
 *
 * [Optimized code by Greg Roelofs and Mark Adler...blame us for bugs. :-) ]
 *//* Two macros which return a boolean (0 or 1) saying whether the given row
 * or column is in a particular pass.  These use a common utility macro that
 * returns a mask for a given pass - the offset 'off' selects the row or
 * column version.  The mask has the appropriate bit set for each column in
 * the tile.
 *//* For the reader row callbacks (both progressive and sequential) it is
 * necessary to find the row in the output image given a row in an interlaced
 * image, so two more macros:
 *//* Hence two macros to determine the number of rows or columns in a given
 * pass of an image given its height or width.  In fact these macros may
 * return non-zero even though the sub-image is empty, because the other
 * dimension may be empty for a small image.
 *//* Two macros to help evaluate the number of rows or columns in each
 * pass.  This is expressed as a shift - effectively log2 of the number or
 * rows or columns in each 8x8 tile of the original image.
 *//* A macro to return the offset between pixels in the output row for a pair of
 * pixels in the input - effectively the inverse of the 'COL_SHIFT' macro that
 * follows.  Note that ROW_OFFSET is the offset from one row to the next whereas
 * COL_OFFSET is from one column to the next, within a row.
 *//* Two macros to return the first row and first column of the original,
 * full, image which appears in a given pass.  'pass' is in the range 0
 * to 6 and the result is in the range 0 to 7.
 *//* Interlace support.  The following macros are always defined so that if
 * libpng interlace handling is turned off the macros may be used to handle
 * interlaced images within the application.
 *//* IO_STATE *//* current location: sig/hdr/data/crc *//* current operation: reading/writing *//* currently at the chunk crc *//* currently at the chunk data *//* currently at the chunk header *//* currently at the file signature *//* currently writing *//* currently reading *//* no I/O at this moment *//* The flags returned by png_get_io_state() are the following: *//* Removed from libpng 1.6; use png_get_io_chunk_type. *//* Added in libpng-1.4.0 *//* INCH_CONVERSIONS *//* pHYs *//* otherwise not implemented. *//* Added in libpng-1.4.1 *//* Added in libpng-1.2.6 *//* For use in png_set_keep_unknown, added to version 1.2.6 *//* The "params" pointer is currently not used and is for future expansion. *//* Png_free_data() will turn off the "valid" flag for anything it frees.
 * If you need to turn it off for a chunk that your application has freed,
 * you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK);
 *//* NOTE: prior to 1.6.0 this routine set the 'location' field of the added
    * unknowns to the location currently stored in the png_struct.  This is
    * invariably the wrong value on write.  To fix this call the following API
    * for each chunk in the list with the correct location.  If you know your
    * code won't be compiled on earlier versions you can rely on
    * png_set_unknown_chunks(write-ptr, png_get_unknown_chunks(read-ptr)) doing
    * the correct thing.
    *//* SET_UNKNOWN_CHUNKS *//* The "keep" PNG_HANDLE_CHUNK_ parameter for the specified chunk is returned;
 * the result is therefore true (non-zero) if special handling is required,
 * false for the default handling.
 *//* HANDLE_AS_UNKNOWN *//* Provide the default handling for all unknown chunks or, optionally, for
 * specific unknown chunks.
 *
 * NOTE: prior to 1.6.0 the handling specified for particular chunks on read was
 * ignored and the default was used, the per-chunk setting only had an effect on
 * write.  If you wish to have chunk-specific handling on read in code that must
 * work on earlier versions you must use a user chunk callback to specify the
 * desired handling (keep or discard.)
 *
 * The 'keep' parameter is a PNG_HANDLE_CHUNK_ value as listed below.  The
 * parameter is interpreted as follows:
 *
 * READ:
 *    PNG_HANDLE_CHUNK_AS_DEFAULT:
 *       Known chunks: do normal libpng processing, do not keep the chunk (but
 *          see the comments below about PNG_HANDLE_AS_UNKNOWN_SUPPORTED)
 *       Unknown chunks: for a specific chunk use the global default, when used
 *          as the default discard the chunk data.
 *    PNG_HANDLE_CHUNK_NEVER:
 *       Discard the chunk data.
 *    PNG_HANDLE_CHUNK_IF_SAFE:
 *       Keep the chunk data if the chunk is not critical else raise a chunk
 *       error.
 *    PNG_HANDLE_CHUNK_ALWAYS:
 *       Keep the chunk data.
 *
 * If the chunk data is saved it can be retrieved using png_get_unknown_chunks,
 * below.  Notice that specifying "AS_DEFAULT" as a global default is equivalent
 * to specifying "NEVER", however when "AS_DEFAULT" is used for specific chunks
 * it simply resets the behavior to the libpng default.
 *
 * INTERACTION WITH USER CHUNK CALLBACKS:
 * The per-chunk handling is always used when there is a png_user_chunk_ptr
 * callback and the callback returns 0; the chunk is then always stored *unless*
 * it is critical and the per-chunk setting is other than ALWAYS.  Notice that
 * the global default is *not* used in this case.  (In effect the per-chunk
 * value is incremented to at least IF_SAFE.)
 *
 * IMPORTANT NOTE: this behavior will change in libpng 1.7 - the global and
 * per-chunk defaults will be honored.  If you want to preserve the current
 * behavior when your callback returns 0 you must set PNG_HANDLE_CHUNK_IF_SAFE
 * as the default - if you don't do this libpng 1.6 will issue a warning.
 *
 * If you want unhandled unknown chunks to be discarded in libpng 1.6 and
 * earlier simply return '1' (handled).
 *
 * PNG_HANDLE_AS_UNKNOWN_SUPPORTED:
 *    If this is *not* set known chunks will always be handled by libpng and
 *    will never be stored in the unknown chunk list.  Known chunks listed to
 *    png_set_keep_unknown_chunks will have no effect.  If it is set then known
 *    chunks listed with a keep other than AS_DEFAULT will *never* be processed
 *    by libpng, in addition critical chunks must either be processed by the
 *    callback or saved.
 *
 *    The IHDR and IEND chunks must not be listed.  Because this turns off the
 *    default handling for chunks that would otherwise be recognized the
 *    behavior of libpng transformations may well become incorrect!
 *
 * WRITE:
 *    When writing chunks the options only apply to the chunks specified by
 *    png_set_unknown_chunks (below), libpng will *always* write known chunks
 *    required by png_set_ calls and will always write the core critical chunks
 *    (as required for PLTE).
 *
 *    Each chunk in the png_set_unknown_chunks list is looked up in the
 *    png_set_keep_unknown_chunks list to find the keep setting, this is then
 *    interpreted as follows:
 *
 *    PNG_HANDLE_CHUNK_AS_DEFAULT:
 *       Write safe-to-copy chunks and write other chunks if the global
 *       default is set to _ALWAYS, otherwise don't write this chunk.
 *    PNG_HANDLE_CHUNK_NEVER:
 *       Do not write the chunk.
 *    PNG_HANDLE_CHUNK_IF_SAFE:
 *       Write the chunk if it is safe-to-copy, otherwise do not write it.
 *    PNG_HANDLE_CHUNK_ALWAYS:
 *       Write the chunk.
 *
 * Note that the default behavior is effectively the opposite of the read case -
 * in read unknown chunks are not stored by default, in write they are written
 * by default.  Also the behavior of PNG_HANDLE_CHUNK_IF_SAFE is very different
 * - on write the safe-to-copy bit is checked, on read the critical bit is
 * checked and on read if the chunk is critical an error will be raised.
 *
 * num_chunks:
 * ===========
 *    If num_chunks is positive, then the "keep" parameter specifies the manner
 *    for handling only those chunks appearing in the chunk_list array,
 *    otherwise the chunk list array is ignored.
 *
 *    If num_chunks is 0 the "keep" parameter specifies the default behavior for
 *    unknown chunks, as described above.
 *
 *    If num_chunks is negative, then the "keep" parameter specifies the manner
 *    for handling all unknown chunks plus all chunks recognized by libpng
 *    except for the IHDR, PLTE, tRNS, IDAT, and IEND chunks (which continue to
 *    be processed by libpng.
 *//* sCAL *//* NOTE: this API is currently implemented using floating point arithmetic,
 * consequently it can only be used on systems with floating point support.
 * In any case the range of values supported by png_fixed_point is small and it
 * is highly recommended that png_get_sCAL_s be used instead.
 *//* Note while png_set_text() will accept a structure whose text,
 * language, and  translated keywords are NULL pointers, the structure
 * returned by png_get_text will always contain regular
 * zero-terminated C strings.  They might be empty strings but
 * they will never be NULL pointers.
 *//* png_get_text also returns the number of text chunks in *num_text *//* These are PNG unsigned 4 byte values: 31-bit unsigned values.  The MSB

    * must be zero.
     *//* The admissible range of these values is not the full range of a PNG

    * fixed point value.  Negative values cannot be encoded and the maximum
     * value is about 1.3 *//* Mastering display luminance in cd/m2 (nits). *//* The chromaticities of the mastering display.  As cHRM, but independent of

    * the encoding endpoints in cHRM, or cICP, or iCCP.
     *//* Mastering display luminance in cd/m2 (nits) multiplied (scaled) by

    * 10,000.
     *//* The chromaticities of the mastering display.  As cHRM, but independent of

    * the encoding endpoints in cHRM, or cICP, or iCCP.  These values will

    * always be in the range 0 to 1.3107.
     *//* The values below are in cd/m2 (nits) and are scaled by 10,000; not

    * 100,000 as in the case of png_fixed_point.
     *//* Returns pointer to signature string read from PNG header *//* EASY_ACCESS *//* Returns image x, y offset in pixels or microns, from oFFs chunk data. *//* Returns pixel aspect ratio, computed from pHYs chunk data.  *//* Returns image resolution in pixels per meter, from pHYs chunk data. *//* Returns image compression_type. *//* Returns image interlace_type. *//* Returns image filter_type. *//* Returns image color_type. *//* Returns image bit_depth. *//* Returns image height in pixels. *//* Returns image width in pixels. *//* Returns number of color channels in image. *//* Set row_pointers, which is an array of pointers to scanlines for use
 * by png_write_png().
 *//* Returns row_pointers, which is an array of pointers to scanlines that was
 * returned from png_read_png().
 *//* Returns number of bytes needed to hold a transformed row. *//* Returns "flag" if chunk data is valid in info_ptr. *//* The png_set_<chunk> functions are for storing values in the png_info_struct.
 * Similarly, the png_get_<chunk> calls are used to read values from the
 * png_info_struct, either storing the parameters in the passed variables, or
 * setting pointers into the png_info_struct where the data is stored.  The
 * png_get_<chunk> functions return a non-zero value if the data was available
 * in info_ptr, or return zero and do not change any of the parameters if the
 * data was not available.
 *
 * These functions should be used instead of directly accessing png_info
 * to avoid problems with future changes in the size and internal layout of
 * png_info_struct.
 *//* Same, chunk name is prepended to message (only during read) *//* Benign error in libpng.  Can continue, but may have a problem.
 * User can choose whether to handle as a fatal error or as a warning. *//* Non-fatal error in libpng, chunk name is prepended to message. *//* Non-fatal error in libpng.  Can continue, but may have a problem. *//* Fatal error in PNG image of libpng - can't continue *//* The same, but the chunk name is prepended to the error string. *//* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN *//* Added at libpng-1.6.31 *//*      PNG_FREE_LIST 0x0400U   removed in 1.6.0 because it is ignored *//* Flags for png_ptr->free_me and info_ptr->free_me *//* Assignments for png_data_freer *//* Reassign the responsibility for freeing existing data, whether allocated
 * by libpng or by the application; this works on the png_info structure passed
 * in, without changing the state for other png_info structures.
 *//* Free data that was allocated internally *//* Frees a pointer allocated by png_malloc() *//* Added at libpng version 1.2.4 *//* Added at libpng version 1.4.0 *//* PROGRESSIVE_READ *//* Function that combines rows.  'new_row' is a flag that should come from
 * the callback and be non-NULL if anything needs to be done; the library
 * stores its own version of the new data internally and ignores the passed
 * in value.
 *//* A function which may be called *only* outside (after) a call to
 * png_process_data.  It returns the number of bytes of data to skip in the
 * input.  Normally it will return 0, but if it returns a non-zero value the
 * application must skip than number of bytes of input data and pass the
 * following data to the next call to png_process_data.
 *//* A function which may be called *only* within png_process_data to stop the
 * processing of any more data.  The function returns the number of bytes
 * remaining, excluding any that libpng has cached internally.  A subsequent
 * call to png_process_data must supply these bytes again.  If the argument
 * 'save' is set to true the routine will first save all the pending data and
 * will always return 0.
 *//* Function to be called when data becomes available *//* Returns the user pointer associated with the push read functions *//* Sets the function callbacks for the push reader, and a pointer to a
 * user-defined structure available to the callback functions.
 *//* This callback is called only for *unknown* chunks.  If
 * PNG_HANDLE_AS_UNKNOWN_SUPPORTED is set then it is possible to set known
 * chunks to be treated as unknown, however in this case the callback must do
 * any processing required by the chunk (e.g. by calling the appropriate
 * png_set_ APIs.)
 *
 * There is no write support - on write, by default, all the chunks in the
 * 'unknown' list are written in the specified position.
 *
 * The integer return from the callback function is interpreted thus:
 *
 * negative: An error occurred; png_chunk_error will be called.
 *     zero: The chunk was not handled, the chunk will be saved. A critical
 *           chunk will cause an error at this point unless it is to be saved.
 * positive: The chunk was handled, libpng will ignore/discard it.
 *
 * See "INTERACTION WITH USER CHUNK CALLBACKS" below for important notes about
 * how this behavior will change in libpng 1.7
 *//* Return information about the row currently being processed.  Note that these
 * APIs do not fail but will return unexpected results if called outside a user
 * transform callback.  Also note that when transforming an interlaced image the
 * row number is the row number within the sub-image of the interlace pass, so
 * the value will increase to the height of the sub-image (not the full image)
 * then reset to 0 for the next pass.
 *
 * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
 * find the output pixel (x,y) given an interlaced sub-image pixel
 * (row,col,pass).  (See below for these macros.)
 *//* Return the user pointer associated with the user transform functions *//* Return the user pointer associated with the memory functions *//* Replace the default memory allocation functions with user supplied one(s). *//* Return the user pointer associated with the I/O functions *//* Replace the default data input function with a user supplied one. *//* Replace the default data output functions with a user supplied one(s).
 * If buffered output is not used, then output_flush_fn can be set to NULL.
 * If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time
 * output_flush_fn will be ignored (and thus can be NULL).
 * It is probably a mistake to use NULL for output_flush_fn if
 * write_data_fn is not also NULL unless you have built libpng with
 * PNG_WRITE_FLUSH_SUPPORTED undefined, because in this case libpng's
 * default flush function, which uses the standard *FILE structure, will
 * be used.
 *//* Return the user pointer associated with the error functions *//* Replace the (error and abort), and warning functions with user
 * supplied functions.  If no messages are to be printed you must still
 * write and use replacement functions. The replacement error_fn should
 * still do a longjmp to the last setjmp location if you are using this
 * method of error handling.  If error_fn or warning_fn is NULL, the
 * default function will be used.
 *//* Initialize the input/output for the PNG file to the default functions. *//* These next functions are called for input/output, memory, and error
 * handling.  They are in the file pngrio.c, pngwio.c, and pngerror.c,
 * and call standard C I/O routines such as fread(), fwrite(), and
 * fprintf().  These functions can be made to use other I/O routines
 * at run time for those applications that need to handle I/O in a
 * different manner by calling png_set_???_fn().  See libpng-manual.txt for
 * more information.
 *//* WRITE *//* WRITE_CUSTOMIZE_ZTXT_COMPRESSION *//* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.
 *//* Also set zlib parameters for compressing non-IDAT chunks *//* WRITE_CUSTOMIZE_COMPRESSION *//* Set the library compression level.  Currently, valid values range from
 * 0 - 9, corresponding directly to the zlib compression levels 0 - 9
 * (0 - no compression, 9 - "maximal" compression).  Note that tests have
 * shown that zlib compression levels 3-6 usually perform as well as level 9
 * for PNG images, and do considerably fewer calculations.  In the future,
 * these values may not correspond directly to the zlib compression levels.
 *//* Filter values (not flags) - used in pngwrite.c, pngwutil.c for now.
 * These defines should NOT be changed.
 *//* Flags for png_set_filter() to say which filters to use.  The flags
 * are chosen so that they don't conflict with real filter types
 * below, in case they are supplied instead of the #defined constants.
 * These values should NOT be changed.
 *//* Set the filtering method(s) used by libpng.  Currently, the only valid
 * value for "method" is 0.
 *//* These functions give the user control over the scan-line filtering in
 * libpng and the compression methods used by zlib.  These functions are
 * mainly useful for testing, as the defaults should work with most users.
 * Those users who are tight on memory or want faster performance at the
 * expense of compression can modify them.  See the compression library
 * header file (zlib.h) for an explanation of the compression functions.
 *//* use current value   use current value *//* quiet/use data      quiet/use data    *//* warn/use data       warn/use data     *//* (INVALID)           warn/discard data *//* error/quit          error/quit        *//* error/quit          warn/discard data *//* Values for png_set_crc_action() say how to handle CRC errors in
 * ancillary and critical chunks, and whether to use the data contained
 * therein.  Note that it is impossible to "discard" data in a critical
 * chunk.  For versions prior to 0.90, the action was always error/quit,
 * whereas in version 0.90 and later, the action for CRC errors in ancillary
 * chunks is warn/discard.  These values should NOT be changed.
 *
 *      value                       action:critical     action:ancillary
 *//* Set the libpng method of handling chunk CRC errors *//* Free any memory associated with the png_struct and the png_info_structs *//* Free any memory associated with the png_info_struct *//* Read the end of the PNG file. *//* Write the end of the PNG file. *//* Write the image data *//* Write a few rows of image data: (*row) is not written; however, the type
 * is declared as writeable to maintain compatibility with previous versions
 * of libpng and to allow the 'display_row' array from read_rows to be passed
 * unchanged to write_rows.
 *//* Write a row of image data *//* Read the whole image into memory at once. *//* Read a row of data. *//* Read one or more rows of image data. *//* Optional call to update the users info structure *//* Optional update palette with requested transformations *//* Flush the current PNG output buffer *//* Set how many lines between output flushes - 0 for no flushing *//* Handle gamma correction. Screen_gamma=(display_exponent).
 * NOTE: this API simply sets the screen and file gamma values. It will
 * therefore override the value for gamma in a PNG file if it is called after
 * the file header has been read - use with care  - call before reading the PNG
 * file for best results!
 *
 * These routines accept the same gamma values as png_set_alpha_mode (described
 * above).  The PNG_GAMMA_ defines and PNG_DEFAULT_sRGB can be passed to either
 * API (floating point or fixed.)  Notice, however, that the 'file_gamma' value
 * is the inverse of a 'screen gamma' value.
 *//* The threshold on gamma processing is configurable but hard-wired into the
 * library.  The following is the floating point variant.
 *//* Turn on quantizing, and reduce the palette to the number of colors
 * available.
 *//* Strip the second byte of information from a 16-bit depth file. *//* Name prior to 1.5.4 *//* Scale a 16-bit depth file down to 8-bit, accurately. *//* Handle alpha and tRNS by replacing with a background color.  Prior to
 * libpng-1.5.4 this API must not be called before the PNG file header has been
 * read.  Doing so will result in unexpected behavior and possible warnings or
 * errors if the PNG file contains a bKGD chunk.
 *//* Invert monochrome files *//* Have the code handle the interlacing.  Returns the number of passes.
 * MUST be called before png_read_update_info or png_start_read_image,
 * otherwise it will not have the desired effect.  Note that it is still
 * necessary to call png_read_row or png_read_rows png_get_image_height
 * times for each pass.
*//* Converts files to legal bit depths. *//* Swap packing order of pixels in bytes. *//* Use 1 byte per pixel in 1, 2, or 4-bit depth files. *//* Swap bytes in 16-bit depth files. *//* READ_FILLER || WRITE_FILLER *//* Add an alpha byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. *//* The values of the PNG_FILLER_ defines should NOT be changed *//* Add a filler byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. *//* The following are examples of calls to png_set_alpha_mode to achieve the
 * required overall gamma correction and, where necessary, alpha
 * premultiplication.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);
 *    This is the default libpng handling of the alpha channel - it is not
 *    pre-multiplied into the color components.  In addition the call states
 *    that the output is for a sRGB system and causes all PNG files without gAMA
 *    chunks to be assumed to be encoded using sRGB.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
 *    In this case the output is assumed to be something like an sRGB conformant
 *    display preceded by a power-law lookup table of power 1.45.  This is how
 *    early Mac systems behaved.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_GAMMA_LINEAR);
 *    This is the classic Jim Blinn approach and will work in academic
 *    environments where everything is done by the book.  It has the shortcoming
 *    of assuming that input PNG data with no gamma information is linear - this
 *    is unlikely to be correct unless the PNG files where generated locally.
 *    Most of the time the output precision will be so low as to show
 *    significant banding in dark areas of the image.
 *
 * png_set_expand_16(pp);
 * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_DEFAULT_sRGB);
 *    This is a somewhat more realistic Jim Blinn inspired approach.  PNG files
 *    are assumed to have the sRGB encoding if not marked with a gamma value and
 *    the output is always 16 bits per component.  This permits accurate scaling
 *    and processing of the data.  If you know that your input PNG files were
 *    generated locally you might need to replace PNG_DEFAULT_sRGB with the
 *    correct value for your system.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_OPTIMIZED, PNG_DEFAULT_sRGB);
 *    If you just need to composite the PNG image onto an existing background
 *    and if you control the code that does this you can use the optimization
 *    setting.  In this case you just copy completely opaque pixels to the
 *    output.  For pixels that are not completely transparent (you just skip
 *    those) you do the composition math using png_composite or png_composite_16
 *    below then encode the resultant 8-bit or 16-bit values to match the output
 *    encoding.
 *
 * Other cases
 *    If neither the PNG nor the standard linear encoding work for you because
 *    of the software or hardware you use then you have a big problem.  The PNG
 *    case will probably result in halos around the image.  The linear encoding
 *    will probably result in a washed out, too bright, image (it's actually too
 *    contrasty.)  Try the ALPHA_OPTIMIZED mode above - this will probably
 *    substantially reduce the halos.  Alternatively try:
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_BROKEN, PNG_DEFAULT_sRGB);
 *    This option will also reduce the halos, but there will be slight dark
 *    halos round the opaque parts of the image where the background is light.
 *    In the OPTIMIZED mode the halos will be light halos where the background
 *    is dark.  Take your pick - the halos are unavoidable unless you can get
 *    your hardware/software fixed!  (The OPTIMIZED approach is slightly
 *    faster.)
 *
 * When the default gamma of PNG files doesn't match the output gamma.
 *    If you have PNG files with no gamma information png_set_alpha_mode allows
 *    you to provide a default gamma, but it also sets the output gamma to the
 *    matching value.  If you know your PNG files have a gamma that doesn't
 *    match the output you can take advantage of the fact that
 *    png_set_alpha_mode always sets the output gamma but only sets the PNG
 *    default if it is not already set:
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
 *    The first call sets both the default and the output gamma values, the
 *    second call overrides the output gamma without changing the default.  This
 *    is easier than achieving the same effect with png_set_gamma.  You must use
 *    PNG_ALPHA_PNG for the first call - internal checking in png_set_alpha will
 *    fire if more than one call to png_set_alpha_mode and png_set_background is
 *    made in the same read operation, however multiple calls with PNG_ALPHA_PNG
 *    are ignored.
 *//* Linear *//* Television standards--matches sRGB gamma *//* Old Mac '1.8' gamma and color space *//* sRGB gamma and color space *//* The output_gamma value is a screen gamma in libpng terminology: it expresses
 * how to decode the output values, not how they are encoded.
 *//* the alpha channel is gamma encoded *//* 'PNG' for opaque pixels, else 'STANDARD' *//* as above *//* as above; this is the normal practice *//* according to Porter/Duff *//* according to the PNG standard *//* How the alpha channel is interpreted - this affects how the color channels
 * of a PNG file are returned to the calling application when an alpha channel,
 * or a tRNS chunk in a palette file, is present.
 *
 * This has no effect on the way pixels are written into a PNG output
 * datastream. The color samples in a PNG datastream are never premultiplied
 * with the alpha samples.
 *
 * The default is to return data according to the PNG specification: the alpha
 * channel is a linear measure of the contribution of the pixel to the
 * corresponding composited pixel, and the color channels are unassociated
 * (not premultiplied).  The gamma encoded color channels must be scaled
 * according to the contribution and to do this it is necessary to undo
 * the encoding, scale the color values, perform the composition and re-encode
 * the values.  This is the 'PNG' mode.
 *
 * The alternative is to 'associate' the alpha with the color information by
 * storing color channel values that have been scaled by the alpha.
 * image.  These are the 'STANDARD', 'ASSOCIATED' or 'PREMULTIPLIED' modes
 * (the latter being the two common names for associated alpha color channels).
 *
 * For the 'OPTIMIZED' mode, a pixel is treated as opaque only if the alpha
 * value is equal to the maximum value.
 *
 * The final choice is to gamma encode the alpha channel as well.  This is
 * broken because, in practice, no implementation that uses this choice
 * correctly undoes the encoding before handling alpha composition.  Use this
 * choice only if other serious errors in the software or hardware you use
 * mandate it; the typical serious error is for dark halos to appear around
 * opaque areas of the composited PNG image because of arithmetic overflow.
 *
 * The API function png_set_alpha_mode specifies which of these choices to use
 * with an enumerated 'mode' value and the gamma of the required output:
 *//*for red/green coefficients*//* Reduce RGB to grayscale. *//* Expand the grayscale to 24-bit RGB if necessary. *//* Use blue, green, red order for pixels. *//* Expand to 16-bit channels, forces conversion of palette to RGB and expansion
 * of a tRNS chunk if present.
 *//* Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. *//* CONVERT_tIME *//* Convert from time_t to png_time.  Uses gmtime() *//* Convert from a struct tm to png_time *//* Removed from libpng 1.7 onwards; use png_convert_to_rfc1123_buffer. *//* Convert to a US string format: there is no localization support in this
    * routine.  The original implementation used a 29 character buffer in
    * png_struct, this will be removed in future versions.
    *//* Read the information before the actual image data. *//* Writes all the PNG information before the image. *//* DEPRECATED: this function allowed init structures to be created using the
 * default allocation method (typically malloc).  Use is deprecated in 1.6.0 and
 * the API will be removed in the future.
 *//* Allocate and initialize the info structure *//* Finish a chunk started with png_write_chunk_start() (includes CRC). *//* Write the data of a PNG chunk started with png_write_chunk_start(). *//* Write the start of a PNG chunk - length and chunk name. *//* Write a PNG chunk - size, type, (optional) data, CRC. *//* Write the PNG file signature. *//* New functions added in libpng-1.0.2 (not enabled by default until 1.2.0) *//* Reset the compression stream *//* This function should be used by libpng applications in place of
 * longjmp(png_ptr->jmpbuf, val).  If longjmp_fn() has been set, it
 * will use it; otherwise it will call PNG_ABORT().  This function was
 * added in libpng-1.5.0.
 *//* This function returns the jmp_buf built in to *png_ptr.  It must be
 * supplied with an appropriate 'longjmp' function to use on that jmp_buf
 * unless the default error function is overridden in which case NULL is
 * acceptable.  The size of the jmp_buf is checked against the actual size
 * allocated by the library - the call will return NULL on a mismatch
 * indicating an ABI mismatch.
 *//* Moved from pngconf.h in 1.4.0 and modified to ensure setjmp/longjmp
 * match up.
 *//* Allocate and initialize png_ptr struct for writing, and any other memory *//* Allocate and initialize png_ptr struct for reading, and any other memory. *//* Check sig[start] through sig[start + num_to_check - 1] to see if it's a
 * PNG file.  Returns zero if the supplied bytes match the 8-byte PNG
 * signature, and non-zero otherwise.  Having num_to_check == 0 or
 * start > 7 will always fail (i.e. return non-zero).
 *//* Tell lib we have already handled the first <num_bytes> magic bytes.
 * Handling more than 8 bytes from the beginning of the file is an error.
 *//* Returns the version number of the library *//* Section 4: exported functions
 * Here are the function definitions most commonly used.  This is not
 * the place to find out how to use libpng.  See libpng-manual.txt for the
 * full explanation, see example.c for the summary.  This just provides
 * a simple one line description of the use of each function.
 *
 * The PNG_EXPORT() and PNG_EXPORTA() macros used below are defined in
 * pngconf.h and in the *.dfn files in the scripts directory.
 *
 *   PNG_EXPORT(type, name, (args));
 *
 *       type:       return type of the function
 *       name:       function name
 *       args:       function arguments, with types
 *
 * When we wish to append attributes to a function prototype we use
 * the PNG_EXPORTA() macro instead.
 *
 *   PNG_EXPORTA(type, name, (args), attributes);
 *
 *       type, name, and args: same as in PNG_EXPORT().
 *       attributes: function attributes
 *//* NOTE: prior to 1.5 these functions had no 'API' style declaration,
 * this allowed the zlib default functions to be used on Windows
 * platforms.  In 1.5 the zlib default malloc (which just calls malloc and
 * ignores the first argument) should be completely compatible with the
 * following.
 *//* Flags for MNG supported features *//* read only *//* or else this might break on a 16-bit machine *//* Added to libpng-1.5.4 *//* Added to libpng-1.4.0 *//* write only *//* Added to libpng-1.2.34 *//* read and write *//* Transform masks for the high-level interface *//* This must match the function definition in <setjmp.h>, and the application
 * must include this before png.h to obtain the definition of jmp_buf.  The
 * function is required to be PNG_NORETURN, but this is not checked.  If the
 * function does return the application will crash via an abort() or similar
 * system level call.
 *
 * If you get a warning here while building the library you may need to make
 * changes to ensure that pnglibconf.h records the calling convention used by
 * your compiler.  This may be very difficult - try using a different compiler
 * to build the library!
 *//* typedef PNG_CALLBACK(void, *png_unknown_chunk_ptr, (png_struct *)); *//* not used anywhere *//* The following callback receives png_uint_32 row_number, int pass for the
 * png_byte* data of the row.  When transforming an interlaced image the
 * row number is the row number within the sub-image of the interlace pass, so
 * the value will increase to the height of the sub-image (not the full image)
 * then reset to 0 for the next pass.
 *
 * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
 * find the output pixel (x,y) given an interlaced sub-image pixel
 * (row,col,pass).  (See below for these macros.)
 *//* These are the function types for the I/O functions and for the functions
 * that allow the user to override the default I/O functions with his or her
 * own.  The png_error_ptr type should match that of user-supplied warning
 * and error functions, while the png_rw_ptr type should match that of the
 * user read/write data functions.  Note that the 'write' function must not
 * modify the buffer it is passed. The 'read' function, on the other hand, is
 * expected to return the read data in the buffer.
 *//* bits per pixel (depth * channels) *//* number of channels (1, 2, 3, or 4) *//* bit depth of row *//* color type of row *//* number of bytes in row *//* width of row *//* This is used for the transformation routines, as some of them
 * change these values for the row.  It also should enable using
 * the routines for other purposes.
 *//* PNGv3: 1.6.45: unknown *//* APNG: these chunks are stored as unknown, these flags are never set
 * however they are provided as a convenience for implementors of APNG and
 * avoids any merge conflicts.
 *
 * Private chunks: these chunk names violate the chunk name recommendations
 * because the chunk definitions have no signature and because the private
 * chunks with these names have been reserved.  Private definitions should
 * avoid them.
 *//* PNGv3: 1.6.45 *//* GR-P, 1.6.31 *//* ESR, 1.0.6 *//* GR-P, 0.96a *//* These determine if an ancillary chunk's data has been successfully read
 * from the PNG header, or if the application has filled in the corresponding
 * data in the info_struct to be written into the output file.  The values
 * of the PNG_INFO_<chunk> defines should NOT be changed.
 *//* Maximum number of entries in PLTE/sPLT/tRNS arrays *//* This is for text chunks *//* Not a valid value *//* These are also for the fcTL chunk, and they should also NOT be changed. *//* These are for the fcTL chunk.  These values should NOT be changed. *//* These are for the sRGB chunk.  These values should NOT be changed. *//* pixels/meter *//* pixels/unknown unit (aspect ratio) *//* These are for the pHYs chunk.  These values should NOT be changed. *//* radians per pixel *//* meters per pixel *//* unknown unit (image scale) *//* These are for the sCAL chunk.  These values should NOT be changed. *//* Hyperbolic sine transformation *//* Arbitrary base exponential transform *//* Exponential base e transform *//* Linear transformation *//* These are for the pCAL chunk.  These values should NOT be changed. *//* Offset in micrometers (1/10^6 meter) *//* Offset in pixels *//* These are for the oFFs chunk.  These values should NOT be changed. *//* Adam7 interlacing *//* Non-interlaced image *//* These are for the interlacing type.  These values should NOT be changed. *//* Used only in MNG datastreams *//* Single row per-byte filtering *//* This is for filter type. PNG 1.0-1.2 only define the single type. *//* Deflate method 8, 32K window *//* This is for compression type. PNG 1.0-1.2 only define the single type. *//* aliases *//* color types.  Note that not all combinations are legal *//* color type masks *//* These describe the color_type field in png_info. *//* These are constants for fixed point values encoded in the
 * PNG specification manner (x100000)
 *//* Maximum positive integer used in PNG is (2^31)-1 *//* Flag values for the unknown chunk location byte. *//* mode of operation at read time *//* On write 'location' must be set using the flag values listed below.
    * Notice that on read it is set by libpng however the values stored have
    * more bits set than are listed below.  Always treat the value as a
    * bitmask.  On write set only one bit - setting multiple bits may cause the
    * chunk to be written in multiple places.
    *//* Data, should not be modified on read! *//* Textual chunk name with '\0' terminator *//* png_unknown_chunk is a structure to hold queued chunks for which there is
 * no specific support.  The idea is that we can use this to queue
 * up private chunks for output even though the library doesn't actually
 * know about their semantics.
 *
 * The data in the structure is set by libpng on read and used on write.
 *//* second of minute, 0 - 60 (for leap seconds) *//* minute of hour, 0 - 59 *//* hour of day, 0 - 23 *//* day of month, 1 - 31 *//* month of year, 1 - 12 *//* full year, as in, 1995 *//* png_time is a way to hold the time in an machine independent way.
 * Two conversions are provided, both from time_t and struct tm.  There
 * is no portable way to convert to either of these structures, as far
 * as I know.  If you know of a portable way, send it to me.  As a side
 * note - PNG has always been Year 2000 compliant!
 *//* Supported compression types for text in PNG files (tEXt, and zTXt).
 * The values of the PNG_TEXT_COMPRESSION_ defines should NOT be changed. *//* keyword translated UTF-8 string, 0 or more
                              chars or a NULL pointer *//* language code, 0-79 characters
                              or a NULL pointer *//* length of the itxt string *//* length of the text string *//* comment, may be an empty string (ie "")
                              or a NULL pointer *//* keyword, 1-79 character description of "text" *//* compression value:
                             -1: tEXt, none
                              0: zTXt, deflate
                              1: iTXt, none
                              2: iTXt, deflate  *//* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,
 * and whether that contents is compressed or not.  The "key" field
 * points to a regular zero-terminated C string.  The "text" fields can be a
 * regular C string, an empty string, or a NULL pointer.
 * However, the structure returned by png_get_text() will always contain
 * the "text" field as a regular zero-terminated C string (possibly
 * empty), never a NULL pointer, so it can be safely used in printf() and
 * other string-handling functions.  Note that the "itxt_length", "lang", and
 * "lang_key" members of the structure only exist when the library is built
 * with iTXt chunk support.  Prior to libpng-1.4.0 the library was built by
 * default without iTXt support. Also note that when iTXt *is* supported,
 * the "lang" and "lang_key" fields contain NULL pointers when the
 * "compression" field contains * PNG_TEXT_COMPRESSION_NONE or
 * PNG_TEXT_COMPRESSION_zTXt. Note that the "compression value" is not the
 * same as what appears in the PNG tEXt/zTXt/iTXt chunk's "compression flag"
 * which is always 0 or 1, or its "compression method" which is always 0.
 *//* number of palette entries *//* palette entries *//* depth of palette samples *//* palette name *//*  When the depth of the sPLT palette is 8 bits, the color and alpha samples
 *  occupy the LSB of their respective members, and the MSB of each member
 *  is zero-filled.  The frequency member always occupies the full 16 bits.
 *//*
 * The following two structures are used for the in-core representation
 * of sPLT chunks.
 *//* for alpha channel files *//* for use in grayscale files *//* for use in red green blue files *//* used for palette files *//* Three color definitions.  The order of the red, green, and blue, (and the
 * exact size) is not important, although the size of the fields need to
 * be png_byte or png_uint_16 (as defined below).
 *//* png_info contains information read from or to be written to a PNG file.
 * One or more of these must exist while reading or creating a PNG file.
 * The information is not used by libpng during read, but is used to control
 * what gets written when a PNG file is created.  "png_get_" function calls
 * read information during decoding, while "png_set_" function calls write
 * information during encoding.
 *//* png_struct is the cache of information used while reading or writing a
 * PNG file.  One of these is always required, although the simplified API
 * (below) hides the creation and destruction of it.
 *//* Basic control structures: png_struct, png_info, etc.
 *
 * The type names ending in 'p', 'pp' and 'rp' denote pointer,
 * pointer-to-pointer and restricted-pointer types, respectively.
 * Although these types are deprecated as of libpng 1.8.0, their
 * declarations remain in the public headers to ensure continued
 * compatibility with the existing PNG-supporting applications.
 *
 * See the libpng manual for more information.
 *//* This triggers a compiler error in png.c, if png.c and png.h
 * do not agree upon the version number.
 *//* Section 3: type definitions, including structures and compile time
 * constants.
 * See pngconf.h for base types that vary by machine/system
 *//* Section 2: run time configuration
 * See pnglibconf.h for build time configuration
 *
 * Run time configuration allows the application to choose between
 * implementations of certain arithmetic APIs.  The default is set
 * at build time and recorded in pnglibconf.h, but it is safe to
 * override these (and only these) settings.  Note that this won't
 * change what the library does, only application code, and the
 * settings can (and probably should) be made on a per-file basis
 * by setting the #defines before including png.h
 *
 * Use macros to read integers from PNG data or use the exported
 * functions?
 *   PNG_USE_READ_MACROS: use the macros (see below)  Note that
 *     the macros evaluate their argument multiple times.
 *   PNG_NO_USE_READ_MACROS: call the relevant library function.
 *
 * Use the alternative algorithm for compositing alpha samples that
 * does not use division?
 *   PNG_READ_COMPOSITE_NODIV_SUPPORTED: use the 'no division'
 *      algorithm.
 *   PNG_NO_READ_COMPOSITE_NODIV: use the 'division' algorithm.
 *
 * How to handle benign errors if PNG_ALLOW_BENIGN_ERRORS is
 * false?
 *   PNG_ALLOW_BENIGN_ERRORS: map calls to the benign error
 *      APIs to png_warning.
 * Otherwise the calls are mapped to png_error.
 *//* Section 1: [omitted] *//* This file is arranged in several sections:
 *
 * 1. [omitted]
 * 2. Any configuration options that can be specified by for the application
 *    code when it is built.  (Build time configuration is in pnglibconf.h)
 * 3. Type definitions (base types are defined in pngconf.h), structure
 *    definitions.
 * 4. Exported library functions.
 * 5. Simplified API.
 * 6. Implementation options.
 *
 * The library source code has additional files (principally pngpriv.h) that
 * allow configuration of the library.
 *//* Version information for C files, stored in png.c.  This had better match
 * the version above.
 *//* __cplusplus *//* Inhibit C++ name-mangling for libpng functions but not for system calls. *//* From pnglibconf.h *//*
 * Added at libpng-1.2.8
 *
 * Ref MSDN: Private as priority over Special
 * VS_FF_PRIVATEBUILD File *was not* built using standard release
 * procedures. If this value is given, the StringFileInfo block must
 * contain a PrivateBuild string.
 *
 * VS_FF_SPECIALBUILD File *was* built by the original company using
 * standard release procedures but is a variation of the standard
 * file of the same version number. If this value is given, the
 * StringFileInfo block must contain a SpecialBuild string.
 *//* Machine specific configuration. *//* If pnglibconf.h is missing, you can copy
 * pnglibconf.h.prebuilt to pnglibconf.h
 *//* Library configuration: these options cannot be changed after
 * the library has been built.
 *//* 1.8.0.git *//* Careful here.  At one time, Guy wanted to use 082, but that
 * would be octal.  We must not include leading zeros.
 * Versions 0.7 through 1.0.0 were in the range 0 to 100 here
 * (only version 1.0.0 was mis-numbered 100 instead of 10000).
 * From version 1.0.1 it is:
 * XXYYZZ, where XX=major, YY=minor, ZZ=release
 *//* Cannot be OR'ed with
                                       PNG_LIBPNG_BUILD_PRIVATE *//* Cannot be OR'ed with
                                       PNG_LIBPNG_BUILD_SPECIAL *//* Can be OR'ed with
                                       PNG_LIBPNG_BUILD_STABLE only *//* Release-Specific Flags *//* Release Status *//* This should be zero for a public release, or non-zero for a
 * development version.
 *//* The versions of shared library builds should stay in sync, going forward *//* These should match the first 3 components of PNG_LIBPNG_VER_STRING: *//* Version information for png.h - this should match the version in png.c *//*
 * The contributing authors would like to thank all those who helped
 * with testing, bug fixes, and patience.  This wouldn't have been
 * possible without all of you.
 *
 * Thanks to Frank J. T. Wojcik for helping with the documentation.
 *//*
 * A "png_get_copyright" function is available, for convenient use in "about"
 * boxes and the like:
 *
 *    printf("%s", png_get_copyright(NULL));
 *
 * Also, the PNG logo (in PNG format, of course) is supplied in the
 * files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
 *//*
 * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE
 * =========================================
 *
 * PNG Reference Library License version 2
 * ---------------------------------------
 *
 *  * Copyright (c) 1995-2025 The PNG Reference Library Authors.
 *  * Copyright (c) 2018-2025 Cosmin Truta.
 *  * Copyright (c) 2000-2002, 2004, 2006-2018 Glenn Randers-Pehrson.
 *  * Copyright (c) 1996-1997 Andreas Dilger.
 *  * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
 *
 * The software is supplied "as is", without warranty of any kind,
 * express or implied, including, without limitation, the warranties
 * of merchantability, fitness for a particular purpose, title, and
 * non-infringement.  In no event shall the Copyright owners, or
 * anyone distributing the software, be liable for any damages or
 * other liability, whether in contract, tort or otherwise, arising
 * from, out of, or in connection with the software, or the use or
 * other dealings in the software, even if advised of the possibility
 * of such damage.
 *
 * Permission is hereby granted to use, copy, modify, and distribute
 * this software, or portions hereof, for any purpose, without fee,
 * subject to the following restrictions:
 *
 *  1. The origin of this software must not be misrepresented; you
 *     must not claim that you wrote the original software.  If you
 *     use this software in a product, an acknowledgment in the product
 *     documentation would be appreciated, but is not required.
 *
 *  2. Altered source versions must be plainly marked as such, and must
 *     not be misrepresented as being the original software.
 *
 *  3. This Copyright notice may not be removed or altered from any
 *     source or altered source distribution.
 *
 *
 * PNG Reference Library License version 1 (for libpng 0.5 through 1.6.35)
 * -----------------------------------------------------------------------
 *
 * libpng versions 1.0.7, July 1, 2000, through 1.6.35, July 15, 2018 are
 * Copyright (c) 2000-2002, 2004, 2006-2018 Glenn Randers-Pehrson, are
 * derived from libpng-1.0.6, and are distributed according to the same
 * disclaimer and license as libpng-1.0.6 with the following individuals
 * added to the list of Contributing Authors:
 *
 *     Simon-Pierre Cadieux
 *     Eric S. Raymond
 *     Mans Rullgard
 *     Cosmin Truta
 *     Gilles Vollant
 *     James Yu
 *     Mandar Sahastrabuddhe
 *     Google Inc.
 *     Vadim Barkov
 *
 * and with the following additions to the disclaimer:
 *
 *     There is no warranty against interference with your enjoyment of
 *     the library or against infringement.  There is no warranty that our
 *     efforts or the library will fulfill any of your particular purposes
 *     or needs.  This library is provided with all faults, and the entire
 *     risk of satisfactory quality, performance, accuracy, and effort is
 *     with the user.
 *
 * Some files in the "contrib" directory and some configure-generated
 * files that are distributed with libpng have other copyright owners, and
 * are released under other open source licenses.
 *
 * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
 * Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from
 * libpng-0.96, and are distributed according to the same disclaimer and
 * license as libpng-0.96, with the following individuals added to the
 * list of Contributing Authors:
 *
 *     Tom Lane
 *     Glenn Randers-Pehrson
 *     Willem van Schaik
 *
 * libpng versions 0.89, June 1996, through 0.96, May 1997, are
 * Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,
 * and are distributed according to the same disclaimer and license as
 * libpng-0.88, with the following individuals added to the list of
 * Contributing Authors:
 *
 *     John Bowler
 *     Kevin Bracey
 *     Sam Bushell
 *     Magnus Holmgren
 *     Greg Roelofs
 *     Tom Tanner
 *
 * Some files in the "scripts" directory have other copyright owners,
 * but are released under this license.
 *
 * libpng versions 0.5, May 1995, through 0.88, January 1996, are
 * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
 *
 * For the purposes of this copyright and license, "Contributing Authors"
 * is defined as the following set of individuals:
 *
 *     Andreas Dilger
 *     Dave Martindale
 *     Guy Eric Schalnat
 *     Paul Schmidt
 *     Tim Wegner
 *
 * The PNG Reference Library is supplied "AS IS".  The Contributing
 * Authors and Group 42, Inc. disclaim all warranties, expressed or
 * implied, including, without limitation, the warranties of
 * merchantability and of fitness for any purpose.  The Contributing
 * Authors and Group 42, Inc. assume no liability for direct, indirect,
 * incidental, special, exemplary, or consequential damages, which may
 * result from the use of the PNG Reference Library, even if advised of
 * the possibility of such damage.
 *
 * Permission is hereby granted to use, copy, modify, and distribute this
 * source code, or portions hereof, for any purpose, without fee, subject
 * to the following restrictions:
 *
 *  1. The origin of this source code must not be misrepresented.
 *
 *  2. Altered versions must be plainly marked as such and must not
 *     be misrepresented as being the original source.
 *
 *  3. This Copyright notice may not be removed or altered from any
 *     source or altered source distribution.
 *
 * The Contributing Authors and Group 42, Inc. specifically permit,
 * without fee, and encourage the use of this source code as a component
 * to supporting the PNG file format in commercial products.  If you use
 * this source code in a product, acknowledgment is not required but would
 * be appreciated.
 *
 * END OF COPYRIGHT NOTICE, DISCLAIMER, and LICENSE.
 *
 * TRADEMARK
 * =========
 *
 * The name "libpng" has not been registered by the Copyright owners
 * as a trademark in any jurisdiction.  However, because libpng has
 * been distributed and maintained world-wide, continually since 1995,
 * the Copyright owners claim "common-law trademark protection" in any
 * jurisdiction where common-law trademark is recognized.
 *//* png.h - header file for PNG reference library
 *
 * libpng version 1.8.0.git
 *
 * Copyright (c) 2018-2025 Cosmin Truta
 * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
 * Copyright (c) 1996-1997 Andreas Dilger
 * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
 *
 * This code is released under the libpng license. (See LICENSE, below.)
 *
 * Authors and maintainers:
 *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
 *   libpng versions 0.89, June 1996, through 0.96, May 1997: Andreas Dilger
 *   libpng versions 0.97, January 1998, through 1.6.35, July 2018:
 *     Glenn Randers-Pehrson
 *   libpng versions 1.6.36, December 2018, through 1.6.53, December 2025:
 *     Cosmin Truta
 *   See also "Contributing Authors", below.
 */res_yunit_typeuser_chunk_cache_maxuser_width_maxuser_height_maxmng_features_permittedtransformsparamsmaskchunkunknownsnum_unknownschunk_namekeepchunk_listnum_chunksunitswidthsheighttrans_alphanum_transtrans_colormod_timetext_ptrnum_textcompression_typeprofileproflensrgb_intentfile_srgb_intentsig_bitpalettenum_palettepurposeX0X1typenparamsunitsoffset_xoffset_yint_white_xint_white_yint_red_xint_red_yint_green_xint_green_yint_blue_xint_blue_ymastering_display_maximum_luminance_scaled_by_10000mastering_display_minimum_luminance_scaled_by_10000white_xwhite_yred_xred_ygreen_xgreen_yblue_xblue_ymastering_display_maximum_luminancemastering_display_minimum_luminanceinterlace_methodcompression_methodfilter_methodhistint_file_gammafile_gammanum_exifexifmaximum_content_light_level_scaled_by_10000maximum_frame_average_light_level_scaled_by_10000maximum_content_light_levelmaximum_frame_average_light_levelcolour_primariestransfer_functionmatrix_coefficientsvideo_full_range_flagint_red_Xint_red_Yint_red_Zint_green_Xint_green_Yint_green_Zint_blue_Xint_blue_Yint_blue_Zred_Xred_Yred_Zgreen_Xgreen_Ygreen_Zblue_Xblue_Yblue_Zflagwarning_messageerror_messagedeprecatedptrfreerfree_menumold_rownew_rowsavebuffer_sizeprogressive_ptrinfo_fnrow_fnend_fnuser_chunk_ptrread_user_chunk_fnuser_transform_ptruser_transform_depthuser_transform_channelswrite_user_transform_fnread_user_transform_fnmem_ptrmalloc_fnfree_fnwrite_row_fnread_row_fnio_ptrread_data_fnwrite_data_fnoutput_flush_fnerror_ptrerror_fnwarning_fnfpmethodwindow_bitsstrategymem_levellevelfilterscrit_actionancil_actionpng_ptr_ptrinfo_ptr_ptrend_info_ptr_ptrrownum_rowsdisplay_rownrowsscreen_gammaoverride_file_gammamaximum_colorshistogramfull_quantizebackground_colorbackground_gamma_codeneed_expandbackground_gammatrue_bitsfillermodeoutput_gammaerror_actionptimettimeoutpng_info_struct_sizelengthuser_png_verwarn_fnvallongjmp_fnjmp_buf_sizesigstartnum_to_checknum_bytesC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/stdlib.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/corecrt.hC:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.43.34808/include/vcruntime.hC:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.43.34808/include/sal.hC:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.43.34808/include/concurrencysal.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/corecrt_malloc.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/corecrt_search.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/stddef.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/corecrt_wstdlib.hC:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.43.34808/include/limits.h11C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/string.h12C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/corecrt_memory.h13C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/corecrt_memcpy_s.h14C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/errno.h15C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.43.34808/include/vcruntime_string.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/corecrt_wstring.h17C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/corecrt_stdio_config.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/assert.h2122D:/PracticeInCodeQL/libpng/build/pnglibconf.h23D:/PracticeInCodeQL/libpng/pngconf.h24C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.43.34808/include/setjmp.h25C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/time.h26C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/corecrt_wtime.h27D:/PracticeInCodeQL/libpng/contrib/libtests/pngimage.c"../../png.h"<assert.h><stdio.h><errno.h><string.h><stdlib.h>option_endilogddisplay *--verbose"--verbose"char[10]LEVEL_MASK-16~LEVEL_MASK4294967280VERBOSE--warnings"--warnings"char[11]WARNINGS--errors"--errors"char[9]ERRORS--quiet"--quiet"char[8]QUIET--exhaustive"--exhaustive"char[13]EXHAUSTIVE--fast"--fast"char[7]-17~EXHAUSTIVE4294967279--strict"--strict"STRICT--relaxed"--relaxed"-33~STRICT4294967263--log"--log"char[6]LOG--nolog"--nolog"-65~LOG4294967231--continue"--continue"128CONTINUE--stop"--stop"-129~CONTINUE4294967167--skip-bugs"--skip-bugs"char[12]SKIP_BUGS--test-all"--test-all"-257~SKIP_BUGS4294967039--log-skipped"--log-skipped"char[14]LOG_SKIPPED--nolog-skipped"--nolog-skipped"char[16]-513~LOG_SKIPPED4294966783--find-bad-combos"--find-bad-combos"1024FIND_BAD_COMBOS--nofind-bad-combos"--nofind-bad-combos"-1025~FIND_BAD_COMBOS4294966271--list-combos"--list-combos"2048LIST_COMBOS--nolist-combos"--nolist-combos"-2049~LIST_COMBOS429496524745'-'pngimage: %s: unknown option
"pngimage: %s: unknown option\n"char[30]errorsd.resultsretpass4294967292314294967264j%s: pngimage "%s: pngimage "PASS"PASS"char[5]FAIL"FAIL"%s "%s "char[4]%s
"%s\n"do_testINTERNAL_ERRORunexpected return code %d"unexpected return code %d"test_one_filecache file"cache file"buffer *ignored transforms"ignored transforms"char[19]write"write"activeexhaustivecurrentbad_transformsbad_combo0U4294967295~0Ubad_combo_list(next & read_transforms) == next"(next & read_transforms) == next"__FILE__"D:\\PracticeInCodeQL\\libpng\\contrib\\libtests\\pngimage.c"active transforms"active transforms"reversible transforms"reversible transforms"char[22]nextunsigned short[33]D:/PracticeInCodeQL/libpng/contrib/libtestsD:/PracticeInCodeQL/libpng/contribdpfilenameD:\PracticeInCodeQL\libpng\contrib\libtests\pngimage.cunsigned short[55]1537combo%s[0x%x]: PROBLEM: 0x%x[0x%x] ANTIDOTE: 0x%x
"%s[0x%x]: PROBLEM: 0x%x[0x%x] ANTIDOTE: 0x%x\n"char[46]%s: no %sbad combos found
"%s: no %sbad combos found\n"char[27]additional "additional "char[1]skip_transformSKIP: %s transforms "SKIP: %s transforms "%s"%s"char[3]'+''\n'INFORMATION%s: skipped known bad combo 0x%x"%s: skipped known bad combo 0x%x"char[33]write_png1.8.0.gitAPP_ERRORfailed to create write png_struct"failed to create write png_struct"char[34]21474836470x7fffffff2052(PNG_TRANSFORM_PACKING|
                     PNG_TRANSFORM_STRIP_FILLER|
                     PNG_TRANSFORM_STRIP_FILLER_BEFORE)ctPNG_TRANSFORM_STRIP_FILLER|
                        PNG_TRANSFORM_STRIP_FILLER_BEFORE(PNG_TRANSFORM_STRIP_FILLER|
                        PNG_TRANSFORM_STRIP_FILLER_BEFORE)-5~PNG_COLOR_MASK_ALPHAwrite_functionbuffer_writebuffer_list *lastend_countavailpng_byte[1024]unsigned char[1024]sizeof last->bufferout of memory saving file"out of memory saving file"(sizeof last->buffer)compare_readeLIBPNG_BUGpng_get_IHDR failed"png_get_IHDR failed"IHDR width(%lu) changed to %luchar[31]IHDR height(%lu) changed to %luchar[32]IHDR bit_depth(%lu) changed to %luchar[35]IHDR color_type(%lu) changed to %luchar[36]IHDR interlace_method(%lu) changed to %luchar[42]char[17]IHDR compression_method(%lu) changed to %luchar[44]IHDR filter_method(%lu) changed to %luchar[39]IHDR changed (%s)"IHDR changed (%s)"chunks0xffffffffAPP_FAILPNG chunks changed from 0x%lx to 0x%lx"PNG chunks changed from 0x%lx to 0x%lx"PNG rowbytes changed from %lu to %lu"PNG rowbytes changed from %lu to %lu"char[37]rows2550xff652800xff00png_get_rows returned NULL"png_get_rows returned NULL"yorigxbyte(%lu,%lu) changed 0x%.2x -> 0x%.2x"byte(%lu,%lu) changed 0x%.2x -> 0x%.2x"bpppng_byte[8]unsigned char[8]sig_bitssBITactive shift transform but no sBIT in file"active shift transform but no sBIT in file"char[43]tripppapplied_transformsLIBPNG_ERRORinvalid colour type %d"invalid colour type %d"sizeof(sig_bits)binvalid sBIT[%u]  value %d returned for PNG bit depth %d"invalid sBIT[%u]  value %d returned for PNG bit depth %d"char[57]invalid bpp %u for bit_depth %u"invalid bpp %u for bit_depth %u"42949017600xffff00000x30x3<<2(0x3<<2)0xf2400xf << 4(0xf << 4)invalid bit depth %d"invalid bit depth %d"mask calculation error %u, %u"mask calculation error %u, %u"significant bits at (%lu[%u],%lu) changed %.2x->%.2x"significant bits at (%lu[%u],%lu) changed %.2x->%.2x"char[53]significant bits at (%lu[end],%lu) changed"significant bits at (%lu[end],%lu) changed"update_displayoriginal read"original read"png_get_rowbytes returned 0"png_get_rowbytes returned 0"char[28]32768png_read_png did not set IDAT flag"png_read_png did not set IDAT flag"png_read_png did not create row buffers"png_read_png did not create row buffers"char[40]inactivebdtransform_infotransform_info[21]504transform_info *transformTRANSFORM_Rread_pngfailed to create read struct"failed to create read struct"failed to create info struct"failed to create info struct"read_functionbuffer_readread_countUSER_ERRORfile truncated (%lu bytes)"file truncated (%lu bytes)"damaged buffer list"damaged buffer list"display_cache_filerb"rb"open failed: %s"open failed: %s"read failed: %s"read failed: %s"display_errordisplay_warningLIBPNG_WARNINGdisplay_log1Ulpapinformation"information"warning(libpng)"warning(libpng)"APP_WARNINGwarning(pngimage)"warning(pngimage)"error(continuable)"error(continuable)"bpoperationwarningfmterror(libpng)"error(libpng)"bug(libpng)"bug(libpng)"error(pngimage)"error(pngimage)"error(user)"error(user)"bug(pngimage)"bug(pngimage)"%s: %s: %s"%s: %s: %s"<stdin>"<stdin>"trx("("char[2]trz+"+"-"-")")"(0x%x)"(0x%x)"(%s)"(%s)": ": "get_dppngimage: internal error (no display)
"pngimage: internal error (no display)\n"display_destroydisplay_cleandisplay_clean_writedisplay_clean_readdisplay_init2528sizeof *dpbuffer_from_filecountcount == sizeof last->buffer"count == sizeof last->buffer"runsigned short[29]475ERANGEbuffer_extendaddcurrent->next == NULLcurrent->next == ((void *)0)"current->next == NULL"unsigned short[22]443struct buffer_list1032get_bufferbuffer_start_readbuffer_start_writebuffer_destroylistbuffer_destroy_listbuffer_initvalidate_TTRANSFORM_Wtransform_nameinvalid transform"invalid transform"is_bad_comboknown_bad_combosint[2]int[1][2]int(*)[2]ARRAY_SIZE(known_bad_combos)first_transformis_combodisplayerror_level(unnamed enum)buffer_listoriginal_filewritten_filewrite_ppread_ipread_ppignored_transformsactive_transformsoriginal_rowsoriginal_rowbytesoriginal_iporiginal_ppresultsoptionserror_codeerror_returnfirsttestedwhenbit_depthscolor_mask_absentcolor_mask_requiredvalid_chunksrw_transformswrite_transformsread_transformsint[][2]1088transform_info[]STRIP_16NONERSTRIP_ALPHAAALLPACKINGLOWRW_PACKPACKSWAPRW_PACKSWAPEXPANDPCtRNSINVERT_MONORW_INVERTSHIFTRW_SHIFTBGRTRUERW_BGRSWAP_ALPHARW_SWAP_ALPHASWAP_ENDIANRW_SWAPINVERT_ALPHARW_INVERT_ALPHASTRIP_FILLER_BEFOREWSTRIP_FILLER_AFTERGRAY_TO_RGBEXPAND_16PALSCALE_16t4096819216384C(item)if (item != dp->item) display_log(dp, APP_WARNING, "IHDR " #item "(%lu) changed to %lu", (unsigned long)dp->item, (unsigned long)item), e = #itemVGATTRRESULT_RELAXED(r)(((r) & ~((1U<<ERRORS)-1)) == 0)RESULT_STRICT(r)(((r) & ~((1U<<WARNINGS)-1)) == 0)0x8000x4000x2000x1000x0800x0400x0200x010MEMORYENOMEMDELETE(ptr)(free(ptr))NEW(type)((type *)malloc(sizeof (type)))TTABLE_SIZEARRAY_SIZE(transform_info)ARRAY_SIZE(a)((sizeof a)/(sizeof a[0]))TTRANSFORM_RW_INVERT_ALPHATRANSFORM_RWTRANSFORM_RW_SWAPTRANSFORM_RW_SWAP_ALPHATRANSFORM_RW_BGRTRANSFORM_RW_SHIFTTRANSFORM_RW_INVERTTRANSFORM_RW_PACKSWAPTRANSFORM_RW_PACKT(name,chunk,cm_required,cm_absent,bd,when){ #name, PNG_TRANSFORM_ ## name, CHUNK_ ## chunk, COLOR_MASK_ ## cm_required, COLOR_MASK_ ## cm_absent, BD_ ## bd, TRANSFORM_ ## when, 0 }BD_TRUE(8+16)BD_16BD_LOW(1 + 2 + 4)BD_PAL(1 + 2 + 4 + 8)BD_ALL(1 + 2 + 4 + 8 + 16)COLOR_MASK_ALL(PALETTE+COLOR+ALPHA)COLOR_MASK_ACOLOR_MASK_CCOLOR_MASK_PCOLOR_MASK_XCHUNK_tRNSCHUNK_sBITCHUNK_NONEPNG_WRITE_PNG_SUPPORTEDPNG_READ_PNG_SUPPORTEDSKIPdefined(HAVE_CONFIG_H) && !defined(PNG_NO_CONFIG_H)PNG_FREESTANDING_TESTSdefined(HAVE_CONFIG_H)PNG_WRITE_PACK_SUPPORTEDPNG_READ_PACK_SUPPORTEDPNG_WRITE_PACKSWAP_SUPPORTEDPNG_READ_PACKSWAP_SUPPORTEDPNG_WRITE_INVERT_SUPPORTEDPNG_READ_INVERT_SUPPORTEDPNG_WRITE_SHIFT_SUPPORTEDPNG_READ_SHIFT_SUPPORTEDPNG_WRITE_BGR_SUPPORTEDPNG_READ_BGR_SUPPORTEDPNG_WRITE_SWAP_ALPHA_SUPPORTEDPNG_READ_SWAP_ALPHA_SUPPORTEDPNG_WRITE_SWAP_SUPPORTEDPNG_READ_SWAP_SUPPORTEDPNG_WRITE_INVERT_ALPHA_SUPPORTEDPNG_READ_INVERT_ALPHA_SUPPORTEDPNG_WRITE_FILLER_SUPPORTED__GNUC__PNG_WRITE_INTERLACING_SUPPORTEDva_endva_start/* !READ_PNG *//* Release allocated memory *//* Here on any return, including failures, except user/internal issues
          *//* abort on user or internal error *//* Not an option *//* prevent display *//* For each file on the command line test it with a range of transforms *//* shouldn't longjmp on warnings *//* The "lowest" level *//* Exists solely to isolate the setjmp clobbers *//* bad_combos identifies the combos that occur in all failing cases;
          * bad_combo_list identifies transforms that do not prevent the
          * failure.
          *//* one at a time *//* skip cases that do nothing *//* skip known bad combos if the relevant option is set; skip
                * combos involving known bad single transforms in all cases.
                *//* Everything tested *//* all combinations *//* Now move to the next transform *//* This set of transforms failed.  If a single bit is set - if
                * there is just one transform - don't include this in further
                * 'exhaustive' tests.  Notice that each transform is tested on
                * its own before testing combos in the exhaustive case.
                *//*for the SHIFT/sBIT transform*//* And if this is read back in, because all the transformations were
             * reversible, the result should be the same.
             *//* All transforms reversible: write the PNG with the transformations
             * reversed, then read it back in with no transformations.  The
             * result should be the same as the original apart from the loss of
             * low order bits because of the SHIFT/sBIT transform.
             *//* If this involved any irreversible transformations then if we write
          * it out with just the reversible transformations and read it in again
          * with the same transforms we should get the same thing.  At present
          * this isn't done - it just seems like a waste of time and it would
          * require two sets of read png_struct/png_info.
          *
          * If there were no irreversible transformations then if we write it
          * out and read it back in again (without the reversible transforms)
          * we should get back to the place where we started.
          *//* bitwise OR of failures *//* bitwise AND of failing transforms *//* Use unsigned int here because the code below to increment through all
       * the possibilities exhaustively has to use a compare and that must be
       * unsigned, because some transforms are negative on a 16-bit system.
       *//* Third test: the active options.  Test each in turn, or, with the
    * EXHAUSTIVE option, test all possible combinations.
    *//*transforms applied*//*transforms*//* Second test: write the original PNG data out to a new file (to test the
    * write side) then read the result back in and make sure that it hasn't
    * changed.
    *//* no point testing more *//* The result should be identical to the original_rows *//* First test: if there are options that should be ignored for this file
    * verify that they really are ignored.
    *//* First cache the file and update the display original file
    * information for the new file.
    *//* don't skip *//* skip *//* Log this to stdout if logging is on, otherwise just do an information
       * display_log.
       *//* Helper to test for a bad combo and log it if it is skipped *//* WRITE_PNG *//* Clean it on the way out - if control returns to the caller then the
    * written_file contains the required data.
    *//*params*//* Certain transforms require the png_info to be zapped to allow the
    * transform to work correctly.
    *//* Remove the user limits, if any *//*flush*//* safety *//* avoid the need to rewrite every time *//* Write the data into the buffer, adding buffers as required *//* Generic write function used both from the write callback provided to
    * libpng and from the generic read code.
    *//* compare succeeded *//* !sBIT *//* for y *//* The mask can be combined with sig_bits[0] *//* Convert bpp to bytes; this gives '1' for low-bit depth grayscale,
          * where there are multiple pixels per byte.
          *//* Value is 1, 2, 3 or 4 *//* Replicate twice *//* Value is 1 or 2 *//* Replicate 4 times *//* Value is 1 *//* allowed, but dumb *//* One byte per component *//* big-endian *//* Two bytes per component, big-endian *//* sanity check; this is a grayscale PNG; something is wrong in the
             * code above.
             *//*!palette*//* libpng should catch this; if not there is a security issue
                * because an app (like this one) may overflow an array. In fact
                * libpng doesn't catch this at present.
                *//*NOTREACHED*//* components are up to 8 bytes in size *//* bits-per-pixel then bytes-per-pixel *//* don't keep reporting failed rows on 'continue' *//* Find the first error *//* Need the stray bits at the end, this depends only on the low bits
          * of the image width; overflow does not matter.  If the width is an
          * exact multiple of 8 bits this gives a mask of 0, not 0xff.
          *//* mask (if not zero) for the final byte *//* The rows should be the same too, unless the applied transforms includes
    * the shift transform, in which case low bits may have been lost.
    *//* NOTE: on 64-bit systems this may trash the top bits of rowbytes,
    * which could lead to weird error messages.
    *//* rowbytes should be the same *//* All the chunks from the original PNG should be preserved in the output PNG
    * because the PNG format has not been changed.
    *//* 'e' remains set to the name of the last thing changed: *//* If write interlace has been disabled, the PNG file is still
       * written correctly, but as a regular (not-interlaced) PNG.
       *//* The IHDR should be identical: *//* Compare the png_info from read_ip with original_info *//* excluding write-only transforms *//* Some transforms appear multiple times in the table; the 'active' status
       * is the logical OR of these and the inactive status must be adjusted to
       * take this into account.
       *//* 'active' transforms are discovered based on the original image format;
    * running one active transform can activate others.  At present the code
    * does not attempt to determine the closure.
    *//* set by png_read_png *//* Move the result to the 'original' fields *//*no transform*//* Now perform the initial read with a 0 transform. *//* called once after the first read to update all the info, original_pp and
    * original_ip must have been filled in.
    *//* crazy debugging *//* Set the IO handling *//* The png_read_png API requires us to make the info struct, but it does the
    * call to png_read_info.
    *//* else this is a verify and do not overwrite info *//* This cleans out any previous read and sets operation and transforms to
    * empty.
    *//* And do a sanity check (the EOF case is caught above) *//* Avoid update outside the loop *//* Move to the next buffer: *//* Does the initial cache of the file. *//* error handler callbacks for libpng *//* Errors cause this routine to exit to the fail code *//* else do not output any message *//* anything unexpected is an internal error: *//* 'level' is as above, fmt is a stdio style format string.  This routine
    * does not return if level is above LIBPNG_WARNING
    *//* Required to quiet GNUC warnings when the compiler sees a stdarg function
    * that calls one of the stdio v APIs.
    *//* error handling *//* prevents a crash *//* The display pointer is always stored in the png_struct error pointer *//* Release any memory held in the display. *//* reset for next time *//* leave the filename for error detection *//* default to !verbose, !quiet *//* Call this only once right at the start to initialize the control
    * structure, the (struct buffer) lists are maintained across calls - the
    * memory is not freed.
    *//* Data read from the original file *//* where the file gets written *//* Used to write a new image (the original info_ptr is used) *//* Used on a read, both the original read and when validating a written
    * image.
    *//* transforms that should do nothing *//* transforms that do something on read *//* Derived information for the original image. *//* Original IHDR information *//* Original chunks valid *//* from the original read *//* of the original rows: *//* set by the original read *//* used on the original read *//* A mask of errors seen *//* See display_log below *//* Transform used in operation *//* Operation being performed *//* The name of the original file *//* Set before longjmp *//* Where to go to on error *//* Result masks apply to the result bits in the 'results' field below; these
 * bits are simple 1U<<error_level.  A pass requires either nothing worse than
 * warnings (--relaxes) or nothing worse than information (--strict)
 *//* List combos by name *//* Attempt to deduce bad combos *//* Log skipped bugs *//* Skip over known bugs *//* Continue on APP_FAIL errors *//* Log pass/fail to stdout *//* Fail on warnings as well as errors *//* Test all combinations of active options *//* where the level is in 'options' *//* such as file-not-found *//* no normal messages *//* such as out-of-memory in a callback *//* erroneous behavior in libpng *//* this and higher cause a longjmp *//* continuable error - no need to longjmp *//* just errors *//* switches on warnings *//* switches on all messages *//* This structure is used to control the test of a single file. *//* Some kind of funky error; errno should be non-zero *//* no error *//* fread failed - probably end of file *//*size*//* Load a buffer from a file; does the equivalent of buffer_start_write.  On a
 * read error returns an errno value, else returns 0.
 *//* Used from libpng callbacks to get the current buffer *//* required by ANSI-C *//* required by POSIX 1003.1 *//* Call this only once for a given buffer *//* the very first buffer *//* count of bytes read from current *//* current buffer being read *//* bytes in the last buffer *//* last buffer in use *//* the actual buffer *//* next buffer in list *//* FILE DATA HANDLING
 *    The original file is cached in memory.  During write the output file is
 *    written to memory.
 *
 *    In both cases the file data is held in a linked list of buffers - not all
 *    of these are in use at any time.
 *//* Reversible transforms are those which are supported on both read and
    * write.
    *//* Validate the above table - this just builds the above values *//* Variables calculated by validate_T below and used to record all the supported
 * transforms.  Need (unsigned int) here because of the places where these
 * values are used (unsigned compares in the 'exhaustive' iterator.)
 *//* first set bit *//* The name, if 't' has multiple bits set the name of the lowest set bit is
    * returned.
    *//* combo is ok *//* lowest set bit *//* non-zero if more than one set bit *//*antidote*//* problem, antidote *//* Some combinations of options that should be reversible are not; these cases
 * are bugs.
 *//*!tested*//*name*//* scales 16-bit components to 8-bits. *//* side effect of EXPAND_16 - expands the tRNS chunk in an RGB or G 16-bit
       * image.
       *//* expands images to 16-bits per component, as a side effect expands
       * palette images to RGB and expands the tRNS chunk if present, so it can
       * modify 16-bit per component images as well:
       *//* The 'palette' side effect mentioned above; a bit bogus but this is the
       * way the libpng code works.
       *//* expands grayscale images to RGB, also causes the palette part of
       * 'EXPAND' to happen.  Low bit depth grayscale images are expanded to
       * 8-bits per component and no attempt is made to convert the image to a
       * palette image.  While this transform is partially reversible
       * png_write_png does not currently support this.
       *//* on write strips a trailing filler channel *//* on write skips a leading filler channel; testing requires data with a
       * filler channel so this is produced from RGBA or GA images by removing
       * the 'alpha' flag from the color type in place.
       *//* 'A' for a filler! *//* converts an alpha channel from 0..1 to 1..0 *//* byte-swaps 16-bit component values *//* swaps the alpha channel of RGBA or GA pixels to the front - ARGB or
       * AG, on write reverses the process.
       *//* reverses the rgb component values of true-color pixels *//* reduces component values to the original range based on the sBIT chunk,
       * this is only partially reversible - the low bits are lost and cannot be
       * recovered on write.  In fact write code replicates the bits to generate
       * new low-order bits.
       *//* converts gray-scale components to 1..0 from 0..1 *//* expands the tRNS chunk in files without alpha *//* expands grayscale PNG files to RGB, or RGBA *//* expands PLTE PNG files to RGB (no tRNS) or RGBA (tRNS) *
       * Note that the 'EXPAND' transform does lots of different things: *//* reverses the order of low-bit-depth components packed into a byte *//* unpacks low-bit-depth components into 1 byte per component on read,
       * reverses this on write.
       *//* removes the alpha channel if present *//* drops the bottom 8 bits when bit depth is 16 *//* List ALL the PNG_TRANSFORM_ macros here.  Check for support using the READ
    * macros; even if the transform is supported on write it cannot be tested
    * without the read support.
    *//* the transform was tested somewhere *//* i.e. true-color depths *//* absent = gray, no alpha *//* If a transform is valid on both read and write this implies that if the
 * transform is applied to read it must also be applied on write to produce
 * meaningful data.  This is because these transforms when performed on read
 * produce data with a memory format that does not correspond to a PNG format.
 *
 * Most of these transforms are invertible; after applying the transform on
 * write the result is the original PNG data that would have would have been
 * read if no transform were applied.
 *
 * The exception is _SHIFT, which destroys the low order bits marked as not
 * significant in a PNG with the sBIT chunk.
 *
 * The following table lists, for each transform, the conditions under which it
 * is expected to do anything.  Conditions are defined as follows:
 *
 * 1) Color mask bits required - simply a mask to AND with color_type; one of
 *    these must be present for the transform to fire, except that 0 means
 *    'always'.
 * 2) Color mask bits which must be absent - another mask - none of these must
 *    be present.
 * 3) Bit depths - a mask of component bit depths for the transform to fire.
 * 4) 'read' - the transform works in png_read_png.
 * 5) 'write' - the transform works in png_write_png.
 * 6) PNG_INFO_chunk; a mask of the chunks that must be present for the
 *    transform to fire.  All must be present - the requirement is that
 *    png_get_valid() & mask == mask, so if mask is 0 there is no requirement.
 *
 * The condition refers to the original image state - if multiple transforms are
 * used together it is possible to cause a transform that wouldn't fire on the
 * original image to fire.
 *//* INFO_IMAGE *//* SEQUENTIAL_READ *//* READ_PNG and WRITE_PNG were not defined, so: *//* 1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:
 *//* because png.h did *not* include this *//* Define the following to use this test against your installed libpng, rather
 * than the one being built here:
 *//* pngimage.c
 *
 * Copyright (c) 2021-2025 Cosmin Truta
 * Copyright (c) 2015,2016 John Cunningham Bowler
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * Test the png_read_png and png_write_png interfaces.  Given a PNG file load it
 * using png_read_png and then write with png_write_png.  Test all possible
 * transforms.
 */D:/PracticeInCodeQL/libpng/contrib/tools/sRGB.hYfromRGB0.21260000000000001120.21260.71519999999999994690.71520.072200000000000000290.0722linear_from_sRGB0.040449999999999999840.0404512.9199999999999999312.920.055000000000000000280.0551.0549999999999999381.0552.3999999999999999112.4sRGB_from_linear0.0031307999999999999890.00313081.00.41666666666666668521/2.4/* Use the sRGB (rounded) coefficients for Rlinear, Glinear, Blinear to get
    * the CIE Y value (also linear).
    *//* sRGB.h
 *
 * COPYRIGHT: Written by John Cunningham Bowler, 2013.
 * To the extent possible under law, the author has waived all copyright and
 * related or neighboring rights to this work.  This work is published from:
 * United States.
 *
 * Utility file; not actually a header, this contains definitions of sRGB
 * calculation functions for inclusion in those test programs that need them.
 *
 * All routines take and return a floating point value in the range
 * 0 to 1.0, doing a calculation according to the sRGB specification
 * (in fact the source of the numbers is the wikipedia article at
 * https://en.wikipedia.org/wiki/SRGB).
 */D:/PracticeInCodeQL/libpng/contrib/toolsgslD:/PracticeInCodeQL/libpng/contrib/libtests/pngstest-errors.hpng_uint_16[4]unsigned short[4]png_uint_16[8][4]unsigned short[8][4]png_uint_16[8][8][4]unsigned short[8][8][4]gpc_error_to_colormappng_uint_16[4][4]unsigned short[4][4]png_uint_16[16][4][4]unsigned short[16][4][4]gpc_error_via_linearpng_uint_16[16][4]unsigned short[16][4]png_uint_16[16][16][4]unsigned short[16][16][4]gpc_error/* END MACHINE GENERATED *//* input: linear-rgb+alpha *//* input: linear-rgb *//* input: linear-gray+alpha *//* input: linear-gray *//* input: sRGB-rgb+alpha *//* input: sRGB-rgb *//* input: sRGB-gray+alpha *//* input: sRGB-gray *//*o*//*i*//* input: color-mapped-linear-rgb+alpha *//* input: color-mapped-linear-rgb *//* input: color-mapped-linear-gray+alpha *//* input: color-mapped-linear-gray *//* input: color-mapped-sRGB-rgb+alpha *//* input: color-mapped-sRGB-rgb *//* input: color-mapped-sRGB-gray+alpha *//* input: color-mapped-sRGB-gray *//*out*//*a*//*in*//* contrib/libtests/pngstest-errors.h
 *
 * BUILT USING: libpng version 1.6.19beta03 - September 25, 2015
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * THIS IS A MACHINE GENERATED FILE: do not edit it directly!
 * Instead run:
 *
 *    pngstest --accumulate
 *
 * on as many PNG files as possible; at least PNGSuite and
 * contrib/libtests/testpngs.
 */C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/ctype.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/corecrt_wctype.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/math.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/corecrt_math.h2830D:/PracticeInCodeQL/libpng/contrib/libtests/pngstest.c"pngstest-errors.h""../tools/sRGB.h"<math.h><ctype.h><stddef.h>optsFAST_WRITE132formatstouchlog_passredundantstride_extraretvalcformat_list *arg--fresh"--fresh"png_uint_16(*)[16][4]unsigned short(*)[16][4]sizeof gpc_errorpng_uint_16(*)[4][4]unsigned short(*)[4][4]sizeof gpc_error_via_linear--file"--file"USE_FILE--memory"--memory"~USE_FILE4294967294--stdio"--stdio"USE_STDIO--name"--name"~USE_STDIO4294967293-9~VERBOSE4294967287--preserve"--preserve"KEEP_TMPFILES--nopreserve"--nopreserve"~KEEP_TMPFILES--keep-going"--keep-going"KEEP_GOING--slow"--slow"~FAST_WRITE--accumulate"--accumulate"ACCUMULATE--redundant"--redundant"~KEEP_GOING--nostrict"--nostrict"4294967291--sRGB-16bit"--sRGB-16bit"sRGB_16BIT--linear-16bit"--linear-16bit"~sRGB_16BIT--noreseed"--noreseed"NO_RESEED--fault-gbg-warning"--fault-gbg-warning"GBG_ERROR--tmpfile"--tmpfile"sizeof tmpf%s: %s is too long for a temp file prefix
"%s: %s is too long for a temp file prefix\n"sizeof (tmpf)sizeof (tmpf)-1%s: %s requires a temporary file prefix
"%s: %s requires a temporary file prefix\n"char[41]--touch"--touch"%s: %s requires a file name argument
"%s: %s requires a file name argument\n"char[38]FORMAT_COUNT%s: unknown option: %s
"%s: unknown option: %s\n"char[24]char[4096]termichsizeof bufferch4095%s...%s: file name too long
"%s...%s: file name too long\n"40644096-32(4096-32)in/* contrib/libtests/pngstest-errors.h
"/* contrib/libtests/pngstest-errors.h\n" *
" *\n" * BUILT USING: libpng version 1.8.0.git
" * BUILT USING:" PNG_HEADER_VERSION_STRING * This code is released under the libpng license.
" * This code is released under the libpng license.\n"char[52] * For conditions of distribution and use, see the disclaimer
" * For conditions of distribution and use, see the disclaimer\n"char[63] * and license in png.h
" * and license in png.h\n"char[25] * THIS IS A MACHINE GENERATED FILE: do not edit it directly!
" * THIS IS A MACHINE GENERATED FILE: do not edit it directly!\n" * Instead run:
" * Instead run:\n" *    pngstest --accumulate
" *    pngstest --accumulate\n" * on as many PNG files as possible; at least PNGSuite and
" * on as many PNG files as possible; at least PNGSuite and\n"char[60] * contrib/libtests/testpngs.
" * contrib/libtests/testpngs.\n" */
" */\n"static png_uint_16 gpc_error[16/*in*/][16/*out*/][4/*a*/] =
"static png_uint_16 gpc_error[16/*in*/][16/*out*/][4/*a*/] =\n"char[61]{
"{\n" { /* input: %s */
 " { /* input: %s */\n "const char *const[64]char *[64]const char *const * {" {" %d" %d"png_uint_16(*)[4]unsigned short(*)[4]44',' }" }"
 "\n "
 }"\n }"};
"};\n"static png_uint_16 gpc_error_via_linear[16][4/*out*/][4] =
"static png_uint_16 gpc_error_via_linear[16][4/*out*/][4] =\n"static png_uint_16 gpc_error_to_colormap[8/*i*/][8/*o*/][4] =
"static png_uint_16 gpc_error_to_colormap[8/*i*/][8/*o*/][4] =\n"png_uint_16(*)[8][4]unsigned short(*)[8][4]/* END MACHINE GENERATED */
"/* END MACHINE GENERATED */\n"fsuccesswt"wt"PNG simple API tests succeeded
"PNG simple API tests succeeded\n"%s: write failed
"%s: write failed\n"%s: open failed
"%s: open failed\n"resultImage *PASS:"PASS:"FAIL:"FAIL:" %s
" %s\n"testimagecopycounteroutput2*FORMAT_COUNTwrite_one_fileimage->imageimage->buffer+16(png_int_32)image->strideimage->colormapPNG_IMAGE_COMPRESSED_SIZE_MAX(image->image)(((png_alloc_size_t)((((((image->image).format)&0x08U)?1:(((((image->image).format) & 0x04U) >> 2)+1))*(image->image).height*((((((image->image).format)&0x08U)?1:((((image->image).format)&(0x02U|0x01U))+1)) * (image->image).width)))+(image->image).height))+((((png_alloc_size_t)((((((image->image).format)&0x08U)?1:(((((image->image).format) & 0x04U) >> 2)+1))*(image->image).height*((((((image->image).format)&0x08U)?1:((((image->image).format)&(0x02U|0x01U))+1)) * (image->image).width)))+(image->image).height))+7U)>>3)+((((png_alloc_size_t)((((((image->image).format)&0x08U)?1:(((((image->image).format) & 0x04U) >> 2)+1))*(image->image).height*((((((image->image).format)&0x08U)?1:((((image->image).format)&(0x02U|0x01U))+1)) * (image->image).width)))+(image->image).height))+63U)>>6)+11U)(png_alloc_size_t)PNG_IMAGE_DATA_SIZE(image->image)(png_alloc_size_t)((((((image->image).format)&0x08U)?1:(((((image->image).format) & 0x04U) >> 2)+1))*(image->image).height*((((((image->image).format)&0x08U)?1:((((image->image).format)&(0x02U|0x01U))+1)) * (image->image).width)))+(image->image).height)PNG_IMAGE_ROW_STRIDE(image->image)(((((image->image).format)&0x08U)?1:((((image->image).format)&(0x02U|0x01U))+1)) * (image->image).width)(image->image).formatPNG_IMAGE_SAMPLE_CHANNELSPNG_IMAGE_SAMPLE_COMPONENT_SIZEfpfpng_uint_16[1024]unsigned short[1024]256*4"tmpfile": flush: ": flush: ": write failed": write failed": open: ": open: "%s%u.png"%s%u.png"3363"memory": PNG_IMAGE_SIZE_MAX wrong": PNG_IMAGE_SIZE_MAX wrong"size_t *: memory size wrong": memory size wrong": out of memory": out of memory": get size:": get size:"2147483648FORMAT_NO_CHANGEoriginal_format~PNG_FORMAT_FLAG_LINEARBASE_FORMATS: format changed on read: ": format changed on read: ": read of new file failed": read of new file failed"read_one_filemalloc((size_t)cb)cb(size_t)0(size_t)~(size_t)0: read failed: ": read failed: ": out of memory: ": out of memory: ": file too big for this architecture: ": file too big for this architecture: ": zero length: ": zero length: ": tell failed: ": tell failed: ": seek failed: ": seek failed: ": open failed: ": open failed: "read_file104sizeof image->imagememory init: "memory init: "stdio init: "stdio init: "file init: "file init: "image_format%s %lu x %lu %s -> %s"%s %lu x %lu %s -> %s"FORMAT_MASKno change"no change" background(%d,%d,%d)
" background(%d,%d,%d)\n"
"\n"4294967288~BASE_FORMATS: image read failed": image read failed"compare_two_imagesstrideastridebrowaavia_linearrowbformataformatba_sampleb_samplealpha_addedalpha_removedbchannelsint[4]btoa: width x height changed: ": width x height changed: "Transform *const Imageconst Image *ppappbmatchpng_byte[256]unsigned char[256]in_useamaxbmaxsizeof in_usebvalavala_cmapb_cmap 1pindex%lu[%lu]"%lu[%lu]": bad pixel index: ": bad pixel index: "BYTE_CHARS2*BYTE_CHARS3+2*BYTE_CHARS%d[%u]"%d[%u]"alpha_changedpng_byte[4]unsigned char[4]alocblocpsapsbpuapub65535component_loccmppixelmaxerrerrmsgpixel_inpixel_calcpixel_outPixel *const Pixelconst Pixel *const Backgroundconst Background *err_a"alpha"err_rerr_gerr_blimitopaque component"opaque component"alpha component"alpha component"transparent component (background)"transparent component (background)"const Transformconst Transform *logpixelin_formatout_formatback_format~PNG_FORMAT_FLAG_ALPHApixel_locchar[100]background_infopalette: %lu"palette: %lu"%lu,%lu"%lu,%lu" (via linear)" (via linear)"backpixel_back on background %s" on background %s"char[512]error_buffer(%s) %s error%s:
 %s%s ->
       %s
  not: %s.
Use --preserve and examine: "(%s) %s error%s:\n %s%s ->\n       %s\n  not: %s.\n"
         "Use --preserve and examine: "char[76](%s) %s error%s:
 %s%s ->
       %s
  not: %s.
 The error happened when reading the original file with this format."(%s) %s error%s:\n %s%s ->\n       %s\n  not: %s.\n"
         " The error happened when reading the original file with this format."char[116]print_pixel(PNG_FORMAT_FLAG_ALPHA|PNG_FORMAT_FLAG_COLOR)%s(%d)"%s(%d)"%s(%d,%d)"%s(%d,%d)"%s(%d,%d,%d)"%s(%d,%d,%d)"%s(%d,%d,%d,%d)"%s(%d,%d,%d,%d)"invalid-format"invalid-format"transform_from_formatsin_baseout_basesizeof *result..(*)(..))(..)(PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLORMAP)internal transform via linear error 0x%x->0x%x
"internal transform via linear error 0x%x->0x%x\n"char[48]..(*const)(..)..(*const[8])(..)..(*[8])(..)..(*const[8][8])(..)..(*[8][8])(..)..(*const(*)[8])(..)..(*(*)[8])(..)..(*const *)(..)..(**)(..)Background *0.0BUFFER_INIT825718761double[256]1.00000000000000002e+301E30gpc_g16qgpc_g16gpc_Agpc_cb1665535.065535.a1loccalcreasonstringpixelin_imageout_imagegpc_gb16gpc_sCp257.0257.gpc_sGpgpc_sGgpc_b16cgpc_b16ggpc_unpcgpc_unpggpc_sRGBgpc_Lingpc_gprqgpc_gpregpc_glingpc_preqgpc_pregpc_lingpc_g8b255.0255.gpc_g8gpc_bckcgpc_bckggpc_noopget_pixelgp_abgr16pbgp_argb16gp_bgra16gp_rgba16gp_bgr16gp_rgb16gp_ag16gp_ga16gp_g16gp_abgr8gp_argb8gp_bgra8pgp_rgba8gp_bgr8gp_rgb8gp_ag8gp_ga8gp_g8checkopaque: opaque not NULL": opaque not NULL"libpng does not support gamma+background+rgb_to_gray"libpng does not support gamma+background+rgb_to_gray" --fault-gbg-warning" --fault-gbg-warning" --strict" --strict"logcloselogerror%s%s%s: %s
"%s%s%s: %s\n"%s%s%s
"%s%s%s\n"%s: image opaque pointer non-NULL on error
"%s: image opaque pointer non-NULL on error\n"checkbuffer%s: overwrite at start of image buffer
"%s: overwrite at start of image buffer\n"%s: overwrite at end of image buffer
"%s: overwrite at end of image buffer\n"check16 16allocbufferimage->stridemalloc(size+32)simpletest: out of memory allocating %lu(+32) byte buffer
"simpletest: out of memory allocating %lu(+32) byte buffer\n"initimagefreeimagefreebufferresetimagenewimage2264sizeof *imageformat_defaultFORMAT_SET_COUNTpng_uint_32[2]unsigned int[2](png_uint_32)0~(png_uint_32)0format_isset(png_uint_32)1((png_uint_32)1)format_setformat_is_initialformat_initformatofeppngstest: format name '%s' invalid
"pngstest: format name '%s' invalid\n"print_opts --file" --file" --stdio" --stdio" --nostrict" --nostrict" --verbose" --verbose" --preserve" --preserve" --keep-going" --keep-going" --accumulate" --accumulate" --slow" --slow" --sRGB-16bit" --sRGB-16bit" --noreseed" --noreseed"YfromRGBintilinear_g22ilinearailinearisRGBsRGBinit_sRGB_to_d0.4545500000000000096.454552.1999780002199975651/.45455u16du8dclosestinteger0.5.5random_colorsizeof *colorreseed3054198960x12345678U1622543190x9abcdefUmake_random_bytesu0u1pvbytesu20-8(20-8)32-7(32-7)TransformBackgroundPixelImageformat_listfrom_linearout_gpin_gpoutput_8bitaccumulateis_palettein_opaquedbdgdribigirtmpfile_nameallocsizebufsizestrideinput_memory_sizeinput_memoryinput_filebitsgpc_fn_colormappedgpc_fnformat_namessRGB-gray"sRGB-gray"sRGB-gray+alpha"sRGB-gray+alpha"sRGB-rgb"sRGB-rgb"sRGB-rgb+alpha"sRGB-rgb+alpha"linear-gray"linear-gray"linear-gray+alpha"linear-gray+alpha"linear-rgb"linear-rgb"linear-rgb+alpha"linear-rgb+alpha"color-mapped-sRGB-gray"color-mapped-sRGB-gray"color-mapped-sRGB-gray+alpha"color-mapped-sRGB-gray+alpha"color-mapped-sRGB-rgb"color-mapped-sRGB-rgb"color-mapped-sRGB-rgb+alpha"color-mapped-sRGB-rgb+alpha"color-mapped-linear-gray"color-mapped-linear-gray"color-mapped-linear-gray+alpha"color-mapped-linear-gray+alpha"color-mapped-linear-rgb"color-mapped-linear-rgb"color-mapped-linear-rgb+alpha"color-mapped-linear-rgb+alpha"sRGB-bgr"sRGB-bgr"sRGB-bgr+alpha"sRGB-bgr+alpha"linear-bgr"linear-bgr"linear-bgr+alpha"linear-bgr+alpha"color-mapped-sRGB-bgr"color-mapped-sRGB-bgr"color-mapped-sRGB-bgr+alpha"color-mapped-sRGB-bgr+alpha"color-mapped-linear-bgr"color-mapped-linear-bgr"color-mapped-linear-bgr+alpha"color-mapped-linear-bgr+alpha"alpha+sRGB-gray"alpha+sRGB-gray"alpha+sRGB-rgb"alpha+sRGB-rgb"alpha+linear-gray"alpha+linear-gray"alpha+linear-rgb"alpha+linear-rgb"color-mapped-alpha+sRGB-gray"color-mapped-alpha+sRGB-gray"color-mapped-alpha+sRGB-rgb"color-mapped-alpha+sRGB-rgb"color-mapped-alpha+linear-gray"color-mapped-alpha+linear-gray"color-mapped-alpha+linear-rgb"color-mapped-alpha+linear-rgb"alpha+sRGB-bgr"alpha+sRGB-bgr"alpha+linear-bgr"alpha+linear-bgr"color-mapped-alpha+sRGB-bgr"color-mapped-alpha+sRGB-bgr"color-mapped-alpha+linear-bgr"color-mapped-alpha+linear-bgr"g22_to_dsRGB_to_dcolor_seedtmpfTMP"TMP"(PNG_FORMAT_FLAG_ALPHA|PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_LINEAR)(FORMAT_COUNT / 32)0x3f0x80000000aligncastconst(type,value)((const void*)(value))voidcast(type,value)(value)ALLOW_UNUSED_GPCMALLOC_CHECK__ISOC90_SOURCEdefined(PNG_FORMAT_AFIRST_SUPPORTED) && defined(PNG_FORMAT_BGR_SUPPORTED)PNG_FORMAT_FLAG_ALPHA == 1 && PNG_FORMAT_FLAG_COLOR == 2 && PNG_FORMAT_FLAG_LINEAR == 4PNG_FORMAT_FLAG_COLORMAP == 8__COVERITY__PNG_LIBPNG_VER == 10700/* PNG_SIMPLIFIED_READ_SUPPORTED *//* So the test is skipped: *//* !PNG_SIMPLIFIED_READ_SUPPORTED *//* so that the increment below sets it to 0 again *//* Don't allow '\0' in file names, and terminate with '\n' or,
                * for -0, just '\0' (use -print0 to find to make this work!)
                *//* Loop reading files, use a static buffer to simplify this and just
             * stop if the name gets to long.
             *//* Safe: checked above *//* skipped: no support *//* initialize random number seeds *//* This error should not exist in 1.7 or later: *//* stdout may not be line-buffered if it is piped to a file, so: *//* Ensure that stderr is flushed into any log file *//* ensure that the random numbers don't depend on file order *//* PNG_SIMPLIFIED_WRITE_SUPPORTED *//*via_linear*//* This may involve a conversion via linear; in the ideal world
                * this would round-trip correctly, but libpng 1.5.7 is not the
                * ideal world so allow a drift (error_via_linear).
                *
                * 'image' has an alpha channel but 'output' does not then there
                * will a strip-alpha-channel operation (because 'output' is
                * linear), handle this by composing on black when doing the
                * comparison.
                *//*convert to 8bit*//* 'output' is linear, convert to the corresponding sRGB format.
                *//* Validate against the original too; the background is needed here
             * as well so that compare_two_images knows what color was used.
             *//* Write the *copy* just made to a new file to make sure the write
             * side works ok.  Check the conversion to sRGB if the copy is
             * linear.
             *//*via linear*//* Make sure the file just read matches the original file. *//* in case read_file needs to change it *//* else just use NULL for background *//* Otherwise an alpha channel is not being eliminated, just leave
             * background NULL and skip the (counter & 1) NULL test.
             *//* BUT if the output is to a color-mapped 8-bit format then
                * the background must always be a color, so increment 'counter'
                * to skip the NULL test.
                *//* Alpha/transparency will be removed, the background is
                * relevant: make it a color the first time
                *//* If there is a format change that removes the alpha channel then
          * the background is relevant.  If the output is 8-bit color-mapped
          * then a background color *must* be provided, otherwise there are
          * two tests to do - one with a color, the other with NULL.  The
          * NULL test happens second.
          *//* Use the low bit of 'counter' to indicate whether or not to do alpha
       * removal with a background color or by composting onto the image; this
       * step gets skipped if it isn't relevant
       *//* Copy the original data, stealing it from 'image' *//* 'output' has an initialized temporary image, read this back in and compare
    * this against the original: there should be no change since the original
    * format was written unmodified unless 'convert_to_8bit' was specified.
    * However, if the original image was color-mapped, a simple read will zap
    * the linear, color and maybe alpha flags, this will cause spurious failures
    * under some circumstances.
    *//* This is also non-fatal but it safes safer to error out anyway:
                *//* This is non-fatal but ignoring it was causing serious problems in
          * the macro to be ignored:
          *//* use memory *//* Afterwards, or freeimage will delete it! *//* Hide the filename immediately and ensure that the file does
         * not exist after the program ends
         *//* Experimental. Coverity says tmpfile() is insecure because it
       * generates predictable names.
       *
       * It is possible to satisfy Coverity by using mkstemp(); however,
       * any platform supporting mkstemp() undoubtedly has a secure tmpfile()
       * implementation as well, and doesn't need the fix.  Note that
       * the fix won't work on platforms that don't support mkstemp().
       *
       * https://www.securecoding.cert.org/confluence/display/c/
       * FIO21-C.+Do+not+create+temporary+files+in+shared+directories
       * says that most historic implementations of tmpfile() provide
       * only a limited number of possible temporary file names
       * (usually 26) before file names are recycled. That article also
       * provides a secure solution that unfortunately depends upon mkstemp().
       *//* cb is the length of the file as a (long) and
                      * this is greater than the maximum amount of
                      * memory that can be requested from malloc.
                      *//* memory *//* memory or stdio. *//* Reads from a filename, which must be in image->file_name, but uses
 * image->opts to choose the method.  The file is always read in its native
 * format (the one the simplified API suggests).
 *//* 'NO_CHANGE' combined with the color-map flag forces the base format
       * flags to be set on read to ensure that the original representation is
       * not lost in the pass through a colormap format.
       *//* Print both original and output formats. *//* Have an initialized image with all the data we need plus, maybe, an
    * allocated file (myfile) or buffer (mybuffer) that need to be freed.
    *//* This must be set after the begin_read call: *//* Read the file; how the read gets done depends on which of input_file and
 * input_memory have been set.
 *//* If requested, copy the error values back from the Transform. *//* error case *//* If we get to here the fast match failed; do the slow match for this
          * pixel.
          *//* impossible *//* x loop *//* FALLTHROUGH *//* 16-bit checks *//* Check each 'b' channel against either the corresponding 'a'
             * channel or the opaque alpha value, as appropriate.  If
             * alpha_removed value is set (not 4) then also do this only if the
             * 'a' alpha channel (alpha_removed) is opaque; only relevant for
             * the 8-bit case.
             *//* Do the fast test if possible. *//* 4 == not present *//* Direct compare is not possible, cancel out all the corresponding local
       * variables.
       *//* location of alpha channel in image a *//* Won't match an image b channel *//* location of alpha channel in image b *//* may be '4' for alpha *//* Hence the btoa array. *//* The following are used only if the formats match, except that
          * 'bchannels' is a flag for matching formats.  btoa[x] says, for each
          * channel in b, where to find the corresponding value in a, for the
          * bchannels.  achannels may be different for a gray to rgb transform
          * (a will be 1 or 2, b will be 3 or 4 channels.)
          *//* The channels may have been moved between input and output, this finds
       * out how, recording the result in the btoa array, which says where in
       * 'a' to find each channel of 'b'.  If alpha was added then btoa[alpha]
       * ends up as 4 (and is not used.)
       *//* Was an alpha channel added? *//* Was an alpha channel removed?  (The third test.)  If so the direct
       * comparison is only possible if the input alpha is opaque.
       *//* Was an alpha channel changed? *//* We can directly compare pixel values without the need to use the read
    * or transform support (i.e. a memory compare) if:
    *
    * 1) The bit depth has not changed.
    * 2) RGB to grayscale has not been done (the reverse is ok; we just compare
    *    the three RGB values to the original grayscale.)
    * 3) An alpha channel has not been removed from an 8-bit format, or the
    *    8-bit alpha value of the pixel was 255 (opaque).
    *
    * If an alpha channel has been *added* then it must have the relevant opaque
    * value (255 or 65535).
    *
    * The fist two the tests (in the order given above) (using the boolean
    * equivalence !a && !b == !(a || b))
    *//*SAFE*//* Check the original image first,
          * TODO: deal with input images with bad pixel values?
          *//* 2^8: real maximum value *//* 2^32: GCC sprintf warning *//* else the image buffers don't match pixel-wise so compare sample values
       * instead, but first validate that the pixel indexes are in range (but
       * only if not accumulating, when the error is ignored.)
       *//* force a continue *//* All the mismatches are logged here; there can only be 256! *//* The colormap entries should be valid, but because libpng doesn't
             * do any checking at present the original image may contain invalid
             * pixel values.  These cause an error here (at present) unless
             * accumulating errors in which case the program just ignores them.
             *//* This is used in logpixel to get the error message correct. *//* match by default *//* Do the color-maps match, entry by entry?  Only check the 'in_use'
          * entries.  An error here should be logged as a color-map error.
          *//* If the buffers match then the colormaps must too. *//* Do this the slow way to accumulate the 'in_use' flags, don't break out
       * of the loop until the end; this validates the color-mapped data to
       * ensure all pixels are valid color-map indexes.
       *//* Only check colormap entries that actually exist; *//* First shortcut the two colormap case by comparing the image data; if it
    * matches then we expect the colormaps to match, although this is not
    * absolutely necessary for an image match.  If the colormaps fail to match
    * then there is a problem in libpng.
    *//* Find the first row and inter-row space. *//* Set up the background and the transform *//* This should never happen: *//* Compare two images, the original 'a', which was written out then read back in
 * to * give image 'b'.  The formats may have been changed.
 *//* not present *//* Given a format return the number of channels and the location of
    * each channel.
    *
    * The mask 'loc' contains the component offset of the channels in the
    * following order.  Note that if 'format' is grayscale the entries 1-3 must
    * all contain the location of the gray channel.
    *
    * 0: alpha
    * 1: red or gray
    * 2: green or gray
    * 3: blue or gray
    *//* Failure to match and not accumulating, so the error must be logged. *//* to cause the caller to keep going *//* Handle a component mis-match; log it, just return an error code, or
       * accumulate it.
       *//* within the error limits *//* transparent *//* partially transparent *//* opaque *//* Mismatch on a component, check the input alpha *//* exact match *//* else just signal an alpha error *//* Now if *either* of the output alphas are 0 but alpha is within tolerance
    * eliminate the 8-bit component comparison.
    *//* If accumulating check the components too *//* Check for alpha errors first; an alpha error can damage the components too
    * so avoid spurious checks on components if one is found.
    *//* Eliminate the case where the output pixel is transparent and the output
    * is 8-bit - any component values are valid.  Don't check the input alpha
    * here to also skip the 16-bit small alpha cases.
    *//* Eliminate the case where the input and output values match exactly. *//*or palette index*//* not used *//* And as a result the *read* format which did any background processing
       * was itself linear, so the background color information is also
       * linear.
       *//* This is actually 14.99, but, despite the closeness to 15, 14 seems to work
    * ok in this case.
    *//*(128.5 * 255 / 65535)*//* 16-bit values less than 128.5 get rounded to 8-bit 0 and so the worst
       * case error arises with 16-bit 128.5, work out what sRGB
       * (non-associated) value generates 128.5; any value less than this is
       * going to map to 0, so the worst error is floor(value).
       *
       * Note that errors are considerably higher (more than a factor of 2)
       * because libpng uses a simple power law for sRGB data at present.
       *
       * Add .1 for arithmetic errors inside libpng.
       *//* transparent pixel *//* Indexed by 8-bit alpha *//* Compare two pixels.
 *
 * OLD error values:
static int error_to_linear = 811; * by experiment *
static int error_to_linear_grayscale = 424; * by experiment *
static int error_to_sRGB = 6; * by experiment *
static int error_to_sRGB_grayscale = 17; * libpng error by calculation +
                                            2 by experiment *
static int error_in_compose = 2; * by experiment *
static int error_in_premultiply = 1;
 *
 * The following is *just* the result of a round trip from 8-bit sRGB to linear
 * then back to 8-bit sRGB when it is done by libpng.  There are two problems:
 *
 * 1) libpng currently uses a 2.2 power law with no linear segment, this results
 * in instability in the low values and even with 16-bit precision sRGB(1) ends
 * up mapping to sRGB(0) as a result of rounding in the 16-bit representation.
 * This gives an error of 1 in the handling of value 1 only.
 *
 * 2) libpng currently uses an intermediate 8-bit linear value in gamma
 * correction of 8-bit values.  This results in many more errors, the worse of
 * which is mapping sRGB(14) to sRGB(0).
 *
 * The general 'error_via_linear' is more complex because of pre-multiplication,
 * this compounds the 8-bit errors according to the alpha value of the pixel.
 * As a result 256 values are pre-calculated for error_via_linear.
 *//* Copy the error values into the Transform: *//* Else the output is colormapped and a background color must be
          * provided; if pngstest crashes then that is a bug in this program
          * (though libpng should png_error as well.)
          *//* TODO: sometimes libpng uses the power law conversion here, how
             * to handle this?
             *//* TODO: sometimes libpng uses the power law conversion here, how
                * to handle this?
                *//* grayscale: libpng only looks at 'g' *//* sRGB output *//* The input value is 'NULL' to use the background and (otherwise) an sRGB
       * background color (to use a solid color).  The code above uses a fixed
       * byte value, BUFFER_INIT8, for buffer even for 16-bit output.  For
       * linear (16-bit) output the sRGB background color is ignored; the
       * composition is always on the background (so BUFFER_INIT8 * 257), except
       * that for the colormap (i.e. linear colormapped output) black is used.
       *//* Rule 1: background only need be supplied if alpha is to be removed *//* default: not required *//* Follow the libpng simplified API rules to work out what to pass to the gpc
    * routines as a background value, if one is not required pass NULL so that
    * this program crashes in the even of a programming error.
    *//* The caller handles the colormap->pixel value conversion, so the
       * transform function just gets a pixel value, however because libpng
       * currently contains a different implementation for mapping a colormap if
       * both input and output are colormapped we need different conversion
       * functions to deal with errors in the libpng implementation.
       *//* The input is not colormapped but the output is, the errors will
       * typically be large (only the grayscale-no-alpha case permits preserving
       * even 8-bit values.)
       *//* Check for an error in this program: *//* Remove the ordering information: *//* The loaders (which need the ordering information) *//* set by caller if required *//* Store the original images for error messages *//* Return a 'transform' as above for the given format conversion. *//* Where these are stored in the static array (for 'accumulate') *//* Three error values for transparent, partially transparent and opaque
       * input pixels (in turn).
       *//* For 'via_linear' transforms the final, from linear, step, else NULL *//* A function to perform the required transform *//* Output is 8-bit (else 16-bit) *//* Accumulate component errors (don't log) *//* Sample values come from the palette *//* Value of input alpha that is opaque *//* Precalculated values: *//* 'background' is the value passed to the gpc_ routines, it may be NULL if
    * it should not be used (*this* program has an error if it crashes as a
    * result!)
    *//* Output image *//* Input image *//* Basic pixel information: *//* flag checks *//* COLORMAP flag check *//* machine generated *//* extra check also required *//* The error arrays record the error in the same matrix; 64 entries, however
 * the different algorithms used in libpng for colormap and direct conversions
 * mean that four separate matrices are used (for each combination of
 * colormapped and direct.)
 *
 * In some cases the conversion between sRGB formats goes via a linear
 * intermediate; an sRGB to linear conversion (as above) is followed by a simple
 * linear to sRGB step with no other conversions.  This is done by a separate
 * error array from an arbitrary 'in' format to one of the four basic outputs
 * (since final output is always sRGB not colormapped).
 *
 * These arrays may be modified if the --accumulate flag is set during the run;
 * then instead of logging errors they are simply added in.
 *
 * The three entries are currently for transparent, partially transparent and
 * opaque input pixel values.  Notice that alpha should be exact in each case.
 *
 * Errors in alpha should only occur when converting from a direct format
 * to a colormapped format, when alpha is effectively smashed (so large
 * errors can occur.)  There should be no error in the '0' and 'opaque'
 * values.  The fourth entry in the array is used for the alpha error (and it
 * should always be zero for the 'via linear' case since this is never color
 * mapped.)
 *
 * Mapping to a colormap smashes the colors, it is necessary to have separate
 * values for these cases because they are much larger; it is very much
 * impossible to obtain a reasonable result, these are held in
 * gpc_error_to_colormap.
 *//*out: G-8     GA-8     RGB-8    RGBA-8    G-16     GA-16   RGB-16  RGBA-16 *//* The array is repeated for the cases where both the input and output are color
 * mapped because then different algorithms are used.
 *//* This will produce a compile time error if the FORMAT_FLAG values don't
 * match the above matrix!
 *//*   OUT:    ----- 8-bit -----    ----- 16-bit -----
 *   IN     G    GA   RGB  RGBA  G    GA   RGB  RGBA
 *  8 G     .    .    .    .     lin  lin  lin  lin
 *  8 GA    bckg .    bckc .     pre' pre  pre' pre
 *  8 RGB   g8   g8   .    .     glin glin lin  lin
 *  8 RGBA  g8b  g8   bckc .     gpr' gpre pre' pre
 * 16 G     sRGB sRGB sRGB sRGB  .    .    .    .
 * 16 GA    b16g unpg b16c unpc  A    .    A    .
 * 16 RGB   sG   sG   sRGB sRGB  g16  g16  .    .
 * 16 RGBA  gb16 sGp  cb16 sCp   g16  g16' A    .
 *
 * The matrix is held in an array indexed thus:
 *
 *   gpc_fn[out_format & BASE_FORMATS][in_format & BASE_FORMATS];
 *//* Unused functions (to hide them from GCC unused function warnings) *//* g16': as 'g16' but alpha is unchanged *//* g16:  convert linear RGB to linear grayscale (alpha := 65535) *//* A:    set alpha to 65535 *//* 16-bit to 16-bit conversions *//* cb16: composite linear onto background and convert to sRGB *//*  (order doesn't matter, the composite and grayscale operations permute) *//* gb16: composite linear onto background and convert to sRGB grayscale *//* sCp: unpremultiply RGB then convert to sRGB *//* sGp: unpremultiply RGB then convert to sRGB grayscale *//* sG: convert linear RGB to sRGB grayscale *//* b16c: composite linear onto color background and convert the result to sRGB*//* b16g: composite linear onto gray background and convert the result to sRGB *//* unpc: unpremultiply color components and convert to sRGB (scale alpha) *//* unpg: unpremultiply gray component and convert to sRGB (scale alpha) *//* sRGB: convert linear components to sRGB, alpha := 255 *//* 16-bit to 8-bit conversions *//* Gpr': as 'Gpre' but alpha := 65535 *//* Gpre: make gAMA 45455 components grayscale and linear and premultiply by
 * alpha.
 *//* Glin: make gAMA 45455 components linear, convert to grayscale, alpha := 65535
 *//* Pre': as 'Pre' but alpha := 65535 *//* Pre: make gAMA 45455 components linear and premultiply by alpha (scale alpha)
 *//* Lin: make gAMA 45455 components linear, alpha := 65535 *//* 8-bit to 16-bit conversions for gAMA 45455 encoded values *//* gpr': as 'gpre' but alpha := 65535 *//* gpre: make sRGB components grayscale and linear and premultiply by alpha *//* glin: make sRGB components linear, convert to grayscale, alpha := 65535 *//* pre': as 'pre' but alpha := 65535 *//* pre: make sRGB components linear and premultiply by alpha (scale alpha) *//* lin: make sRGB components linear, alpha := 65535 *//* 8-bit to 16-bit conversions *//* g8b: convert sRGB components to grayscale and composite on gray background *//* g8: convert sRGB components to sRGB grayscale *//* bckc: composite on color background *//* bckg: composite on gray background *//* 8-bit to 8-bit conversions *//* Simple copy: *//* Conversion between pixel formats.  The code above effectively eliminates the
 * component ordering changes leaving three basic changes:
 *
 * 1) Remove an alpha channel by pre-multiplication or compositing on a
 *    background color.  (Adding an alpha channel is a no-op.)
 *
 * 2) Remove color by mapping to grayscale.  (Grayscale to color is a no-op.)
 *
 * 3) Convert between 8-bit and 16-bit components.  (Both directions are
 *    relevant.)
 *
 * This gives the following base format conversion matrix:
 *
 *   OUT:    ----- 8-bit -----    ----- 16-bit -----
 *   IN     G    GA   RGB  RGBA  G    GA   RGB  RGBA
 *  8 G     .    .    .    .     lin  lin  lin  lin
 *  8 GA    bckg .    bckc .     pre' pre  pre' pre
 *  8 RGB   g8   g8   .    .     glin glin lin  lin
 *  8 RGBA  g8b  g8   bckc .     gpr' gpre pre' pre
 * 16 G     sRGB sRGB sRGB sRGB  .    .    .    .
 * 16 GA    b16g unpg b16c unpc  A    .    A    .
 * 16 RGB   sG   sG   sRGB sRGB  g16  g16  .    .
 * 16 RGBA  gb16 sGp  cb16 sCp   g16  g16' A    .
 *
 *  8-bit to 8-bit:
 * bckg: composite on gray background
 * bckc: composite on color background
 * g8:   convert sRGB components to sRGB grayscale
 * g8b:  convert sRGB components to grayscale and composite on gray background
 *
 *  8-bit to 16-bit:
 * lin:  make sRGB components linear, alpha := 65535
 * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
 * pre': as 'pre' but alpha := 65535
 * glin: make sRGB components linear, convert to grayscale, alpha := 65535
 * gpre: make sRGB components grayscale and linear and premultiply by alpha
 * gpr': as 'gpre' but alpha := 65535
 *
 *  16-bit to 8-bit:
 * sRGB: convert linear components to sRGB, alpha := 255
 * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
 * unpc: unpremultiply color components and convert to sRGB (scale alpha)
 * b16g: composite linear onto gray background and convert the result to sRGB
 * b16c: composite linear onto color background and convert the result to sRGB
 * sG:   convert linear RGB to sRGB grayscale
 * sGp:  unpremultiply RGB then convert to sRGB grayscale
 * sCp:  unpremultiply RGB then convert to sRGB
 * gb16: composite linear onto background and convert to sRGB grayscale
 *       (order doesn't matter, the composite and grayscale operations permute)
 * cb16: composite linear onto background and convert to sRGB
 *
 *  16-bit to 16-bit:
 * A:    set alpha to 65535
 * g16:  convert linear RGB to linear grayscale (alpha := 65535)
 * g16': as 'g16' but alpha is unchanged
 *//* The color-map flag is irrelevant here - the caller of the function
    * returned must either pass the buffer or, for a color-mapped image, the
    * correct entry in the color-map.
    *//* Given a format, return the correct one of the above functions. *//* Read a Pixel from a buffer.  The code below stores the correct routine for
 * the format in a function pointer, these are the routines:
 *//* Basic image formats; control the data but not the layout thereof. *//* linear r,g,b scaled to 0..1 *//* The background as the original sRGB 8-bit value converted to the final
    * integer format and as a double precision linear value in the range 0..1
    * for with partially transparent pixels.
    *//* The components, for grayscale images the gray value is in 'g' and if alpha
    * is not present 'a' is set to 255 or 65535 according to format.
    *//* Compare the pixels of two images, which should be the same but aren't.  The
 * images must have been checked for a size match.
 *//* IMAGE COMPARISON/CHECKING *//* Separate out the gamma+background_rgb_to_gray warning because it may
    * produce opaque component errors:
    *//* Make sure the png_image has been freed - validates that libpng is doing what
 * the spec says and freeing the image.
 *//* Log an error and close a file (just a utility to do both things in one
 * function call.)
 *//* Log a terminal error, also frees the libpng part of the image if necessary.
 *//* ERROR HANDLING *//* Check for overwrite in the image buffer. *//* Make sure 16 bytes match the given byte. *//* Make sure the image buffer is big enough; allows re-use of the buffer if the
 * image is re-read.
 *//* This is actually a re-initializer; allows an image structure to be re-used by
 * freeing everything that relates to an old image.
 *//* Delete function; cleans out all the allocated data and the temporary file in
 * the image.
 *//* Free the image buffer; the buffer is re-used on a re-read, this is just for
 * cleanup.
 *//* Reset the image to be read again - only needs to rewind the FILE object at
 * present.
 *//* Initializer: also sets the permitted error limit for 16-bit operations. *//* The super-class of a png_image, contains the decoded image plus the input
 * data necessary to re-read the file with a different format.
 *//* THE Image STRUCTURE *//*HACK: fixed value*//* AFIRST is meaningless if no alpha: *//* BGR is meaningless if no color: *//* Eliminate redundant and unsupported settings. *//* set everything, including flags that are pointless *//* currently unused *//* All off *//* Bitset/test functions for formats *//* Decode an argument to a format number. *//* A name table for all the formats - defines the format of the '+' arguments to
 * pngstest.
 *//* additional flag *//* --fast is currently the default *//* do not ignore the gamma+background_rgb_to_gray
                          * libpng warning. *//* do not reseed on each new file *//* else delete temporary files *//* fail on warnings too *//* else use file name *//* else memory *//* unused *//* "multiple_algorithms" in this case means that a color-map has been
    * involved somewhere, so we can deduce that the values were forced to 8-bit
    * (like the via_linear case for 8-bit.)
    *//* Always allow an extra 1 here for rounding errors *//* Round trip the value through an 8-bit representation but using
       * non-matching to/from conversions.
       *//* by experiment *//* The error that results from using a 2.2 power law in place of the correct
 * sRGB transform, given an 8-bit value which might be either sRGB or power-law.
 *//* Arbitrary, but consistent with the libpng code *//*range 0.0 .. 1.0*//* sRGB support: use exact calculations rounded to the nearest int, see the
 * fesetround() call in main().  sRGB_to_d optimizes the 8 to 16-bit conversion.
 *//* Cast support: remove GCC whines. *//* Math support - neither Cygwin nor Visual Studio have C99 support and we need
 * a predictable rounding function, so make one here:
 *//* First generate 8 new bits then shift them in at the end. *//* There are thirty three bits, the next bit in the sequence is bit-33 XOR
    * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.
    *//* Generate random bytes.  This uses a boring repeatable algorithm and it
 * is implemented here so that it gives the same set of numbers on every
 * architecture.  It's a linear congruential generator (Knuth or Sedgewick
 * "Algorithms") but it comes from the 'feedback taps' table in Horowitz and
 * Hill, "The Art of Electronics".
 *//* During parallel runs of pngstest each temporary file needs a unique name,
 * this is used to permit uniqueness using a command line argument which can be
 * up to 22 characters long.
 *//* The following is to support direct compilation of this file as C++ *//* If true include unused static GPC functions and declare an external array
    * of them to hide the fact that they are unused.  This is for development
    * use while testing the correct function to use to take into account libpng
    * misbehavior, such as using a simple power law to correct sRGB to linear.
    *//* KNOWN ISSUES
 *
 * These defines switch on alternate algorithms for format conversions to match
 * the current libpng implementation; they are set to allow pngstest to pass
 * even though libpng is producing answers that are not as correct as they
 * should be.
 *//* Else nothing can be done *//*glibc facility: turn on debugging*//* pngstest.c
 *
 * Copyright (c) 2021-2025 Cosmin Truta
 * Copyright (c) 2013-2017 John Cunningham Bowler
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * Test for the PNG 'simplified' APIs.
 */a2a3fixed_srgbfixed_linearlinearcolorseedD:/PracticeInCodeQL/libpng/contrib/libtests/pngunknown.c<setjmp.h>const char **png_uint_32[4]unsigned int[4]default_flagsstrictdefault_testscount_argvdefault=save"default=save"touch_file--default"--default"--touch: missing file name"--touch: missing file name"missing test file"missing test file"extra arguments"extra arguments"%s: %s: internal error
"%s: %s: internal error\n"const char[13]const char[15]testconst char *[30]char *[30]this_testconst displayconst display *new_countarg_count%s: %s %s
"%s: %s %s\n"errPNG unknown tests succeeded
"PNG unknown tests succeeded\n"usagepngunknown: %s: usage:
 %s [--strict] --default|{(CHNK|default|all)=(default|discard|if-safe|save)} testfile.png
"pngunknown: %s: usage:\n %s [--strict] "
      "--default|{(CHNK|default|all)=(default|discard|if-safe|save)} "
      "testfile.png\n"char[114]perform_one_test_safeperform_one_testdefpng_uint_32[2][4]unsigned int[2][4]png_uint_32(*)[4]unsigned int(*)[4]sizeof flags[0]struct <unnamed>[25]chunk handled inconsistently in count tests"chunk handled inconsistently in count tests"chunk handled inconsistently in option tests"chunk handled inconsistently in option tests"char[45]new known chunk before IDAT"new known chunk before IDAT"new unknown chunk before IDAT"new unknown chunk before IDAT"new known chunk after IDAT"new known chunk after IDAT"new unknown chunk after IDAT"new unknown chunk after IDAT"before IDAT"before IDAT"after IDAT"after IDAT"check_handlingprogramset_callbackknownpositionerrorxUNKNOWN (default)"UNKNOWN (default)"UNKNOWN (specified)"UNKNOWN (specified)"chunk processed"chunk processed"DEFAULT: unknown chunk saved"DEFAULT: unknown chunk saved"DISCARD: unknown chunk saved"DISCARD: unknown chunk saved"IF-SAFE: unknown ancillary chunk lost"IF-SAFE: unknown ancillary chunk lost"IF-SAFE: unknown critical chunk saved"IF-SAFE: unknown critical chunk saved"SAVE: unknown chunk lost"SAVE: unknown chunk lost"internal error: bad keep"internal error: bad keep"KNOWN"KNOWN"!DEFAULT: known chunk processed"!DEFAULT: known chunk processed"DEFAULT: known chunk not processed"DEFAULT: known chunk not processed"DISCARD: known chunk saved"DISCARD: known chunk saved"IF-SAFE: known ancillary chunk lost"IF-SAFE: known ancillary chunk lost"IF-SAFE: known critical chunk saved"IF-SAFE: known critical chunk saved"SAVE: known chunk lost"SAVE: known chunk lost"internal error: bad keep (2)"internal error: bad keep (2)"%s(%s%s): %s %s %s: %s
"%s(%s%s): %s %s %s: %s\n",callback",callback"check_error%s(%s): chunk %s: %s
"%s(%s): chunk %s: %s\n"checknpassesipass%s(%s): could not allocate png struct
"%s(%s): could not allocate png struct\n"%s(%s): could not allocate png info
"%s(%s): could not allocate png info\n"equals61'='default"default"discard"discard"if-safe"if-safe""save"%s(%s): %s: unrecognized chunk option
"%s(%s): %s: unrecognized chunk option\n"all"all"800NINFO%s(%s): %s: unrecognized chunk argument
"%s(%s): %s: unrecognized chunk argument\n"%s(%s): invalid interlace type
"%s(%s): invalid interlace type\n"wPass28529604718111216get_unknownafter_IDATnum_unknown%s(%s): %s: %s: unknown chunk saved
"%s(%s): %s: %s: unknown chunk saved\n"%s(%s): if-safe: %s: unknown critical chunk saved
"%s(%s): if-safe: %s: unknown critical chunk saved\n"char[51]read_callbackdisplay*png_get_user_chunk_ptr(pp)%s(%s): %d: unrecognized chunk option
"%s(%s): %d: unrecognized chunk option\n"get_valid~0(png_uint_32)~0ntext268435456PNG_INFO_tEXt1073741824PNG_INFO_zTXt536870912PNG_INFO_iTXt%s(%s): unknown text compression %d
"%s(%s): unknown text compression %d\n"%s(%s): libpng warning: %s
"%s(%s): libpng warning: %s\n"%s(%s): libpng error: %s
"%s(%s): libpng error: %s\n"display_rcdisplay_exitclean_display%s(%s): png_destroy_read_struct error
"%s(%s): png_destroy_read_struct error\n"init_display336sizeof *dancillarybPNG_U32(name[0], name[1], name[2], name[3])(((png_uint_32)(((unsigned int)(name[0]) << 8) + (name[1])) << 16) + (((unsigned int)(name[2]) << 8) + (name[3])))name[0]name[1]name[2]name[3]ancillaryfind_by_flagpngunknown: internal error
"pngunknown: internal error\n"findbfindclear_keepwarning_counterror_countbefore_IDATend_ptrtagconst char *[]standard_testsdefault=discard"default=discard"default=if-safe"default=if-safe"pcvpAg"vpAg"vpAg=if-safe"vpAg=if-safe"sTER"sTER"sTER=if-safe"sTER=if-safe"IDAT"IDAT"IDAT=save"IDAT=save"sAPI"sAPI"bKGD=save"bKGD=save"cHRM=save"cHRM=save"gAMA=save"gAMA=save"all=discard"all=discard"iCCP=save"iCCP=save"sBIT=save"sBIT=save"sRGB=save"sRGB=save"eXIf=save"eXIf=save"cmdcommand line"command line"initinitialization"initialization"struct <unnamed>[]chunk_info686584807669987571728277678810383868966((int)((sizeof chunk_info)/(sizeof chunk_info[0])))ENDSTARTABSENTPNG_INFO_vpAg0x02000000UPNG_INFO_sTER0x01000000U0x40000000U0x20000000U0x10000000Upng_vpAgPNG_U32(118, 112, 65, 103)UNUSED(param)(void)param;PNG_CHUNK_SAFE_TO_COPY(c)(1 & ((c) >> 5))PNG_CHUNK_RESERVED(c)(1 & ((c) >> 13))PNG_CHUNK_PRIVATE(c)(1 & ((c) >> 21))PNG_CHUNK_CRITICAL(c)(!PNG_CHUNK_ANCILLARY(c))PNG_CHUNK_ANCILLARY(c)(1 & ((c) >> 29))png_zTXtPNG_U32(122, 84, 88, 116)png_tRNSPNG_U32(116, 82, 78, 83)png_tIMEPNG_U32(116, 73, 77, 69)png_tEXtPNG_U32(116, 69, 88, 116)png_sTERPNG_U32(115, 84, 69, 82)png_sRGBPNG_U32(115, 82, 71, 66)png_sPLTPNG_U32(115, 80, 76, 84)png_sCALPNG_U32(115, 67, 65, 76)png_sBITPNG_U32(115, 66, 73, 84)png_pHYsPNG_U32(112, 72, 89, 115)png_pCALPNG_U32(112, 67, 65, 76)png_oFFsPNG_U32(111, 70, 70, 115)png_mDCVPNG_U32(109, 68, 67, 86)png_iTXtPNG_U32(105, 84, 88, 116)png_iCCPPNG_U32(105, 67, 67, 80)png_hISTPNG_U32(104, 73, 83, 84)png_gIFxPNG_U32(103, 73, 70, 120)png_gIFtPNG_U32(103, 73, 70, 116)png_gIFgPNG_U32(103, 73, 70, 103)png_gAMAPNG_U32(103, 65, 77, 65)png_fRAcPNG_U32(102, 82, 65, 99)png_eXIfPNG_U32(101, 88, 73, 102)png_cLLIPNG_U32( 99, 76, 76, 73)png_cICPPNG_U32( 99, 73, 67, 80)png_cHRMPNG_U32( 99, 72, 82, 77)png_bKGDPNG_U32( 98, 75, 71, 68)png_PLTEPNG_U32( 80, 76, 84, 69)png_IHDRPNG_U32( 73, 72, 68, 82)png_IENDPNG_U32( 73, 69, 78, 68)png_IDATPNG_U32( 73, 68, 65, 84)PNG_U32(b1,b2,b3,b4)(((png_uint_32)PNG_u2(b1, b2) << 16) + PNG_u2(b3, b4))PNG_U16(b1,b2)((png_uint_16)PNG_u2(b1, b2))PNG_u2(b1,b2)(((unsigned int)(b1) << 8) + (b2))defined(PNG_SET_UNKNOWN_CHUNKS_SUPPORTED) && defined(PNG_STDIO_SUPPORTED) && defined(PNG_READ_SUPPORTED)defined(PNG_READ_USER_CHUNKS_SUPPORTED) || defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)UNUSEDdefined(__GNUC__) || defined(_MSC_VER)PNG_READ_bKGD_SUPPORTEDPNG_READ_cHRM_SUPPORTEDPNG_READ_cICP_SUPPORTEDPNG_READ_cLLI_SUPPORTEDPNG_READ_eXIf_SUPPORTEDPNG_READ_gAMA_SUPPORTEDPNG_READ_hIST_SUPPORTEDPNG_READ_iCCP_SUPPORTEDPNG_READ_iTXt_SUPPORTEDPNG_READ_mDCV_SUPPORTEDPNG_READ_oFFs_SUPPORTEDPNG_READ_pCAL_SUPPORTEDPNG_READ_pHYs_SUPPORTEDPNG_READ_sBIT_SUPPORTEDPNG_READ_sCAL_SUPPORTEDPNG_READ_sPLT_SUPPORTEDPNG_READ_sRGB_SUPPORTEDPNG_READ_tEXt_SUPPORTEDPNG_READ_tIME_SUPPORTEDPNG_READ_tRNS_SUPPORTEDPNG_READ_zTXt_SUPPORTEDPNG_SAVE_UNKNOWN_CHUNKS_SUPPORTEDPNG_LIBPNG_VER >= 10700 && !defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)/* SET_UNKNOWN_CHUNKS && READ*//* !(SET_UNKNOWN_CHUNKS && READ) *//* READ_USER_CHUNKS || SAVE_UNKNOWN_CHUNKS *//* !(READ_USER_CHUNKS || SAVE_UNKNOWN_CHUNKS) *//* Success, touch the success file if appropriate *//* Set the exit_test pointer here so we can continue after a libpng error.
       * NOTE: this leaks memory because the png_struct data from the failing
       * test is never freed.
       *//* acts as a flag to say exit, do not longjmp *//* Now find what the various supplied options cause to change: *//* First find all the chunks, known and unknown, in the test file, a failure
    * here aborts the whole test.
    *
    * If 'save' is supported then the normal saving method should happen,
    * otherwise if 'read' is supported then the read callback will do the
    * same thing.  If both are supported the 'read' callback won't be
    * instantiated by default.  If 'save' is *not* supported then a user
    * callback is required even though we can call png_get_unknown_chunks.
    *//* The name of the test file is the last argument; remove it. *//* GCC BUG: if (default_tests && argc != 1) triggers some weird GCC argc
    * optimization which causes warnings with -Wstrict-overflow!
    *//* A file name is required, but there should be no other arguments if
    * --default was specified.
    *//*valid,unknown{before,after}*//*end*//* prevent use of d->error_return *//* allow use of d->error_return *//* Now each chunk in the original list should have been handled according to
    * the options set for that chunk, regardless of whether libpng knows about
    * it or not.
    *//* Now find out what happened to each chunk before and after the IDAT and
    * determine if the behavior was correct.  First some basic sanity checks,
    * any known chunk should be known in the original count, any unknown chunk
    * should be either known or unknown in the original.
    *//* Chunks should either be known or unknown, never both and this should apply
    * whether the chunk is before or after the IDAT (actually, the app can
    * probably change this by swapping the handling after the image, but this
    * test does not do that.)
    *//* If IDAT is being handled as unknown the image read is skipped and all the
    * IDATs after the first end up in the end info struct, so in this case add
    * IDAT to the list of unknowns.  (Do this after 'check' above sets the
    * chunk_info 'keep' fields.)
    *
    * Note that the flag setting has to be in the 'known' field to avoid
    * triggering the consistency check below and the flag must only be set if
    * there are multiple IDATs, so if the check above did find an unknown IDAT
    * after IDAT.
    *//* not processed *//* chunk was processed, it won't have been saved because that is
             * caught below when checking for inconsistent processing.
             *//* known chunk *//* unknown chunk *//*after IDAT*//* Only png_read_png sets PNG_INFO_IDAT! *//*before IDAT*//* not interlaced *//* interlaced *//* Skip the image data, if IDAT is not being handled then don't do this
    * because it will cause a CRC error.
    *//* Hard error because it is not test specific *//* some misplaced = *//* 1.7+ SAVE_UNKNOWN_CHUNKS *//* all *//* default *//* These #if tests have the effect of skipping the arguments
                   * if SAVE support is unavailable - we can't do a useful test
                   * in this case, so we just check the arguments!  This could
                   * be improved in the future by using the read callback.
                   *//* chunk name *//* Handle each argument in turn; multiple settings are possible for the same
    * chunk and multiple calls will occur (the last one should override all
    * preceding ones).
    *//* This is only done if requested by the caller; it interferes with the
       * standard store/save mechanism.
       *//* Terminate here, this error is not test specific. *//* Some of these errors are permanently fatal and cause an exit here, others
    * are per-test and cause an error return.
    *//* SAVE_UNKNOWN_CHUNKS *//* READ_USER_CHUNKS *//* The #defines above should mean this is never reached, it's just here as
       * a check to ensure the logic is correct.
       *//* Otherwise this will return the cached values set by any user callback *//* (safe) *//* Chunks not known to pngunknown must be validated here; since they
          * must also be unknown to libpng the 'display->keep' behavior should
          * have been used.
          *//* Create corresponding 'unknown' flags *//* READ_USER_CHUNKS_SUPPORTED *//*handled; discard*//* However if there is no support to store unknown chunks don't ask libpng to
    * do it; there will be an png_error.
    *//* stupidity to stop a GCC warning *//* Also store information about this chunk in the display, the relevant flag
    * is set if the chunk is to be kept ('not handled'.)
    *//*not handled; keep*//* See the comments in png.h - use the default for unknown chunks,
          * do not keep known chunks.
          *//* not one in our list, so not a known chunk *//* This function mimics the behavior of png_set_keep_unknown_chunks by
    * returning '0' to keep the chunk and '1' to discard it.
    *//* Map the text chunks back into the flags *//* libpng error and warning callbacks *//* During initialization and if this is a single command line argument set
    * exit now - there is only one test, otherwise longjmp to do the next test.
    *//* This must not happen - it might cause an app crash *//* the default value *//* Type of an error_ptr *//* No libpng handling *//* This is a mess but it seems to be the only way to do it - there is no way
    * to check for a definition outside a #if.
    *//* Non-critical chunks that libpng handles *//* must be [0] *//* Critical chunks *//* unknown handling setting *//* position in pngtest.png *//* Chunk set by the '-1' option *//* Chunk not known to libpng *//* Chunk information *//* Types of chunks not known to libpng *//* Unused formal parameter errors are removed using the following macro which is
 * expected to have no bad effects on performance.
 *//* Test on flag values as defined in the spec (section 5.4): *//* PNGv3 *//* deprecated *//* registered, not defined *//* registered July 2017 *//* Constants for known chunk types.
 *//* Copied from libpng 1.7.0 png.h *//* One of these must be defined to allow us to find out what happened.  It is
 * still useful to set unknown chunk handling without either of these in order
 * to cause *known* chunks to be discarded.  This can be a significant
 * efficiency gain, but it can't really be tested here.
 *//* Since this program tests the ability to change the unknown chunk handling
 * these must be defined:
 *//* pngunknown.c - test the read side unknown chunk handling
 *
 * Copyright (c) 2021-2025 Cosmin Truta
 * Copyright (c) 2015,2017 Glenn Randers-Pehrson
 * Written by John Cunningham Bowler
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * NOTES:
 *   This is a C program that is intended to be linked against libpng.  It
 *   allows the libpng unknown handling code to be tested by interpreting
 *   arguments to save or discard combinations of chunks.  The program is
 *   currently just a minimal validation for the built-in libpng facilities.
 */C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/signal.hraisesignalvoid **__pxcptinfoptrs_crt_signal_tsig_atomic_t_pxcptinfoptrs(*__pxcptinfoptrs())SIG_ERR((_crt_signal_t)-1)SIG_ACK((_crt_signal_t)4)SIG_SGE((_crt_signal_t)3)SIG_GET((_crt_signal_t)2)SIG_IGN((_crt_signal_t)1)SIG_DFL((_crt_signal_t)0)SIGABRT_COMPATSIGABRTSIGBREAKSIGTERMSIGSEGVSIGFPESIGILLSIGINTNSIG_INC_SIGNAL_CORECRT_BUILD// _INC_SIGNAL// Function prototypes// Pointer to exception information pointers structure// signal error value// Signal error value (returned by signal call on error)// terminate process// Internal use only!  Not valid as an argument to signal().// acknowledge// signal gets error// return current value// ignore signal// default signal action// Signal action codes// SIGABRT compatible with other platforms, same as SIGABRT// abnormal termination triggered by abort call// Ctrl-Break sequence// Software termination signal from kill// segment violation// floating point exception// illegal instruction - invalid function image// interrupt// Signal types// maximum signal number + 1// The C Standard Library <signal.h> header._Signal_FunctionD:/PracticeInCodeQL/libpng/contrib/visupng/cexcept.hThrowfor (;; longjmp(*the_exception_context->penv, 1)) the_exception_context->v.etmp =Catch_anonymousexception__catch(0)Catch(e)exception__catch(((e) = the_exception_context->v.etmp, 0))exception__catch(action)while (the_exception_context->caught = 0, the_exception_context->caught); } else { the_exception_context->caught = 1; } the_exception_context->penv = exception__prev; } if (!the_exception_context->caught || action) { } elseTry{ jmp_buf *exception__prev, exception__env; exception__prev = the_exception_context->penv; the_exception_context->penv = &exception__env; if (setjmp(exception__env) == 0) { doinit_exception_context(ec)((void)((ec)->penv = 0))define_exception_type(etype)struct exception_context { jmp_buf *penv; int caught; volatile struct { etype etmp; } v; }CEXCEPT_H/* CEXCEPT_H *//* false and avoid generating code for it.                            *//* Most compilers should still recognize that the condition is always *//* compilers that warn about constant expressions inside while().     *//* The 0 in while(0) is expressed as x=0,x in order to appease        *//*                                                                    *//* syntax.                                                            *//* else, to ensure that Try/Catch syntax is similar to if/else        *//* Try ends with do, and Catch begins with while(0) and ends with     *//* already includes it.                                              *//* avoid warnings about a duplicate volatile qualifier in case etype *//* the calls to setjmp() and longjmp().  A wrapper struct is used to *//* storage for the_exception_context, and etmp is modified between   *//* etmp must be volatile because the application might use automatic *//*===
cexcept.h 2.0.1 (2008-Jul-19-Sat)
http://www.nicemice.net/cexcept/
Adam M. Costello
http://www.nicemice.net/amc/

An interface for exception-handling in ANSI C (C89 and subsequent ISO
standards), developed jointly with Cosmin Truta.

    Copyright (c) 2000-2008 Adam M. Costello and Cosmin Truta.
    This software may be modified only if its author and version
    information is updated accurately, and may be redistributed
    only if accompanied by this unaltered notice.  Subject to those
    restrictions, permission is granted to anyone to do anything
    with this software.  The copyright holders make no guarantees
    regarding this software, and are not responsible for any damage
    resulting from its use.

The cexcept interface is not compatible with and cannot interact
with system exceptions (like division by zero or memory segmentation
violation), compiler-generated exceptions (like C++ exceptions), or
other exception-handling interfaces.

When using this interface across multiple .c files, do not include
this header file directly.  Instead, create a wrapper header file that
includes this header file and then invokes the define_exception_type
macro (see below).  The .c files should then include that header file.

The interface consists of one type, one well-known name, and six macros.


define_exception_type(type_name);

    This macro is used like an external declaration.  It specifies
    the type of object that gets copied from the exception thrower to
    the exception catcher.  The type_name can be any type that can be
    assigned to, that is, a non-constant arithmetic type, struct, union,
    or pointer.  Examples:

        define_exception_type(int);

        enum exception { out_of_memory, bad_arguments, disk_full };
        define_exception_type(enum exception);

        struct exception { int code; const char *msg; };
        define_exception_type(struct exception);

    Because throwing an exception causes the object to be copied (not
    just once, but twice), programmers may wish to consider size when
    choosing the exception type.


struct exception_context;

    This type may be used after the define_exception_type() macro has
    been invoked.  A struct exception_context must be known to both
    the thrower and the catcher.  It is expected that there be one
    context for each thread that uses exceptions.  It would certainly
    be dangerous for multiple threads to access the same context.
    One thread can use multiple contexts, but that is likely to be
    confusing and not typically useful.  The application can allocate
    this structure in any way it pleases--automatic, static, or dynamic.
    The application programmer should pretend not to know the structure
    members, which are subject to change.


struct exception_context *the_exception_context;

    The Try/Catch and Throw statements (described below) implicitly
    refer to a context, using the name the_exception_context.  It is
    the application's responsibility to make sure that this name yields
    the address of a mutable (non-constant) struct exception_context
    wherever those statements are used.  Subject to that constraint, the
    application may declare a variable of this name anywhere it likes
    (inside a function, in a parameter list, or externally), and may
    use whatever storage class specifiers (static, extern, etc) or type
    qualifiers (const, volatile, etc) it likes.  Examples:

        static struct exception_context
          * const the_exception_context = &foo;

        { struct exception_context *the_exception_context = bar; ... }

        int blah(struct exception_context *the_exception_context, ...);

        extern struct exception_context the_exception_context[1];

    The last example illustrates a trick that avoids creating a pointer
    object separate from the structure object.

    The name could even be a macro, for example:

        struct exception_context ec_array[numthreads];
        #define the_exception_context (ec_array + thread_id)

    Be aware that the_exception_context is used several times by the
    Try/Catch/Throw macros, so it shouldn't be expensive or have side
    effects.  The expansion must be a drop-in replacement for an
    identifier, so it's safest to put parentheses around it.


void init_exception_context(struct exception_context *ec);

    For context structures allocated statically (by an external
    definition or using the "static" keyword), the implicit
    initialization to all zeros is sufficient, but contexts allocated
    by other means must be initialized using this macro before they
    are used by a Try/Catch statement.  It does no harm to initialize
    a context more than once (by using this macro on a statically
    allocated context, or using this macro twice on the same context),
    but a context must not be re-initialized after it has been used by a
    Try/Catch statement.


Try statement
Catch (expression) statement

    The Try/Catch/Throw macros are capitalized in order to avoid
    confusion with the C++ keywords, which have subtly different
    semantics.

    A Try/Catch statement has a syntax similar to an if/else statement,
    except that the parenthesized expression goes after the second
    keyword rather than the first.  As with if/else, there are two
    clauses, each of which may be a simple statement ending with a
    semicolon or a brace-enclosed compound statement.  But whereas
    the else clause is optional, the Catch clause is required.  The
    expression must be a modifiable lvalue (something capable of being
    assigned to) of the same type (disregarding type qualifiers) that
    was passed to define_exception_type().

    If a Throw that uses the same exception context as the Try/Catch is
    executed within the Try clause (typically within a function called
    by the Try clause), and the exception is not caught by a nested
    Try/Catch statement, then a copy of the exception will be assigned
    to the expression, and control will jump to the Catch clause.  If no
    such Throw is executed, then the assignment is not performed, and
    the Catch clause is not executed.

    The expression is not evaluated unless and until the exception is
    caught, which is significant if it has side effects, for example:

        Try foo();
        Catch (p[++i].e) { ... }

    IMPORTANT: Jumping into or out of a Try clause (for example via
    return, break, continue, goto, longjmp) is forbidden--the compiler
    will not complain, but bad things will happen at run-time.  Jumping
    into or out of a Catch clause is okay, and so is jumping around
    inside a Try clause.  In many cases where one is tempted to return
    from a Try clause, it will suffice to use Throw, and then return
    from the Catch clause.  Another option is to set a flag variable and
    use goto to jump to the end of the Try clause, then check the flag
    after the Try/Catch statement.

    IMPORTANT: The values of any non-volatile automatic variables
    changed within the Try clause are undefined after an exception is
    caught.  Therefore, variables modified inside the Try block whose
    values are needed later outside the Try block must either use static
    storage or be declared with the "volatile" type qualifier.


Throw expression;

    A Throw statement is very much like a return statement, except that
    the expression is required.  Whereas return jumps back to the place
    where the current function was called, Throw jumps back to the Catch
    clause of the innermost enclosing Try clause.  The expression must
    be compatible with the type passed to define_exception_type().  The
    exception must be caught, otherwise the program may crash.

    Slight limitation:  If the expression is a comma-expression, it must
    be enclosed in parentheses.


Try statement
Catch_anonymous statement

    When the value of the exception is not needed, a Try/Catch statement
    can use Catch_anonymous instead of Catch (expression).


Everything below this point is for the benefit of the compiler.  The
application programmer should pretend not to know any of it, because it
is subject to change.

===*/D:/PracticeInCodeQL/libpng/contrib/visupngD:/Applications/VCPKG/vcpkg/installed/x64-windows/include/zlib.hD:/Applications/VCPKG/vcpkg/installed/x64-windows/include/zconf.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/sys/types.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/float.hD:/PracticeInCodeQL/libpng/contrib/libtests/pngvalid.c"../visupng/cexcept.h"<float.h><zlib.h><signal.h>summarymemstatsdouble[]gammascpchar[1024]command&pm.thisexception_context *the_exception_contextpng_store *png_modifier *TRANSFORM_ROWMAXTRANSFORM_HEIGHTMAXsizeof commandpngvalid"pngvalid"10700double[9]ARRAY_SIZE(gammas)const color_encodingconst color_encoding *color_encoding *const color_encoding[5]color_encoding[5]test_encodings400ARRAY_SIZE(test_encodings)8U0.1000000000000000056.15.00000000000000024e-05.000051.0.0039215686274509803381./2550.4989999999999999991.4991.525902189669642176e-051./65535PNG_MAX_GAMMA_81<<PNG_MAX_GAMMA_8(1<<PNG_MAX_GAMMA_8)2047(1<<PNG_MAX_GAMMA_8)-1((1<<PNG_MAX_GAMMA_8)-1)2047.00.00048851978505129456391./((1<<PNG_MAX_GAMMA_8)-1)0.005000000000000000104.005catmore " "-v"-v"-l"-l"-q"-q"-w"-w"--speed"--speed"--size"--size"--nosize"--nosize"--standard"--standard"--nostandard"--nostandard"--transform"--transform"--notransform"--notransform"--transform-disable="--transform-disable="--transform-disable"--transform-disable"sizeof "--transform-disable"--transform-enable="--transform-enable="--transform-enable"--transform-enable"sizeof "--transform-enable"--gamma"--gamma"2U--nogamma"--nogamma"--gamma-threshold"--gamma-threshold"--nogamma-threshold"--nogamma-threshold"--gamma-transform"--gamma-transform"--nogamma-transform"--nogamma-transform"--gamma-sbit"--gamma-sbit"--nogamma-sbit"--nogamma-sbit"--gamma-16-to-8"--gamma-16-to-8"--nogamma-16-to-8"--nogamma-16-to-8"--gamma-background"--gamma-background"--nogamma-background"--nogamma-background"--gamma-alpha-mode"--gamma-alpha-mode"--nogamma-alpha-mode"--nogamma-alpha-mode"--expand16"--expand16"--noexpand16"--noexpand16"--low-depth-gray"--low-depth-gray"--nolow-depth-gray"--nolow-depth-gray"--tRNS"--tRNS"--notRNS"--notRNS"--more-gammas"--more-gammas"3U--all-gammas"--all-gammas"--progressive-read"--progressive-read"--use-update-info"--use-update-info"--interlace"--interlace"--use-input-precision"--use-input-precision"--use-calculation-precision"--use-calculation-precision"--calculations-use-input-precision"--calculations-use-input-precision"--assume-16-bit-calculations"--assume-16-bit-calculations"--calculations-follow-bit-depth"--calculations-follow-bit-depth"--sbitlow"--sbitlow"--max"--max"abs8"abs8"abs16"abs16"calc8"calc8"calc16"calc16"out8"out8"out16"out16"pc8"pc8"pc16"pc16"pngvalid: %s: unknown 'max' option
"pngvalid: %s: unknown 'max' option\n"--log8"--log8"--log16"--log16"--option="--option="settingarm-neon:"arm-neon:"max-inflate-window:"max-inflate-window:"pngvalid: %s: %s: unknown option
"pngvalid: %s: %s: unknown option\n"off"off"on"on"pngvalid: %s: %s: unknown setting (use 'on' or 'off')
"pngvalid: %s: %s: unknown setting (use 'on' or 'off')\n"char[55]struct <unnamed>[16]pngvalid: %s: unknown argument
"pngvalid: %s: unknown argument\n"exception__prevexception__envpngvalid: test aborted (probably failed in cleanup)
"pngvalid: test aborted (probably failed in cleanup)\n"char[256]pngvalid: first error: %s
"pngvalid: first error: %s\n"pngvalid: run with -v to see what happened
"pngvalid: run with -v to see what happened\n"%s: %s (%s point arithmetic)
"%s: %s (%s point arithmetic)\n"floating"floating"Allocated memory statistics (in bytes):
	read  %lu maximum single, %lu peak, %lu total
	write %lu maximum single, %lu peak, %lu total
"Allocated memory statistics (in bytes):\n"
         "\tread  %lu maximum single, %lu peak, %lu total\n"
         "\twrite %lu maximum single, %lu peak, %lu total\n"char[135]pngvalid: %s
"pngvalid: %s\n"pngvalid: %d errors, %d warnings
"pngvalid: %d errors, %d warnings\n"PNG validation succeeded
"PNG validation succeeded\n"fail2.2000000000000001782.21.4499999999999999561.451.5172413793103449732.2/1.451.8000000000000000441.81.52.52.6200000000000001072.622.8999999999999999112.9signal_handlerposmsgsizeof msgcaught signal: "caught signal: "abort"abort"floating point exception"floating point exception"illegal instruction"illegal instruction"interrupt"interrupt"invalid memory access"invalid memory access"termination request"termination request"unknown "unknown "volatile struct <unnamed>perform_interlace_macro_validationvmPNG_PASS_START_ROW(%d) = %u != %x
"PNG_PASS_START_ROW(%d) = %u != %x\n"PNG_PASS_START_COL(%d) = %u != %x
"PNG_PASS_START_COL(%d) = %u != %x\n"PNG_PASS_ROW_SHIFT(%d) = %u != %x
"PNG_PASS_ROW_SHIFT(%d) = %u != %x\n"PNG_PASS_COL_SHIFT(%d) = %u != %x
"PNG_PASS_COL_SHIFT(%d) = %u != %x\n"0xFFFFFFFFUPNG_ROW_FROM_PASS_ROW(%u, %d) = %u != %x
"PNG_ROW_FROM_PASS_ROW(%u, %d) = %u != %x\n"PNG_COL_FROM_PASS_COL(%u, %d) = %u != %x
"PNG_COL_FROM_PASS_COL(%u, %d) = %u != %x\n"PNG_ROW_IN_INTERLACE_PASS(%u, %d) = %u != %x
"PNG_ROW_IN_INTERLACE_PASS(%u, %d) = %u != %x\n"PNG_COL_IN_INTERLACE_PASS(%u, %d) = %u != %x
"PNG_COL_IN_INTERLACE_PASS(%u, %d) = %u != %x\n"PNG_PASS_ROWS(%u, %d) = %u != %x
"PNG_PASS_ROWS(%u, %d) = %u != %x\n"signumPNG_PASS_COLS(%u, %d) = %u != %x
"PNG_PASS_COLS(%u, %d) = %u != %x\n"2147483646png_pass_colstilescolsconst png_byte[8]const png_byte[8][8]unsigned char[8][8]const png_byte(*)[8]unsigned char(*)[8]png_pass_rowspng_col_in_interlace_passpng_row_in_interlace_passpng_col_from_pass_colpng_row_from_pass_rowpng_pass_col_shiftbaseinc2540xfe2530xfdpng_pass_row_shiftpng_pass_start_colpng_pass_start_rowperform_gamma_testcalculations_use_input_precisionmaxout8Gamma correction error summary

"Gamma correction error summary\n\n"The printed value is the maximum error in the pixel values
"The printed value is the maximum error in the pixel values\n"calculated by the libpng gamma correction code.  The error
"calculated by the libpng gamma correction code.  The error\n"is calculated as the difference between the output pixel
"is calculated as the difference between the output pixel\n"char[58]value (always an integer) and the ideal value from the
"value (always an integer) and the ideal value from the\n"char[56]libpng specification (typically not an integer).

"libpng specification (typically not an integer).\n\n"Expect this value to be less than .5 for 8 bit formats,
"Expect this value to be less than .5 for 8 bit formats,\n"less than 1 for formats with fewer than 8 bits and a small
"less than 1 for formats with fewer than 8 bits and a small\n"number (typically less than 5) for the 16 bit formats.
"number (typically less than 5) for the 16 bit formats.\n"For performance reasons the value for 16 bit formats
"For performance reasons the value for 16 bit formats\n"char[54]increases when the image file includes an sBIT chunk.
"increases when the image file includes an sBIT chunk.\n""sBIT"
Gamma correction with 16 to 8 bit reduction:
"\nGamma correction with 16 to 8 bit reduction:\n"char[47] 16 bit gray:  %.5f
" 16 bit gray:  %.5f\n" 16 bit color: %.5f
" 16 bit color: %.5f\n""background"do_backgroundALPHA_MODE_OFFSETalpha mode"alpha mode"summarize_gamma_errors
Gamma correction with %s:
"\nGamma correction with %s:\n"
Basic gamma correction:
"\nBasic gamma correction:\n" 2 bit gray: " 2 bit gray: " 4 bit gray: " 4 bit gray: " 8 bit gray: " 8 bit gray: " 8 bit color:" 8 bit color:" indexed:    " indexed:    "16 bit gray: "16 bit gray: "16 bit color:"16 bit color:"print_one-1.0-1. %s %.5f
" %s %.5f\n"init_gamma_errorsperform_gamma_composition_testscolour_typepalette_numberconst doublegamma_composition_testbgchar[128]4.0 bckg(Screen):" bckg(Screen):" bckg(File):" bckg(File):" bckg(Unique):" bckg(Unique):"3.0 alpha(PNG)" alpha(PNG)" alpha(Porter-Duff)" alpha(Porter-Duff)" alpha(Optimized)" alpha(Optimized)"xInyInpmwholow_bit_depthindexedleaderexpand_16interlace_typeuse_input_precision alpha(Broken)" alpha(Broken)"50005000.01.000000000000000082e-050.05000000000000000278193sizeof namegamma "gamma "->"->",",")^")^"perform_gamma_scale16_testsperform_gamma_sbit_testssbitREAD_BDHI1<<READ_BDHI(1<<READ_BDHI)npaletteperform_gamma_transform_testsgamma_transform_testsbit("sbit(") ") "16to8 "16to8 "perform_gamma_threshold_teststest_gamma 1.00.4000000000000000222.40.9499999999999999556.95gamma_threshold_testthreshold "threshold "/"/"gamma_test&pmIn->thisfaultcolour_typeInbit_depthInpalette_numberIninterlace_typeIngamma_display *((fault) = the_exception_context->v.etmp, 0)pigama_modsrgb_modsbit_modpng_modification *gama_modification *srgb_modification *127sbit_modification *standard_display *%d bit %s %s: max error %f (%.2g, %2g%%)
"%d bit %s %s: max error %f (%.2g, %2g%%)\n"const char *[8]char *[8]100.0bad bit depth (internal: 1)"bad bit depth (internal: 1)"bad bit depth (internal: 2)"bad bit depth (internal: 2)"scale16pmInfile_gammaInscreen_gammaInsbitInthreshold_testInuse_input_precisionInscale16Inexpand16Indo_backgroundInbkgd_colorInbkgd_gammaIn(void *)faultgamma_endgamma_display*png_get_progressive_ptr(pp)gamma_image_validateconst png_storeconst png_store *psin_ctin_bdwhcbRowout_ctout_bdsamples_per_pixelprocessingconst store_palette_entryconst store_palette_entry *store_palette_entry *in_palettein_is_transparentprocess_tRNSout_npaletteout_is_transparentout_palettevivalidate_info *pRowstdin_indexout_indexinput_alphaoutput_alpha65536const validate_infoconst validate_info *"gray""red""green""blue"gamma: below threshold row %lu changed"gamma: below threshold row %lu changed"gamma_component_validateisbitsbit_maxoutmaxencoded_sampleencoded_errorinput_samplees_loes_hicomposeoutput_is_encodedlog_max_errortcomposeless than maxout:
"less than maxout:\n"percentage_errortmplow_valuehigh_valuewithin digitization limits:
"within digitization limits:\n"is_lois_hiSBIT_ERRORwithin input precision limits:
"within input precision limits:\n"precisionuse_inputuse_backgrounddo_compose
	"\n\t"internal error (compose)"internal error (compose)", sbit(", sbit("ppInidod): "): "^"^"[linear]"[linear]"*(alpha)"*(alpha)"(background)"(background)"*"*" =
	" =\n\t" = " = " (libpng: " (libpng: " ^" ^"(to screen) ="(to screen) =" [screen is linear] =" [screen is linear] ="
	[overall:"\n\t[overall:"(gamma correction) ="(gamma correction) =" [no gamma correction] =" [no gamma correction] ="]"]" < " < "gamma_component_composeinit_validate_infoconst png_modifierconst png_modifier *bg_inversegamma_infogamma_info_impsggamma_display_initdo_read_interlacesizeof dp->background_colorperform_transform_testpm->interlace_typebase_postransform:"transform:"const image_transformconst image_transform *image_transform *const image_transform **image_transform **image_transform_add +" +"image_transform *constimage_transform_test_counterimage_transform_reset_counttransform_disablepngvalid: --transform-disable=%s: unknown transform
"pngvalid: --transform-disable=%s: unknown transform\n"transform_enableall_disabledfound_itpngvalid: --transform-enable=%s: unknown transform
"pngvalid: --transform-enable=%s: unknown transform\n"image_transform_png_set_shift_addimage_transform_png_set_shift_modimage_pixel *const transform_displayconst transform_display *transform_display *shiftimage_transform_png_set_shift_setimage_transform_png_set_packswap_addimage_transform_png_set_packswap_modimage_transform_png_set_packswap_setimage_transform_png_set_packing_addimage_transform_png_set_packing_modimage_transform_png_set_packing_setimage_transform_png_set_add_alpha_addimage_transform_png_set_add_alpha_modadd_alphamaxin_depthout_depththreshold_testexpand16pointer_to_the_background_colorthissizeof_namethatimage_transform_png_set_add_alpha_setimage_transform_png_set_filler_addimage_transform_png_set_filler_modimage_transform_png_set_filler_setimage_transform_png_set_swap_addimage_transform_png_set_swap_modimage_transform_png_set_swap_setimage_transform_png_set_swap_alpha_addimage_transform_png_set_swap_alpha_modimage_transform_png_set_swap_alpha_setimage_transform_png_set_bgr_addimage_transform_png_set_bgr_modimage_transform_png_set_bgr_setimage_transform_png_set_invert_alpha_addimage_transform_png_set_invert_alpha_modimage_transform_png_set_invert_alpha_setimage_transform_png_set_background_modconst standard_displayconst standard_display *alf2.220446049250313081e-16DBL_EPSILONimage_transform_png_set_background_setrandom_bytesexpandpng_byte(*)[8]const image_pixelconst image_pixel *image_transform_png_set_rgb_to_gray_addimage_transform_png_set_rgb_to_gray_modrlocalc_depthrhigloghiblobhirgb_to_graygamma_depthpow(rlo, power)-absepow(rhi, power)+absepow(glo, power)-absepow(ghi, power)+absepow(blo, power)-absepow(bhi, power)+abserlo * (data.red_coefficient-ce) + glo * (data.green_coefficient-ce) + blo * (data.blue_coefficient-ce)rlo * (image_transform_data_rgb_to_gray.red_coefficient-ce) + glo * (image_transform_data_rgb_to_gray.green_coefficient-ce) + blo * (image_transform_data_rgb_to_gray.blue_coefficient-ce)do_roundrhi * (data.red_coefficient+ce) + ghi * (data.green_coefficient+ce) + bhi * (data.blue_coefficient+ce)rhi * (image_transform_data_rgb_to_gray.red_coefficient+ce) + ghi * (image_transform_data_rgb_to_gray.green_coefficient+ce) + bhi * (image_transform_data_rgb_to_gray.blue_coefficient+ce)pow(graylo, power)sample_depthpow(grayhi, power)isgraygraylograyhi0.9999999999999997781.000000000000000222powerabsece2.02.32768.06.103515625e-052. / 32768rgb_to_gray error "rgb_to_gray error " exceeds limit " exceeds limit "image_transform_png_set_rgb_to_gray_setrXrYrZgXgYgZbXbYbZYZmaxeelointernal pngvalid cHRM coefficient error"internal pngvalid cHRM coefficient error"red(X)red(Y)red(Z)green(X)green(Y)green(Z)blue(X)blue(Y)blue(Z)1E-5FPAPI_form cHRM " cHRM " error: " error: " -> " -> "image_transform_png_set_rgb_to_gray_iniwhiteY69686968.032768.0.2126464843756968 / 32768.2343423434.00.7151489257812523434 / 32768.23662366.00.072204589843752366 / 32768.rutotal0xffff8.08.6.06.0.0078431372549019606752.0/2550.0040000000000000000834E-3image_transform_png_set_strip_alpha_addimage_transform_png_set_strip_alpha_modimage_transform_png_set_strip_alpha_setimage_transform_png_set_strip_16_addimage_transform_png_set_strip_16_modimage_transform_png_set_strip_16_setimage_transform_png_set_scale_16_addimage_transform_png_set_scale_16_modimage_transform_png_set_scale_16_setimage_transform_png_set_expand_16_addimage_transform_png_set_expand_16_modimage_transform_png_set_expand_16_setimage_transform_png_set_expand_gray_1_2_4_to_8_addimage_transform_png_set_expand_gray_1_2_4_to_8_modimage_transform_png_set_expand_gray_1_2_4_to_8_setimage_transform_png_set_expand_addimage_transform_png_set_expand_modimage_transform_png_set_expand_setimage_transform_png_set_gray_to_rgb_addimage_transform_png_set_gray_to_rgb_modimage_transform_png_set_gray_to_rgb_setimage_transform_png_set_tRNS_to_alpha_addimage_transform_png_set_tRNS_to_alpha_modimage_transform_png_set_tRNS_to_alpha_setimage_transform_png_set_palette_to_rgb_addimage_transform_png_set_palette_to_rgb_modimage_transform_png_set_palette_to_rgb_setimage_transform_default_addimage_transform_default_initransform_testfull_namesizeof full_nametransform_endtransform_display*transform_image_validatered_sBITgreen_sBITblue_sBITalpha_sBIThave_tRNSdigitization_errorunexpected change in palette size"unexpected change in palette size"in_sample_depth940x5esizeof out_palette128.5.5 * 257in_pixelout_pixelunexpected transformed palette index"unexpected transformed palette index"red/gray"red/gray"transform_range_checkin_minin_maxerr > limit ||sizeof message output value error: rgba(" output value error: rgba(" expected: " expected: " (" ("..".."transform_info_impinvalid final bit depth: colour type("invalid final bit depth: colour type(") with bit depth: ") with bit depth: "test_pixelsizeof test_pixelcolour type "colour type " expected " expected "bit depth "bit depth "pngvalid: internal: palette sample depth not 8"pngvalid: internal: palette sample depth not 8"pngvalid: internal: bad unpacked pixel depth"pngvalid: internal: bad unpacked pixel depth"internal: sample depth "internal: sample depth "internal: bit depth "internal: bit depth "transform_display_init1288idIntransform_listInin_digitizedtransform_listimage_transform_mod_endscalesample_scaleimage_transform_set_endimage_transform_ini_endtransform_set_encodingchrm_modification *image_pixel_add_alphaimage_pixel_convert_PLTEimage_pixel_initswap16littleendianimage_pixel_setfperform_size_testtest_sizeconst png_byte[]unsigned char[]hincwincsave_bdloDEPTH(bdlo)((png_byte)(1U << (bdlo)))bdloconst png_byte[5]perform_standard_testtest_standardstandard_testpsInpngvalid progressive deinterlacer"pngvalid progressive deinterlacer"pngvalid sequential deinterlacer"pngvalid sequential deinterlacer"progressive reader"progressive reader"sequential reader"sequential reader"image read failed silently"image read failed silently"standard_endstandard_display*10518standard_image_validatestandard_row_validatewhere178sizeof stdPNG image row[%lu][%d] changed from %.2x to %.2x"PNG image row[%lu][%d] changed from %.2x to %.2x"char[49]display row[%lu][%d] changed from %.2x to %.2x"display row[%lu][%d] changed from %.2x to %.2x"standard_text_validatetpimage name"image name"png_store_file *FILE_NAME_SIZEend marker"end marker"end"end"expected two text items, got %lu"expected two text items, got %lu"standard_check_texttext: "text: "okcompression [%d->%d], "compression [%d->%d], "keyword ""keyword \""", "\", "null, "null, "text lost, "text lost, "text length changed[%lu->%lu], "text length changed[%lu->%lu], "text becomes ""text becomes \""" (was ""\" (was \"""), "\"), "iTXt length set, "iTXt length set, "iTXt language ""iTXt language \""iTXt keyword ""iTXt keyword \""sequential_rowdo_interlace1970xc5sizeof row920x5csizeof displayprogressive_rowdp->wpng_get_current_row_number is broken"png_get_current_row_number is broken"png_get_current_pass_number is broken"png_get_current_pass_number is broken"invalid y to progressive row callback"invalid y to progressive row callback"sample_valuefor_backgroundrMaxgMaxbMaxaMaxbdhiuse_update_infoiImageiDisplaycheck_endkeywordmissing row in progressive de-interlacing"missing row in progressive de-interlacing"standard_infostandard_info_impstandard_info_part2bad png_get_rowbytes calculation"bad png_get_rowbytes calculation"standard_info_part1validate: bit depth changed"validate: bit depth changed"validate: color type changed"validate: color type changed"validate: filter type changed"validate: filter type changed"validate: interlacing changed"validate: interlacing changed"validate: compression type changed"validate: compression type changed"validate: image width changed"validate: image width changed"validate: image height changed"validate: image height changed"sBIT_invalidvalidate: unexpected png_get_sBIT result"validate: unexpected png_get_sBIT result"validate: sBIT value out of range"validate: sBIT value out of range"validate: row size changed"validate: row size changed"validate: unexpected png_get_tRNS (color) result"validate: unexpected png_get_tRNS (color) result"validate: unexpected png_get_tRNS result"validate: unexpected png_get_tRNS result"validate: invalid tRNS chunk with alpha image"validate: invalid tRNS chunk with alpha image"validate: file changed interlace type"validate: file changed interlace type"standard_palette_validatevalidate: palette transparency changed"validate: palette transparency changed"validate: palette size changed: "validate: palette size changed: "validate: PLTE or tRNS chunk changed"validate: PLTE or tRNS chunk changed"read_palettepalvalidate: invalid PLTE count"validate: invalid PLTE count"126sizeof *palettevalidate: invalid PLTE result"validate: invalid PLTE result"113sizeof (store_palette)validate: unexpected png_get_tRNS (palette) result"validate: unexpected png_get_tRNS (palette) result"55standard_palette_initstandard_display_init1112internal: bad bit depth"internal: bad bit depth"dp->interlace_typesizeof dp->transparentsizeof dp->paletteperform_formatting_testcorrect29 Aug 2079 13:53:60 +0000"29 Aug 2079 13:53:60 +0000"timestringptlibpng formatting test"libpng formatting test"20795360png_convert_to_rfc1123_buffer failed"png_convert_to_rfc1123_buffer failed"png_convert_to_rfc1123_buffer("png_convert_to_rfc1123_buffer(") returned: '") returned: '"'"'"perform_error_testsizeof pm->this.testerror test"error test"WRITE_BDHImake_errorserror_testdo_own_interlaceconst struct <unnamed>const struct <unnamed>[2]struct <unnamed>[2]const struct <unnamed> *ARRAY_SIZE(error_test)make_errorexception_prev_1exception_env_1row size incorrect"row size incorrect"write: png_set_interlace_handling failed"write: png_set_interlace_handling failed"sBIT_error_fnbadsBIT0_error_fnstandard_rowmake_size_imagessizeof ps->testmake size images"make size images"make_sizemake_size_imagepixel_sizesizeof copysize row size incorrect"size row size incorrect"png_byte[128]unsigned char[128]SIZE_ROWMAXpng_byte[16][128]unsigned char[16][128]png_byte(*)[128]unsigned char(*)[128]sizeof imagetempRowsizeof tempRowcommentsizeof comment(sizeof comment)(sizeof comment)-1size_row1650xA5make_transform_imagesmake standard images"make standard images"make_transform_imagetransform row size incorrect"transform row size incorrect"choose_random_filter120248256Udeinterlace_rowxinxoutxstepinterlace_rowtransform_row128/8nImagesbit_widthimageRow128/4128/2internal error"internal error"standard_rowsizestandard_heightstandard_widthCOL_FROM_ID(id)DEPTH_FROM_ID(id)transform_heighttransform_rowsizeTRANSFORM_WIDTHbit_sizeinvalid color type"invalid color type"npasses_from_interlace_typeinvalid interlace type"invalid interlace type"set_random_tRNSinit_standard_paletteppalpng_color[256]png_color_struct[256]42make_standard_palettepalette_seedpng_byte[256][4]unsigned char[256][4]valuespng_byte(*)[4]unsigned char(*)[4]255Uneedsizeof need(sizeof need)(sizeof need)-2selector22715604810x87654321sbit_modification_init19293798404325376193370521618688193372390419337239881342177280498073613471580162150413471795201347179589sbit_modifyunexpected colour type in sBIT modification"unexpected colour type in sBIT modification"srgb_modification_initsrgb_modify537395219347537921817619347719681934772034chrm_modification_initwhite1660944384471859216656629762099216656839681665684045chrm_modify36gama_modification_init1728053248425984017323130881971217323328001732332865gama_modifyset_modifier_for_readmodifier_startmodifier_progressive_readpng_store_buffer *store state damaged (progressive)"store state damaged (progressive)"noisecbAvailpng_byte[512]unsigned char[512]9-5(9-5)5110x1ffprogressive read implementation error"progressive read implementation error"modifier_readpng_modifier*png_get_io_ptr(pp)bad modifier_read call"bad modifier_read call"modifier_read_imppm->bufferpm->buffer+4lenmod137signinvalid PNG file signature"invalid PNG file signature"modifier_signature13+12122473676812294553601740812294727681229472850invalid IHDR"invalid IHDR"8+88+8+1modifier_IHDR445644812291932161664012292098561229209940452198412292587521996812292787201229278788sizeof pm->buffermodifier_setbuffermodifier_crcdatalencrcconst Bytefconst Bytef *modifier_color_encoding_is_setmodifier_color_encoding_is_sRGBmodifier_set_encodingmodifier_resetmodifier_encoding_iteratemodifier_total_encodingssafecat_current_encoding[overridden]"[overridden]"modifier_current_encodingsizeof *cemodification_initsizeof *pmmmodification_resetoutput_quantization_factoroutlog256.065536.0outerr0.731820000000000026.731820.231820000000000026.73182-.50.9064400000000000235.906440.4064400000000000235.90644-.5pcerr0.01000000000000000021.01calcerrabserrdigitizedigitization_factormodifier_init2640sizeof *pmsafecat_color_encodingR("R("),G("),G("),B("),B("do_tRNSmeintentencodinggammadppistpmmvalueencoding_gammanormalize_color_encodingwhite_pointchromaticity_ychromaticity_xstore_deletepng_store_file **set_store_for_readread store already in use"read store already in use"store_pool *png_create_read_struct returned NULL (unexpected)"png_create_read_struct returned NULL (unexpected)"char[50]optpng option invalid"png option invalid"store_read_set0UL: file not found": file not found"store_read_resetset_store_for_writewrite store already in use"write store already in use"sizeof ps->wnamestore_write_resetstore_freestore_pool*png_get_mem_ptr(pp)poolstore_memory*store_memory *store_memory **bad pointer to free"bad pointer to free"store_mallocmalloc(cb + (sizeof *new) + (sizeof pool->mark))newsizeof new->marksizeof pool->markout of memory"out of memory"store_pool_delete%s: %s %s: memory lost (list follows):
"%s: %s %s: memory lost (list follows):\n"read"read"unknown file"unknown file"	%lu bytes @ %p
"\t%lu bytes @ %p\n"%s: %s %s: memory counter mismatch (internal error)
"%s: %s %s: memory counter mismatch (internal error)\n"store_memory_freememory corrupted (pool)"memory corrupted (pool)"sizeof memory->markmemory corrupted (start)"memory corrupted (start)"memory corrupted (size)"memory corrupted (size)"memory corrupted (end)"memory corrupted (end)"store_pool_errorstore_current_paletteno current stream for palette"no current stream for palette"store_write_paletteattempt to write palette without write stream"attempt to write palette without write stream"multiple store_write_palette calls"multiple store_write_palette calls"store_palette_entry*malloc(npalette * sizeof *ps->palette)store new palette: OOM"store new palette: OOM"store_progressive_readstore_readpng_store*bad store read call"bad store read call"store_read_chunkchunklenchunktypechunkposbuffer+4U12UIDAT_posIDAT_lenIDAT_sizerandom13U4Uinternal: IDAT size mismatch"internal: IDAT size mismatch"9006628140x35af061e0xffU(uInt)-1internal: missing IDAT data"internal: missing IDAT data"internal: missing IDAT"internal: missing IDAT"store_read_impstore state damaged"store state damaged"png_byte[500]unsigned char[500]500STORE_BUFFER_SIZEread beyond end of file"read beyond end of file"store_read_buffer_nextpbOldpbNewbuffer lost"buffer lost"store_read_buffer_availbuffer read error"buffer read error"store_read_buffer_sizestore_flushstore_writewritepos0x7fffffffUunexpected write size"unexpected write size"0xffffffffUchunk length too great"chunk length too great"pngvalid internal image too large"pngvalid internal image too large"invalid chunk type"invalid chunk type"valid_chunktype65U9090U9797U122Ustore_image_check2370xedimage overwrite"image overwrite"190239row start overwritten"row start overwritten"222173row end overwritten"row end overwritten"store_ensure_imagemalloc(cb+2)OOM allocating image buffer"OOM allocating image buffer"store_image_freepng_store image overwrite (1)"png_store image overwrite (1)"png_store image overwrite (2)"png_store image overwrite (2)"store_image_rowcoffsetno allocated image"no allocated image"image too small"image too small"store_warningpng_get_error_ptr(pp)store_errorinternal_errorstore_logsizeof ps->errorerror: "error: "warning: "warning: "store_verbosestore_messageread: "read: "const char[3]write: "write: "pngvalid: "pngvalid: "store_storefilestorefile: incomplete write"storefile: incomplete write"png_store_file*malloc(sizeof *pf)624storefile: OOM"storefile: OOM"sizeof pf->namestorefile: 0 sized IDAT"storefile: 0 sized IDAT"bits_of0xffff0000U16U0xff00U0xf0U0xcU0x2Ustore_freefilestore_storenewpng_store_buffer*malloc(sizeof *pb)store new: OOM"store new: OOM"store_freenewstore_freebufferstore_init1344sizeof *ps&ps->exception_contextstore_pool_initsizeof *poolrandom_32markstore_pool_markstore_seed0x12345678pixel_cmprow_copypixel_copydestMaskdestBytesourceBytesamplebit_index2+4(2+4)next_format*bit_depthpnstandard_name_from_idstandard_name["["+tRNS"+tRNS" bit" bit" interlaced" interlaced"(pngvalid)"(pngvalid)"(libpng)"(libpng)""x"random_choicerandom_modrandom_u32b4sizeof b4random_u16unsigned char[2]b2sizeof b2random_byteunsigned char[1]b1sizeof b1randomize_bytesrandom_seed14507445080x56789abc0xdmake_four_random_bytesmincRowsnImageis_errorprefixppfpatoBufferfromBufferbitWidthtoIndexfromIndexpixelSizesample_indexlow_depth_grayfix100000.0safecatdnumber%.*f"%.*f"safecatn%d"%d"safecatvalidate_infogamma_displaytransform_displayimage_transformimage_pixelstandard_displaysbit_modificationsrgb_modificationchrm_modificationgama_modificationpng_modificationpng_modifiercolor_encodingCIE_colormodifier_statestore_memorypng_storestore_palette_entry[256]store_palettestore_poolpng_store_filestore_palette_entrypng_store_bufferexception_contextstruct png_store*outquantmaxout_totalmaxoutmaxcalcmaxpcmaxabsbackground_bluebackground_greenbackground_redscreen_inversefile_inversegamma_correctionisbit_shiftmaxerrabsmaxerrpcmaxerroutcoefficients_overriddenblue_coefficientgreen_coefficientred_coefficientgreen_to_setred_to_setgammasetinichrm_modunpackedoutput_bit_depthoutput_colour_typemax_gamma_8local_useglobal_useenablealphaeblueegreeneredealphafbluefgreenfredfmono_invertedalpha_invertedalpha_firstswap_rgbpalette_indextransparentspeedhas_tRNSis_transparentfnbybxgygxryrxwywxbuffer_positionbuffer_countflushlogtest_lbg_gamma_compositiontest_lbg_gamma_sbittest_lbg_gamma_transformtest_lbg_gamma_thresholdtest_lbgtest_exhaustivetest_gamma_expand16test_gamma_alpha_modetest_gamma_backgroundtest_gamma_scale16test_gamma_sbittest_gamma_transformtest_gamma_thresholdassume_16_bit_calculationsuse_input_precision_16to8use_input_precision_sbittest_tRNStest_transformerror_indexederror_color_16error_color_8error_gray_16error_gray_8error_gray_4error_gray_2log16log8maxpc16maxcalcGmaxcalc16maxabs16maxout16maxpc8maxcalc8maxabs8sbitlowtest_uses_encodingrepeatencoding_ignoredencoding_countercurrent_encodingnencodingsencodingscurrent_gammangamma_testsngammaspending_chunkpending_lenstatemodificationsremovedaddedmodifiedmodify_fnetmpwrite_memory_poolwnamepiwritepwritesavedread_memory_poolmax_totalmax_limitmax_maxstoreimage_hIDAT_crccb_rowcb_imagereadposprevdatacountIDAT_bitspireadpreadnoptionsnwarningsnerrorsvalidatedprogressivesaw_warningexpect_warningexpect_errortreat_warnings_as_errorsverbosecaughtpenvconst color_encoding[]color_encoding[]0.45454545454545453031/2.20.41239079926595900720.4123907992659590.21263900587150999510.2126390058715100.019330818715591998460.0193308187155920.35758433938387801380.3575843393838780.71516867876775602750.7151686787677560.11919477979462600460.1191947797946260.18048078840183401360.1804807884018340.072192315360734005130.0721923153607340.95053215224966003390.9505321522496601.6000000000000000891.60.6251/1.60.79776048967230295260.7977604896723030.28807112822929298310.2880711282292930.0000000000000000.1351858371757400090.1351858371757400.71184321781010195810.7118432178101020.031349349581525000340.0313493495815258.56539606050000054e-050.0000856539606050.82510460251046002790.82510460251046051.051.0.1992187551./2562.199218752+51./256(2+51./256)0.45470692717584371151/(2+51./256)0.57666904291013099120.5766690429101310.29734497525053599220.2973449752505360.02703136138641199990.0270313613864120.18555823790654599190.1855582379065460.62736356625546596530.6273635662554660.070688852535827004230.0706888525358270.18822864623499499510.1882286462349950.075291458493998000830.0752914584939980.99133753683763903290.9913375368376390.71650071677938598210.7165007167793860.25872824304011299290.2587282430401130.10102057439747699760.1010205743974770.72468231494856605310.7246823149485660.051211818965387997940.0512118189653880.1467743852527050030.1467743852527050.016589442011320999080.0165894420113210.77389278354507295980.7738927835450730.65909090909090906061.45/2.21.000000000000000adam7image_transform_firstimage_transform_shiftpackswapimage_transform_data_shiftimage_transform_packswappackingimage_transform_packingimage_transform_add_alphaimage_transform_data_add_alphaimage_transform_fillerswapimage_transform_data_fillerimage_transform_swapswap_alphaimage_transform_swap_alphabgrimage_transform_bgrinvert_alphaimage_transform_invert_alphaimage_transform_backgroundimage_transform_data_backgroundimage_transform_rgb_to_graystrip_alphaimage_transform_data_rgb_to_grayimage_transform_strip_alphastrip_16image_transform_strip_16scale_16image_transform_scale_16image_transform_expand_16expand_gray_1_2_4_to_8image_transform_expand_gray_1_2_4_to_8image_transform_expandgray_to_rgbimage_transform_gray_to_rgbtRNS_to_alphaimage_transform_tRNS_to_alphapalette_to_rgbimage_transform_palette_to_rgbimage_transform_end(end)"(end)"const struct <unnamed>[]sBIT(0): failed to detect error"sBIT(0): failed to detect error"sBIT(too big): failed to detect error"sBIT(too big): failed to detect error"colour_typesgrayscale"grayscale"const char[8]truecolour"truecolour"indexed-colour"indexed-colour"grayscale with alpha"grayscale with alpha"truecolour with alpha"truecolour with alpha"sepinvalid"invalid"SBIT_16_TO_8PTITSTRUCT(shift)ITDATA(shift)ITSTRUCT(packswap)ITSTRUCT(packing)ITSTRUCT(add_alpha)ITDATA(add_alpha)ITSTRUCT(filler)ITDATA(filler)ITSTRUCT(swap)ITSTRUCT(swap_alpha)ITSTRUCT(bgr)ITSTRUCT(invert_alpha)ITSTRUCT(background)image_transform_png_set_background_addITDATA(background)image_transform_iniITSTRUCT(rgb_to_gray)DUDDDU(v,d,r)(digitize(v*(1+DBL_EPSILON), d, r) * (1+DBL_EPSILON))DD(v,d,r)(digitize(v*(1-DBL_EPSILON), d, r) * (1-DBL_EPSILON))CHECK(col,x){ double err = fabs(o.col.x - e.col.x); if (err > maxe) { maxe = err; el = #col "(" #x ")"; } }API_cvt(x)(x)API_type"FP"API_functionITDATA(rgb_to_gray)ITSTRUCT(strip_alpha)ITSTRUCT(strip_16)ITSTRUCT(scale_16)ITSTRUCT(expand_16)ITSTRUCT(expand_gray_1_2_4_to_8)ITSTRUCT(expand)ITSTRUCT(gray_to_rgb)ITSTRUCT(tRNS_to_alpha)ITSTRUCT(palette_to_rgb)ITSTRUCT(end)IT(name)static image_transform ITSTRUCT(name) ={ #name, 1, &PT, 0, 0, 0, image_transform_ini, image_transform_png_set_ ## name ## _set, image_transform_png_set_ ## name ## _mod, image_transform_png_set_ ## name ## _add}ITDATA(name)image_transform_data_ ## nameITSTRUCT(name)image_transform_ ## nameTEXT_COMPRESSIONCAN_WRITE_INTERLACEset_write_interlace_handling(pp,type)png_set_interlace_handling(pp)check_interlace_type(type)((void)(type))INTERLACE_LASTDEPTH(bd)((png_byte)(1U << (bd)))transform_width(pp,colour_type,bit_depth)SIZE_HEIGHTMAXSTANDARD_ROWMAX(16*8U)(TRANSFORM_WIDTH*8U)128UDIGITIZEPNG_LIBPNG_VER != 10700PALETTE_COUNT(bit_depth)((bit_depth) > 4 ? 1U : 16U)DO_16BITHEIGHT_FROM_ID(id)(((id)>>24) & 0xff)WIDTH_FROM_ID(id)(((id)>>16) & 0xff)DO_INTERLACE_FROM_ID(id)((int)(((id)>>15) & 1))INTERLACE_FROM_ID(id)((png_byte)(((id) >> 13) & 0x3))PALETTE_FROM_ID(id)(((id) >> 8) & 0x1f)((png_byte)(((id) >> 3) & 0x1fU))((png_byte)((id)& 0x7U))FILEID(col,depth,palette,interlace,width,height,do_interlace)((png_uint_32)((col) + ((depth)<<3) + ((palette)<<8) + ((interlace)<<13) + (((do_interlace)!=0)<<15) + ((width)<<16) + ((height)<<24)))R8(this)randomize_bytes(&(this), sizeof (this))gnu_volatile(x)is_gnu_patch(major,minor,patch)is_gnu(major,minor) && __GNUC_PATCHLEVEL__ == 0is_gnu(major,minor)(defined __GNUC__) && __GNUC__ == (major) && __GNUC_MINOR__ == (minor)((unsigned int)((sizeof (a))/(sizeof (a)[0])))context(ps,fault)anon_context(ps); png_store *faultanon_context(ps)struct exception_context *the_exception_context = &(ps)->exception_contextCHUNK_sRGBCHUNK(115,82,71,66)CHUNK(115,66,73,84)CHUNK_gAMACHUNK(103,65,77,65)CHUNK_cHRMCHUNK(99,72,82,77)CHUNK_IENDCHUNK(73,69,78,68)CHUNK_IDATCHUNK(73,68,65,84)CHUNK_PLTECHUNK(80,76,84,69)CHUNK_IHDRCHUNK(73,72,68,82)CHUNK(a,b,c,d)(((a)<<24)+((b)<<16)+((c)<<8)+(d))debugonly(something)somethingRELEASE_BUILD(PNG_LIBPNG_BUILD_BASE_TYPE >= PNG_LIBPNG_BUILD_RC)FE_OVERFLOWFE_INVALIDFE_DIVBYZERO_DEFAULT_SOURCE_BSD_SOURCE_GNU_SOURCE_ISOC99_SOURCE_POSIX_SOURCEHAVE_FEENABLEEXCEPTPNG_ZLIB_HEADERdefined PNG_WRITE_SUPPORTED && (defined PNG_PROGRESSIVE_READ_SUPPORTED) && (defined PNG_FIXED_POINT_SUPPORTED || defined PNG_FLOATING_POINT_SUPPORTED)PNG_READ_TRANSFORMS_SUPPORTEDdefined PNG_READ_SUPPORTED || defined PNG_WRITE_tRNS_SUPPORTED || defined PNG_WRITE_FILTER_SUPPORTEDdefined PNG_READ_RGB_TO_GRAY_SUPPORTED || defined PNG_READ_FILLER_SUPPORTEDdefined PNG_READ_TRANSFORMS_SUPPORTED || defined PNG_WRITE_FILTER_SUPPORTED(defined PNG_READ_RGB_TO_GRAY_SUPPORTED) || (defined PNG_READ_FILLER_SUPPORTED)PNG_WRITE_16BIT_SUPPORTEDPNG_READ_16BIT_SUPPORTEDdefined PNG_READ_TRANSFORMS_SUPPORTED && defined PNG_READ_cHRM_SUPPORTEDPNG_WRITE_tRNS_SUPPORTEDPNG_LIBPNG_VER == 10700 || defined PNG_WRITE_INTERLACING_SUPPORTEDPNG_READ_INTERLACING_SUPPORTEDPNG_WRITE_FILTER_SUPPORTEDdefined(PNG_READ_zTXt_SUPPORTED) && defined(PNG_WRITE_zTXt_SUPPORTED)defined PNG_READ_EXPAND_SUPPORTED || defined PNG_READ_GRAY_TO_RGB_SUPPORTED || defined PNG_READ_EXPAND_SUPPORTED || defined PNG_READ_EXPAND_16_SUPPORTED || defined PNG_READ_BACKGROUND_SUPPORTEDPNG_READ_ACCURATE_SCALE_SUPPORTEDPNG_FLOATING_POINT_SUPPORTED!RELEASE_BUILDPNG_READ_FILLER_SUPPORTEDPNG_READ_INVERT_MONO_SUPPORTEDTHIS_IS_THE_PROFORMAPNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED(defined PNG_READ_BACKGROUND_SUPPORTED) || (defined PNG_READ_ALPHA_MODE_SUPPORTED)defined PNG_MAX_GAMMA_8 || PNG_LIBPNG_VER != 10700defined(PNG_READ_BACKGROUND_SUPPORTED) || defined(PNG_READ_ALPHA_MODE_SUPPORTED)PNG_EXTENSIONSdefined(PNG_FLOATING_ARITHMETIC_SUPPORTED)/* write or low level APIs not supported *//* This is required because some very minimal configurations do not use it:
    *//* Success case. *//* Error exit if there are any errors, and maybe if there are any
    * warnings.
    *//* Do this here to provoke memory corruption errors in memory not directly
    * allocated by libpng - not a complete test, but better than nothing.
    *//* PNG_READ_TRANSFORMS_SUPPORTED *//* Combinatorial transforms: *//* Various oddly sized images: *//* Perform the standard and gamma tests. *//* Make useful base images *//* Nothing to test so turn everything off: *//* Make this do all the tests done in the test shell scripts with the same
       * parameters, where possible.  The limitation is that all the progressive
       * read and interlace stuff has to be done in separate runs, so only the
       * basic 'standard' and 'size' tests are done.
       *//* If pngvalid is run with no arguments default to a reasonable set of the
    * tests.
    *//* consumed an extra *argv *//* PNG_SET_OPTION_SUPPORTED *//* Syntax of the argument is <option>:{on|off} *//* !CAN_WRITE_INTERLACE *//* Can call multiple times *//* composition *//* Just do two gamma tests here (2.2 and linear) for speed: *//* NOTE: this is the default! *//* Record each argument for posterity: *//* Set if the argument has an argument. *//* Now parse the command line options. *//* I.e., 1/200% - 1/20000 *//* NOTE: this is a reasonable perceptual limit. We assume that humans can
    * perceive light level differences of 1% over a 100:1 range, so we need to
    * maintain 1 in 10000 accuracy (in linear light space), which is what the
    * following guarantees.  It also allows significantly higher errors at
    * higher 16 bit values, which is important for performance.  The actual
    * maximum 16 bit error is about +/-1.9 in the fixed point implementation but
    * this is only allowed for values >38149 by the following:
    *//* +/-1 in 16 bits for compose errors *//* 1/20000 *//* Error in *encoded* value *//* I.e., .499% fractional error *//* +/-1 in 8 bits for compose errors *//* Arithmetic error in *encoded* value *//* Some default values (set the behavior for 'make check' here).
    * These values simply control the maximum error permitted in the gamma
    * transformations.  The practical limits for human perception are described
    * below (the setting for maxpc16), however for 8 bit encodings it isn't
    * possible to meet the accepted capabilities of human vision - i.e. 8 bit
    * images can never be good enough, regardless of encoding.
    *//* because libpng now rounds sBIT *//* The following allows results to pass if they correspond to anything in the
    * transformed range [input-.5,input+.5]; this is is required because of the
    * way libpng treats the 16_TO_8 flag when building the gamma tables in
    * releases up to 1.6.0.
    *
    * TODO: review this
    *//* because libpng doesn't do sBIT below 8! *//* And the test encodings *//* PNG_LIBPNG_VER >= 10600 *//* Low bit depth gray images don't do well in the gamma tests, until
    * this is fixed turn them off for some gamma cases:
    *//* default to off *//* Store the test gammas *//* Currently 16 bit expansion happens at the end of the pipeline, so the
    * calculations are done in the input bit depth not the output.
    *
    * TODO: fix this
    *//* Default assume_16_bit_calculations appropriately; this tells the checking
    * code that 16-bit arithmetic is used for 8-bit samples when it would make a
    * difference.
    *//* Default to error on warning: *//* Don't give argv[0], it's normally some horrible libtool string: *//* Preallocate the image buffer, because we know how big it needs to be,
    * note that, for testing purposes, it is deliberately mis-aligned by tag
    * bytes either side.  All rows have an additional five bytes of padding for
    * overwrite checking.
    *//* Only required to enable FP exceptions on platforms where they start off
    * disabled; this is not necessary but if it is not done pngvalid will likely
    * end up ignoring FP conditions that other platforms fault.
    *//* Add appropriate signal handlers, just the ANSI specified ones: *//* This records the command and arguments: *//* This is an array of standard gamma values (believe it or not I've seen
    * every one of these mentioned somewhere.)
    *
    * In the following list the most useful values are first!
    *//* Create the given output file on success: *//* Print memory statistics at the end *//* Print the error summary at the end *//* main program *//* And finally throw an exception so we can keep going, unless this is
    * SIGTERM in which case stop now.
    *//*error*//*png_struct**//* signal handler
 *
 * This attempts to trap signals and escape without crashing.  It needs a
 * context pointer so that it can throw an exception (call longjmp) to recover
 * from the condition; this is handled by making the png_modifier used by 'main'
 * into a global variable.
 *//*blue: *//*green:*//*red:  *//* the 'Mac' gamma *//*gamma:*//* Fake encoding which selects just the green channel *//* Adobe Wide Gamut RGB *//* Adobe RGB (1998) *//*approximate: uses 1.8 power law compared to sRGB 2.4*//* Kodak ProPhoto (wide gamut) *//* sRGB: must be first in this list! *//* Test color encodings. These values are back-calculated from the published
 * chromaticities.  The values are accurate to about 14 decimal places; 15 are
 * given.  These values are much more accurate than the ones given in the spec,
 * which typically don't exceed 4 decimal places.  This allows testing of the
 * libpng code to its theoretical accuracy of 4 decimal places.  (If pngvalid
 * used the published errors the 'slack' permitted would have to be +/-.5E-4 or
 * more.)
 *
 * The png_modifier code assumes that encodings[0] is sRGB and treats it
 * specially: do not change the first entry in this list!
 *//* Move to the next v - the stepping algorithm starts skipping
          * values above 1024.
          *//* Then the base 1 stuff: *//* First the base 0 stuff: *//* The first two tests overflow if the pass row or column is outside
          * the possible range for a 32-bit result.  In fact the values should
          * never be outside the range for a 31-bit result, but checking for 32
          * bits here ensures that if an app uses a bogus pass row or column
          * (just so long as it fits in a 32 bit integer) it won't get a
          * possibly dangerous overflow.
          *//* Macros that depend on the image or sub-image height too:
       *
       * PNG_PASS_ROWS(height, pass)
       * PNG_PASS_COLS(width, pass)
       * PNG_ROW_FROM_PASS_ROW(yIn, pass)
       * PNG_COL_FROM_PASS_COL(xIn, pass)
       * PNG_ROW_IN_INTERLACE_PASS(y, pass)
       * PNG_COL_IN_INTERLACE_PASS(x, pass)
       *//* The macros to validate, first those that depend only on pass:
    *
    * PNG_PASS_START_ROW(pass)
    * PNG_PASS_START_COL(pass)
    * PNG_PASS_ROW_SHIFT(pass)
    * PNG_PASS_COL_SHIFT(pass)
    *//* i.e. break the 'y', row, loop. *//* i.e. break the 'x', column, loop. *//* Is column 'x' in pass 'pass'? *//* Is row 'y' in pass 'pass'? *//* bad pass number *//* By examination of the array: *//* error - unrecognized 'inc' *//* pass 7 has all the columns *//* The shift is always 1, 2 or 3 - no pass has all the rows! *//* error - no row in pass! *//* error - more than one 'inc' value! *//* This routine validates all the interlace support macros in png.h for
 * a variety of valid PNG widths and heights.  It uses a number of similarly
 * named internal routines that feed off the above array.
 *//* This is copied verbatim from the specification, it is simply the pass
 * number in which each pixel in each 8x8 tile appears.  The array must
 * be indexed adam7[y][x] and notice that the pass numbers are based at
 * 1, not 0 - the base libpng uses.
 *//* INTERLACE MACRO VALIDATION *//* PNG_READ_SUPPORTED *//* PNG_READ_GAMMA_SUPPORTED *//*indexed*//*TODO: remove this.  Necessary because the current libpng
       * implementation works in 8 bits:
       *//* because the 16 bit background is smashed *//* The 16 to 8 bit strip operations: *//* Should be READ_16BIT_SUPPORTED *//* The sbit tests produce much larger errors: *//*low bit depth*//*who*//* Now some real transforms. *//* First some arbitrary no-transform tests: *//* Save certain values for the temporary overrides below. *//*TODO: remove this*//* Use -1 to catch tests that were not actually run *//* READ_BACKGROUND || READ_ALPHA_MODE *//* Don't skip the i==j case here - it's relevant. *//*TODO: FIXME: this should work *//* TODO: FIXME *//* Skip the non-alpha cases - there is no setting of a transparency colour at
    * present.
    *
    * TODO: incorrect; the palette case sets tRNS and, now RGB and gray do,
    * however the palette case fails miserably so is commented out below.
    *//*strip 16*//*sBIT*//* This assumes no expand gray->rgb - the current code won't handle that!
       *//* Include the background color and gamma in the name: *//* Grayscale input, we do not convert to RGB (TBD), so we must set the
       * background to gray - else libpng seems to fail.
       *//* Because, currently, png_set_background is always called with
       * 'need_expand' false in this case and because the gamma test itself
       * doesn't cause an expand to 8-bit for lower bit depths the colour must
       * be reduced to the correct range.
       *//* rgb(193,193,193) to detect errors *//* 8 bit colors *//* The background values will be looked up in an 8-bit table to do
             * the gamma correction, so only select values which are an exact
             * match for the 8-bit table entries:
             *//* In earlier libpng versions, those where DIGITIZE is set, any background
       * gamma correction in the expand16 case was done using 8-bit gamma
       * correction tables, resulting in larger errors.  To cope with those
       * cases use a 16-bit background value which will handle this gamma
       * correction.
       *//* Use random background values - the background is always presented in the
    * output space (8 or 16 bit components).
    *//* should not be used *//* This tests the handling of a unique value, the math is such that the
          * value tends to be <1, but is neither screen nor file (even if they
          * match!)
          *//* Make up a name and get an appropriate background gamma value. *//* 16 to 8 bit conversion *//*scale16*//* Include the alpha cases here. Note that sbit matches the internal value
    * used by the library - otherwise we will get spurious errors from the
    * internal sbit style approximation.
    *
    * The threshold test is here because otherwise the 16 to 8 conversion will
    * proceed *without* gamma correction, and the tests above will fail (but not
    * by much) - this could be fixed, it only appears with the -g option.
    *//* Note that this requires a 16 bit source image but produces 8 bit output, so
 * we only need the 16bit write support, but the 16 bit images are only
 * generated if DO_16BIT is defined.
 *//* The only interesting cases are colour and grayscale, alpha is ignored here
    * for overall speed.  Only bit depths where sbit is less than the bit depth
    * are tested.
    *//*do not scale16*//* And a special test for sRGB *//* There's little point testing the interlacing vs non-interlacing,
          * but this can be set from the command line.
          *//* Don't test more than one instance of each palette - it's pointless, in
    * fact this test is somewhat excessive since libpng doesn't make this
    * decision based on colour type or bit depth!
    *
    * CHANGED: now test two palettes and, as a side effect, images with and
    * without tRNS.
    *//*no background gamma*//*hence*//*no background*//*no expand16*//*no scale16*//*no input precision*//*threshold test*//*palette*//* Log the summary values too. *//* Process the 'info' requirements. Only one image is generated *//* Check the header values: *//* modifier_read expects a png_modifier* *//* Now feed data into the reader until we reach the end: *//* Share the row function with the standard implementation. *//* Introduce the correct read function. *//* Get a png_struct for reading the image. *//*delete*//* Make an appropriate modifier to set the PNG file gamma to the
       * given gamma value and the sBIT chunk to the given precision.
       *//* Just resets everything *//* For the moment don't use the png_modifier support here. *//* A single test run checking a gamma transformation.
 *
 * maxabs: maximum absolute error as a fraction
 * maxout: maximum output error in the output units
 * maxpc:  maximum percentage error (as a percentage)
 *//* row (y) loop *//* No transform is expected on the threshold tests. *//*component*//* RGB or palette *//* grayscale *//* Handle grayscale or RGB components. *//* RGB *//* gray *//* alpha needs to be set appropriately for this pixel, it is
                * currently 1 and needs to be 0 for an input pixel which matches
                * the values in tRNS.
                *//* This is a copy of the calculation of 'i' above in order to
                   * have the alpha value to use in the background calculation.
                   *//* no alpha in output *//*background*//*alpha*//* as a flag value *//* Handle input alpha - png_set_background will cause the output
             * alpha to disappear so there is nothing to check.
             *//* Record the palette index for index images. *//* serves as a flag value *//* TODO: FIX THIS: MAJOR BUG!  If the transformations all happen inside
    * the palette there is no way of finding out, because libpng fails to
    * update the palette on png_read_update_info.  Indeed, libpng doesn't
    * even do the required work until much later, when it doesn't have any
    * info pointer.  Oops.  For the moment 'processing' is turned off if
    * out_ct is palette.
    *//* Supply the input and output sample depths here - 8 for an indexed image,
    * otherwise the bit depth.
    *//* Check for row overwrite errors *//* Just refers to the palette case *//* There are three sources of error, firstly the quantization in the
    * file encoding, determined by sbit and/or the file depth, secondly
    * the output (screen) gamma and thirdly the output file encoding.
    *
    * Since this API receives the screen and file gamma in double
    * precision it is possible to calculate an exact answer given an input
    * pixel value.  Therefore we assume that the *input* value is exact -
    * sample/maxsample - calculate the corresponding gamma corrected
    * output to the limits of double precision arithmetic and compare with
    * what libpng returns.
    *
    * Since the library must quantize the output to 8 or 16 bits there is
    * a fundamental limit on the accuracy of the output of +/-.5 - this
    * quantization limit is included in addition to the other limits
    * specified by the parameters to the API.  (Effectively, add .5
    * everywhere.)
    *
    * The behavior of the 'sbit' parameter is defined by section 12.5
    * (sample depth scaling) of the PNG spec.  That section forces the
    * decoder to assume that the PNG values have been scaled if sBIT is
    * present:
    *
    *     png-sample = floor( input-sample * (max-out/max-in) + .5);
    *
    * This means that only a subset of the possible PNG values should
    * appear in the input. However, the spec allows the encoder to use a
    * variety of approximations to the above and doesn't require any
    * restriction of the values produced.
    *
    * Nevertheless the spec requires that the upper 'sBIT' bits of the
    * value stored in a PNG file be the original sample bits.
    * Consequently the code below simply scales the top sbit bits by
    * (1<<sbit)-1 to obtain an original sample value.
    *
    * Because there is limited precision in the input it is arguable that
    * an acceptable result is any valid result from input-.5 to input+.5.
    * The basic tests below do not do this, however if 'use_input_precision'
    * is set a subsequent test is performed above.
    *//* Get some constants derived from the input and output file formats: *//* logging this value *//* The error condition *//* This is our calculated encoded_sample which should (but does
             * not) match od:
             *//* This is the non-composition case, the internal linear
                * values are irrelevant (though the log below will reveal
                * them.)  Output a much shorter warning/error message and report
                * the overall gamma correction.
                *//* logging *//* Finally report the output gamma encoding, if any. *//* Report the calculated value (input_sample) and the linearized
             * libpng value (output) unless this is just a component gamma
             * correction.
             *//* Now record the *linear* background value if it was used
                * (this function is not passed the original, non-linear,
                * value but it is contained in the test name.)
                *//* If any form of composition is being done report our
                * calculated linear value here (the code above doesn't record
                * the input value before composition is performed, so what
                * gets reported is the value after composition.)
                *//* A component may have been multiplied (in linear space) by the
             * alpha value, 'compose' says whether this is relevant.
             *//* The output is either "id/max" or "id sbit(sbit): isbit/max" *//* sBIT has reduced the precision of the input: *//*logging*//* 'name' is the component name *//* Check the 'compose' flag *//* ALPHA_MODE_SUPPORTED *//* Set up the various flags, the output_is_encoded flag above
             * is also used below.  do_compose is just a double check.
             *//* Need either 1/255 or 1/65535 precision here; 3 or 6 decimal
             * places.  Just use outmax to work out which.
             *//* Attempt to output a meaningful error/warning message: the message
          * output depends on the background/composite operation being performed
          * because this changes what parameters were actually used above.
          *//* !use_input_precision *//* One last chance.  If this is an alpha channel and the 16to8
             * option has been used and 'inaccurate' scaling is used then the
             * bit reduction is obtained by simply using the top 8 bits of the
             * value.
             *
             * This is only done for older libpng versions when the 'inaccurate'
             * (chop) method of scaling was used.
             *//* Ok, something is wrong - this actually happens in current libpng
             * 16-to-8 processing.  Assume that the input value (id, adjusted
             * for sbit) can be anywhere between value-.5 and value+.5 - quite a
             * large range if sbit is low.
             *
             * NOTE: at present because the libpng gamma table stuff has been
             * changed to use a rounding algorithm to correct errors in 8-bit
             * calculations the precise sbit calculation (a shift) has been
             * lost.  This can result in up to a +/-1 error in the presence of
             * an sbit less than the bit depth.
             *//* pass is set at this point if either of the tests above would have
          * passed.  Don't do these additional tests here - just log the
          * original [es_lo..es_hi] values.
          *//* There has been an error in processing, or we need to log this
          * value.
          *//* The value passes, but we may need to log the information anyway. *//* The primary test is that the final encoded value returned by the
       * library should be between the two limits (inclusive) that were
       * calculated above.
       *//* Quantize this appropriately: *//* The 'maxout' value refers to the encoded result, to compare with
          * this encode input_sample adjusted by the maximum error (tmp) above.
          *//* If 'compose' is true the composition was done in linear space using
          * integer arithmetic.  This introduces an extra error of +/- 0.5 (at
          * least) in the integer space used.  'maxcalc' records this, taking
          * into account the possibility that even for 16 bit output 8 bit space
          * may have been used.
          *//* Now calculate the digitization limits for 'encoded_sample' using the
       * 'max' values.  Note that maxout is in the encoded space but maxpc and
       * maxabs are in linear light space.
       *
       * First find the maximum error in linear light space, range 0..1:
       *//* The following is an attempt to ignore the tendency of quantization to
       * dominate the percentage errors for lower result values:
       *//* Now we have the numbers for real errors, both absolute values as as a
       * percentage of the correct value (output):
       *//* i: the original input value in the range 0..1
       *
       * pngvalid calculations:
       *  input_sample: linear result; i linearized and composed, range 0..1
       *  encoded_sample: encoded result; input_sample scaled to output bit depth
       *
       * libpng calculations:
       *  output: linear result; od scaled to 0..1 and linearized
       *  od: encoded result from libpng
       *//* Test passed but error is bigger than the log limit, record why the
          * test passed:
          *//* Don't log errors in the alpha channel, or the 'optimized' case,
       * neither are significant to the overall perception.
       *//* Calculate (or recalculate) the encoded_sample value and repeat the
       * check above (unnecessary if we took the fast route, but harmless.)
       *//* the optimized case - linear output *//* A component *//* In all other cases the output alpha channel is linear already,
             * don't log errors here, they are much larger in linear data.
             *//* The alpha channel *//* And similarly for the output value, but we need to check the background
       * handling to linearize it correctly.
       *//* Handle the compose processing: *//* Convert to linear light (with the above caveat.)  The alpha channel is
       * already linear.
       *//* Reason test passes (or 0 for fail) *//* Check maximum error values *//* Set if encoded to screen gamma *//* Set to one if composition done *//* In range 0..1 *//* There may be an error, or background processing is required, so calculate
    * the actual sample values - unencoded light intensity values.  Note that in
    * practice these are not completely unencoded because they include a
    * 'viewing correction' to decrease or (normally) increase the perceptual
    * contrast of the image.  There's nothing we can do about this - we don't
    * know what it is - so assume the unencoded value is perceptually linear.
    *//* The slow route - attempt to do linear calculations. *//* alpha less than 0 indicates the alpha channel, which is always linear
       *//* Then get the gamma corrected version of 'i' and compare to 'od', any
       * error less than .5 is insignificant - just quantization of the output
       * value to the nearest digital value (nevertheless the error is still
       * recorded - it's interesting ;-)
       *//* alpha channel *//* opaque pixel component *//* Check for the fast route: if we don't do any background composition or if
    * this is the alpha channel ('alpha' < 0) or if the pixel is opaque then
    * just use the gamma_correction field to correct to the final output gamma.
    *//* First check on the 'perfect' result obtained from the digitized input
    * value, id, and compare this against the actual digitized result, 'od'.
    * 'i' is the input result in the range 0..1:
    *//* component background value *//* <0 for the alpha channel itself *//* This API returns the encoded *input* component, in the range 0..1 *//* Standard cases where no compositing is done (so the component
          * value is already correct.)
          *//* The optimization is that the partial-alpha entries are linear
          * while the opaque pixels are gamma encoded, but this only affects the
          * output encoding.
          *//* The components are premultiplied in either case and the output is
          * gamma encoded (to get standard Porter-Duff we expect the output
          * gamma to be set to 1.0!)
          *//* Standard PNG background processing. *//* This function handles composition of a single non-alpha component.  The
 * argument is the input sample value, in the range 0..1, and the alpha value.
 * The result is the composed, linear, input sample.  If alpha is less than zero
 * this is the alpha component and the function should not be called!
 *//* Do not expect any background processing *//* libpng doesn't do this optimization, if we do pngvalid will fail.
          *//* Caller must at least put the gray value into the red channel *//* This mimics the libpng threshold test, '0' is used to prevent gamma
    * correction in the validation test.
    *//* Total including quantization error *//* Linear background value, red or gray. *//* Inverse of screen gamma. *//* Inverse of file gamma. *//* Overall correction required. *//* Validate a single component value - the routine gets the input and output
 * sample values as unscaled PNG component values along with a cache of all the
 * information required to validate the values.
 *//*images*//* Now we may get a different cbRow: *//* Always do one call, even if use_update_info is 0. *//*need_expand*//* NOTE: this assumes the caller provided the correct background gamma!
          *//* Set up gamma processing. *//* However, for the standard Porter-Duff algorithm the output defaults
          * to be linear, so if the test requires non-linear output it must be
          * corrected here.
          *//* The gamma value is the output gamma, and is in the standard,
          * non-inverted, representation.  It provides a default for the PNG file
          * gamma, but since the file has a gAMA chunk this does not matter.
          *//* This tests the alpha mode handling, if supported. *//* The following works both in 1.5.4 and earlier versions: *//* If requested strip 16 to 8 bits - this is handled automagically below
    * because the output bit depth is read from the library.  Note that there
    * are interactions with sBIT but, internally, libpng makes sbit at most
    * PNG_MAX_GAMMA_8 prior to 1.7 when doing the following.
    *//* Reuse the standard stuff as appropriate. *//* Local variable fields *//* Parameter fields *//* Standard fields *//* Local variables *//* Parameters *//* Reader callbacks and implementations, where they differ from the standard
 * ones.
 *//********************************* GAMMA TESTS ********************************//* The command line can change this to checking interlaced images. *//*max*//* 'max' is currently hardwired to '1'; this should be settable on the
          * command line.
          *//* Nothing added, but was there anything in there to add? *//* Now if anything was added we have something to do. *//* And, since we know it isn't useful, stop it being added again
                * in this run:
                *//* Not useful and max>0, so remove it from *this: *//* Added, so add to the name too. *//* Candidate to add: *//* Go through the whole list adding anything that the counter selects: *//* Now add all these items, if possible *//* advance the counter *//* first time *//* Find the next counter value, if the counter is zero this is the start
       * of the list.  This routine always returns the current counter (not the
       * next) so it returns 0 at the end and expects 0 at the beginning.
       *//* until we manage to add something *//* Continue if any entry hasn't reacked the max. *//* For max 0 or 1 continue until the counter overflows: *//* Test the list to see if there is any point continuing, given a current
    * counter and a 'max' value.
    *//* This can only happen if we every have more than 32 transforms (excluding
    * the end) in the list.
    *//* Everything starts out enabled, so if we see an 'enable' disabled
    * everything else the first time round.
    *//* This may just be 'end' if all the transforms are disabled! *//* PNG_READ_SHIFT_SUPPORTED *//* One grey channel *//* RGB channels *//* The sBIT fields are reset to the values previously sent to
        * png_set_shift according to the colour type.
        * does.
        *//* Copy the correct values into the sBIT fields, libpng does not do
    * anything to palette data:
    *//* Get a random set of shifts.  The shifts need to do something
    * to test the transform, so they are limited to the bit depth
    * of the input image.  Notice that in the following the 'gray'
    * field is randomized independently.  This acts as a check that
    * libpng does use the correct field.
    *//* png_set_shift(png_struct *, const png_color_8 *true_bits)
 *
 * The output pixels will be shifted by the given true_bits
 * values.
 *//* PNG_READ_INVERT_MONO_SUPPORTED *//* Only has an effect on pixels with no colour: *//* Invert the gray channel
 *
 *  png_set_invert_mono(png_struct *png_ptr)
 *//* png_set_invert_mono *//* PNG_READ_PACKSWAP_SUPPORTED *//* Swap pixels packed into bytes; reverses the order on screen so that
 * the high order bits correspond to the rightmost pixels.
 *
 *  png_set_packswap(png_struct *png_ptr)
 *//* png_set_packswap *//* PNG_READ_PACK_SUPPORTED *//* Nothing should happen unless the bit depth is less than 8: *//* grayscale or palette *//* The general expand case depends on what the colour type is,
    * low bit-depth pixel values are unpacked into bytes without
    * scaling, so sample_depth is not changed.
    *//* Use 1 byte per pixel in 1, 2, or 4-bit depth files.
 *
 *  png_set_packing(png_struct *png_ptr)
 *
 * This should only affect grayscale and palette images with less than 8 bits
 * per pixel.
 *//* png_set_packing *//* PNG_READ_FILLER_SUPPORTED *//* alpha added *//* Need a random choice for 'before' and 'after' as well as for the
    * filler.  The 'filler' value has all 32 bits set, but only bit_depth
    * will be used.  At this point we don't know bit_depth.
    *//* Add an alpha byte to 8-bit Gray or 24-bit RGB images. *//* png_set_add_alpha, (png_struct *png_ptr, png_uint_32 filler, int flags)); *//* The filler has been stored in the alpha channel, we must record
       * that this has been done for the checking later on, the color
       * type is faked to have an alpha channel, but libpng won't report
       * this; the app has to know the extra channel is there and this
       * was recording in standard_display::filler above.
       *//* The standard display handling stuff also needs to know that
    * there is a filler, so set that here.
    *//* Add a filler byte to 8-bit Gray or 24-bit RGB images.
 *
 *  png_set_filler, (png_struct *png_ptr, png_uint_32 filler, int flags));
 *
 * Flags:
 *
 *  PNG_FILLER_BEFORE
 *  PNG_FILLER_AFTER
 *//* PNG_READ_SWAP_SUPPORTED *//* Byte swap 16-bit components.
 *
 *  png_set_swap(png_struct *png_ptr)
 *//* png_set_swap *//* PNG_READ_SWAP_ALPHA_SUPPORTED *//* Put the alpha channel first.
 *
 *  png_set_swap_alpha(png_struct *png_ptr)
 *
 * This only has an effect on GA and RGBA pixels.
 *//* png_set_swap_alpha *//* PNG_READ_BGR_SUPPORTED *//* Swap R,G,B channels to order B,G,R.
 *
 *  png_set_bgr(png_struct *png_ptr)
 *
 * This only has an effect on RGB and RGBA pixels.
 *//* png_set_bgr *//* PNG_READ_INVERT_ALPHA_SUPPORTED *//* Only has an effect on pixels with alpha: *//* Invert the alpha channel
 *
 *  png_set_invert_alpha(png_struct *png_ptr)
 *//* png_set_invert_alpha *//* The data layout transforms are handled by swapping our own channel data,
 * necessarily these need to happen at the end of the transform list because the
 * semantic of the channels changes after these are executed.  Some of these,
 * like set_shift and set_packing, can't be done at present because they change
 * the layout of the data at the sub-sample level so sample() won't get the
 * right answer.
 *//*NOTE: TBD NYI *//* png_set_quantize(png_struct *, png_color *palette, int num_palette,
 *    int maximum_colors, const png_uint_16 *histogram, int full_quantize)
 *
 * Very difficult to validate this!
 *//* PNG_READ_BACKGROUND_SUPPORTED *//* PNG_COLOR_TYPE_PALETTE is not changed *//* Remove the alpha type and set the alpha (not in that order.) *//* 0 < alpha < 1 *//* Now we do the background calculation without any gamma correction. *//* This is only necessary if the alpha value is less than 1. *//*for background*//* Check for tRNS first: *//* Extract the background colour from this image_pixel, but make sure the
    * unused fields of 'back' are garbage.
    *//*format*//*unused: palette*//*x*//* passing in an RGB not a pixel index *//* Read the random value, for colour type 3 the background colour is actually
    * expressed as a 24bit rgb, not an index.
    *//* We need a background colour, because we don't know exactly what transforms
    * have been set we have to supply the colour in the original file format and
    * so we need to know what that is!  The background colour is stored in the
    * transform_display.
    *//* 8 bytes - 64 bits - the biggest pixel *//* png_set_background(png_struct *, const png_color_16 *background_color,
 *    int background_gamma_code, int need_expand, double background_gamma)
 * png_set_background_fixed(png_struct *, const png_color_16 *background_color,
 *    int background_gamma_code, int need_expand,
 *    png_fixed_point background_gamma)
 *
 * This ignores the gamma (at present.)
*//* PNG_READ_RGB_TO_GRAY_SUPPORTED *//* And remove the colour bit in the type: *//* The sBIT is the minimum of the three colour channel sBITs. *//* !DIGITIZE *//* !RELEASE_BUILD *//* Validate that the error is within limits (this has caused
             * problems before, it's much easier to detect them here.)
             *//* Work out the lower and upper bounds for the gray value in the
             * encoded space, then work out an average and error.  Remove the
             * previously added input quantization error at this point.
             *//* The calculation happens in linear space, and this produces much
             * wider errors in the encoded space.  These are handled here by
             * factoring the errors in to the calculation.  There are two table
             * lookups in the calculation and each introduces a quantization
             * error defined by the table size.
             *//* There is no need to do the conversions to and from linear space,
             * so the calculation should be a lot more accurate.  There is a
             * built in error in the coefficients because they only have 15 bits
             * and are adjusted to make sure they add up to 32768.  This
             * involves a integer calculation with truncation of the form:
             *
             *     ((int)(coefficient * 100000) * 32768)/100000
             *
             * This is done to the red and green coefficients (the ones
             * provided to the API) then blue is calculated from them so the
             * result adds up to 32768.  In the worst case this can result in
             * a -1 error in red and green and a +2 error in blue.  Consequently
             * the worst case in the calculation below is 2/32768 error.
             *
             * TODO: consider fixing this in libpng by rounding the calculation
             * limiting the error to 1/32768.
             *
             * Handling this by adding 2/32768 here avoids needing to increase
             * the global error limits to take this into account.)
             *//* before 1.7 *//* The true gray case involves no math in earlier versions (not
             * true, there was some if gamma correction was happening too.)
             *//* Check that this worked: *//* Now the error can be calculated.
          *
          * If r==g==b because there is no overall gamma correction libpng
          * currently preserves the original value.
          *//*truncate*//* And this happens yet again, shifting the values once more. *//* And invert the gamma. *//* always accept the right answer *//* Now calculate the actual gray values.  Although the error in the
          * coefficients depends on whether they were specified on the command
          * line (in which case truncation to 15 bits happened) or not (rounding
          * was used) the maximum error in an individual coefficient is always
          * 2/32768, because even in the rounding case the requirement that
          * coefficients add up to 32768 can cause a larger rounding error.
          *
          * The only time when rounding doesn't occur in 1.5.5 and later is when
          * the non-gamma code path is used for less than 16 bit data.
          *//* 'abse' is the error in the gamma table calculation itself. *//* If a gamma calculation is done it is done using lookup tables of
             * precision gamma_depth, so the already digitized value above may
             * need to be further digitized here.
             *//*round*//* Do this using interval arithmetic, otherwise it is too difficult to
          * handle the errors correctly.
          *
          * To handle the gamma correction work out the upper and lower bounds
          * of the digitized value.  Assume rounding here - normally the values
          * will be identical after this operation if there is only one
          * transform, feel free to delete the png_error checks on this below in
          * the future (this is just me trying to ensure it works!)
          *
          * Interval arithmetic is exact, but to implement it it must be
          * possible to control the floating point implementation rounding mode.
          * This cannot be done in ANSI-C, so instead I reduce the 'lo' values
          * by DBL_EPSILON and increase the 'hi' values by the same.
          *//* Image now has RGB channels... *//* READ_cHRM *//* Print the color space without the gamma value: *//* Here in both fixed and floating cases to check the values read
             * from the cHRm chunk.  PNG uses fixed point in the cHRM chunk, so
             * we can't expect better than +/-.5E-5 on the result, allow 1E-5.
             *//* Set to element name with error *//* This should match the original one from the png_modifier, within
             * the range permitted by the libpng fixed point representation.
             *//* Generate a colour space encoding. *//* Sanity check the pngvalid code - the coefficients should match
             * the normalized Y values of the encoding unless they were
             * overridden.
             *//* Expect libpng to return a normalized result, but the original
             * color space encoding may not be normalized.
             *//* We have an encoding so a cHRM chunk may have been set; if so then
          * check that the libpng APIs give the correct (X,Y,Z) values within
          * some margin of error for the round trip through the chromaticity
          * form.
          *//* no error, no defines in png.h *//* With no gamma correction a large error comes from the truncation of the
       * calculation in the 8 bit case, allow for that here.
       *//* Rounding to 8 bits in the linear space causes massive errors which
          * will trigger the error check in transform_range_check.  Fix that
          * here by taking the gamma encoding into account.
          *
          * When DIGITIZE is set because a pre-1.7 version of libpng is being
          * tested allow a bigger slack.
          *
          * NOTE: this number only affects the internal limit check in pngvalid,
          * it has no effect on the limits applied to the libpng values.
          *//* The computations have the form:
          *
          *    r * rc + g * gc + b * bc
          *
          *  Each component of which is +/-1/65535 from the gamma_to_1 table
          *  lookup, resulting in a base error of +/-6.  The gamma_from_1
          *  conversion adds another +/-2 in the 16-bit case and
          *  +/-(1<<(15-PNG_MAX_GAMMA_8)) in the 8-bit case.
          *//* Use gamma tables *//* Adjust the error limit in the png_modifier because of the larger errors
    * produced in the digitization during the gamma handling.
    *//* The following just changes the error messages: *//* These values override the color encoding defaults, simply use random
       * numbers.
       *//* First time in coefficients_overridden is 0, the following sets it to 1,
       * so repeat if it is set.  If a test fails this may mean we subsequently
       * skip a non-override test, ignore that.
       *//* The arguments to png_set_rgb_to_gray can override the coefficients implied
    * by the color space encoding.  If doing exhaustive checks do the override
    * in each case, otherwise do it randomly.
    *//* If not set then the calculations assume linear encoding (implicitly): *//* The default (built in) coefficients, as above: *//* Coefficients come from the encoding, but may need to be normalized to a
       * white point Y of 1.0
       *//* If 'e' is not NULL chromaticity information is present and either a cHRM
    * or an sRGB chunk will be inserted.
    *//* Since we check the encoding this flag must be set: *//* Set if the coeefficients have been overridden. *//* The actual coefficients: *//* The following are the parameters for png_set_rgb_to_gray: *//* File gamma to use in processing *//* png_set_rgb_to_gray(png_struct *, int err_action, double red, double green)
 * png_set_rgb_to_gray_fixed(png_struct *, int err_action, png_fixed_point red,
 *    png_fixed_point green)
 * png_get_rgb_to_gray_status
 *
 * The 'default' test here uses values known to be used inside libpng prior to
 * 1.7.0:
 *
 *   red:    6968
 *   green: 23434
 *   blue:   2366
 *
 * These values are being retained for compatibility, along with the somewhat
 * broken truncation calculation in the fast-and-inaccurate code path.  Older
 * versions of libpng will fail the accuracy tests below because they use the
 * truncation algorithm everywhere.
 *//* PNG_READ_STRIP_ALPHA_SUPPORTED *//* png_set_strip_alpha *//* PNG_READ_16_TO_8_SUPPORTED *//* Prior to 1.5.4 png_set_strip_16 would use an 'accurate' method if this
       * configuration option is set.  From 1.5.4 the flag is never set and the
       * 'scale' API (above) must be used.
       *//* libpng will limit the gamma table size: *//* png_set_strip_16 *//* the default before 1.5.4 *//* PNG_READ_SCALE_16_TO_8_SUPPORTED (1.5.4 on) *//* png_set_scale_16 *//* API added in 1.5.4 *//* PNG_READ_EXPAND_16_SUPPORTED *//* expand_16 does something unless the bit depth is already 16. *//*!for background*//* Expect expand_16 to expand everything to 16 bits as a result of also
    * causing 'expand' to happen.
    *//* NOTE: prior to 1.7 libpng does SET_EXPAND as well, so tRNS is expanded. *//* png_set_expand_16 *//* PNG_READ_EXPAND_SUPPORTED *//* 1.7 or later *//* This should do nothing unless the color type is gray and the bit depth is
    * less than 8:
    *//* Only expand grayscale of bit depth less than 8: *//* NOTE: don't expect this to expand tRNS *//* png_set_expand_gray_1_2_4_to_8
 * Pre 1.7.0 LIBPNG BUG: this just does an 'expand'
 *//* 'expand' should do nothing for RGBA or GA input - no tRNS and the bit
    * depth is at least 8 already.
    *//* The general expand case depends on what the colour type is: *//* png_set_expand *//* PNG_READ_GRAY_TO_RGB_SUPPORTED *//* And just changing the colour type works here because the green and blue
       * channels are being maintained in lock-step with the red/gray:
       *//* RGB images have a bit depth at least equal to '8' *//* Simply expand the bit depth and alter the colour type as required. *//* NOTE: we can actually pend the tRNS processing at this point because we
    * can correctly recognize the original pixel value even though we have
    * mapped the one gray channel to the three RGB ones, but in fact libpng
    * doesn't do this, so we don't either.
    *//* NOTE: this doesn't result in tRNS expansion. *//* png_set_gray_to_rgb *//* We don't know yet whether there will be a tRNS chunk, but we know that
    * this transformation should do nothing if there already is an alpha
    * channel.  In addition, after the bug fix in 1.7.0, there is no longer
    * any action on a palette image.
    *//* LIBPNG BUG: otherwise libpng still expands to 8 bits! *//* This effectively does an 'expand' only if there is some transparency to
    * convert to an alpha channel.
    *//* LIBPNG BUG: this always forces palette images to RGB. *//* If there was a tRNS chunk that would get expanded and add an alpha
    * channel is_transparent must be updated:
    *//* png_set_tRNS_to_alpha *//* png_set_palette_to_rgb *//* private, but almost always needed *//* silence GCC warnings *//* To save code: *//* stores the previous transform *//*next*//*local_use*//*global_use*//*list*//*enable*//* The transforms: *//* Logging (debugging only) *//* Add the color space information, if any, to the name. *//* Add any modifications required by the transform list. *//* Make sure the encoding fields are correct and enter the required
       * modifications.
       *//* A single test run. *//* Record that something was actually checked to avoid a false positive. *//* pixel (x) loop *//* Check the colours for palette images too - in fact the palette could
          * be separately verified itself in most cases.
          *//* We don't expect changes to the index here even if the bit depth is
          * changed.
          *//* Read the output pixel and compare it to what we got, we don't
          * use the error field here, so no need to update sBIT.  in_pixel
          * says whether we expect libpng to change the output format.
          *//* This applies the transforms to the input data, including output
          * format operations which must be used when reading the output
          * pixel that libpng produces.
          *//* For error detection, below. *//* Find out what we think the pixel should be: *//* Go through each original pixel transforming it and comparing with what
       * libpng did to the same pixel.
       *//* The original, standard, row pre-transforms. *//* Else calculations are at 8 bit precision, and the output actually
       * consists of scaled 8-bit values, so scale .5 in 8 bits to the 16 bits:
       *//* use-input-precision means assume that if the input has 8 bit (or less)
       * samples and the output has 16 bit samples the calculations will be done
       * with 8 bit precision, not 16.
       *//* Validate that the palette count itself has not changed - this is not
       * expected.
       *//* Read the palette corresponding to the output if the output colour type
    * indicates a palette, otherwise set out_palette to garbage.
    *//* Constants for the loop below: *//* Compare the scaled, digitized, values of our local calculation (in+-err)
    * with the digitized values libpng produced;  'sample_depth' is the actual
    * digitization depth of the libpng output colors (the bit depth except for
    * palette images where it is always 8.)  The check on 'err' is to detect
    * internal errors in pngvalid itself.
    *//* This could be a libpng error too; libpng has not produced what we
          * expect for the output bit depth.
          *//* Because unless something has set 'unpacked' or the image is palette
          * mapped we expect the transform to keep sample depth and bit depth
          * the same.
          *//* oops - internal error! *//* If both bit depth and colour type are correct check the sample depth.
       *//* Don't need sBIT here, but it must be set to non-zero to avoid
       * arithmetic overflows.
       *//* input *//* Use a test pixel to check that the output agrees with what we expect -
    * this avoids running the whole test if the output is unexpected.  This also
    * checks for internal errors.
    *//* Validate the combination of colour type and bit depth that we are getting
    * out of libpng; the semantics of something not in the PNG spec are, at
    * best, unclear.
    *//* If png_set_filler is in action then fake the output color type to include
    * an alpha channel where appropriate.
    *//* Plus the extra stuff we need for the transform tests: *//* And get the output information into the standard_display *//* Update the info structure for these transforms: *//* Now set the list of transforms. *//* not unpacked *//* invalid *//* never called, I want it to crash if it is! *//* next *//* local_use *//* global_use *//* list *//* enable *//* name *//* Static 'end' structure: *//* It's exact ;-) *//* Override this. *//* The error value is increased, at the end, according to the lowest sBIT
    * value seen.  Common sense tells us that the intermediate integer
    * representations are no more accurate than +/- 0.5 in the integral values,
    * the sBIT allows the implementation to be worse than this.  In addition the
    * PNG specification actually permits any error within the range (-1..+1),
    * but that is ignored here.  Instead the final digitized value is compared,
    * below to the digitized value of the error limits - this has the net effect
    * of allowing (almost) +/-1 in the output value.  It's difficult to see how
    * any algorithm that digitizes intermediate results can be more accurate.
    *//* This is a bit bogus; really the above calculation should use the red_sBIT
    * value, not sample_depth, but because libpng does png_set_shift by just
    * shifting the bits we get errors if we don't do it the same way.
    *//* At the end recalculate the digitized red green and blue values according
    * to the current sample_depth of the pixel.
    *
    * The sample value is simply scaled to the maximum, checking for over
    * and underflow (which can both happen for some image transforms,
    * including simple size scaling, though libpng doesn't do that at present.
    *//* Return NaN as 0: *//* At the end of the list recalculate the output image pixel value from the
 * double precision values set up by the preceding 'mod' calls:
 *//* Three functions to end the list: *//* Set gAMA and cHRM separately. *//* Set up the png_modifier '_current' fields then use these to determine how
    * to add appropriate chunks.
    *//* Set sRGB, cHRM and gAMA transforms as required by the current encoding. *//* Modifications (not necessarily used.) *//* Add this transform to the list and return true if the transform is
    * meaningful for this colour type and bit depth - if false then the
    * transform should have no effect on the image so there's not a lot of
    * point running it.
    *//* Then a transform that takes an input pixel in one PNG format or another
    * and modifies it by a pngvalid implementation of the transform (thus
    * duplicating the libpng intent without, we hope, duplicating the bugs
    * in the libpng implementation!)  The png_struct* is solely to allow error
    * reporting via png_error and png_warning.
    *//* And a callback to set the transform on the current png_read_struct:
    *//* A single transform for the image, expressed as a series of function
    * callbacks and some space for values.
    *
    * First a callback to add any required modifications to the png_modifier;
    * this gets called just before the modifier is set up for read.
    *//* The next transform in the list, each transform must call its own next
    * transform after it has processed the pixel successfully.
    *//* The local count of the number of times this transform has been set. *//* The global count of the number of times this transform has been set on an
    * image.
    *//* The global list of transforms; read only. *//* Each transform can be disabled from the command line: *//* The name of this transform: a string. *//* transforms that need image_pixel_add_alpha *//* The error in the alpha is zero and the sBIT value comes from the
       * original sBIT data (actually it will always be the original bit depth).
       *//* Again, check the exact input values, not the current transformed
             * value!
             *//* Check the input, original, channel value here against the
             * original tRNS gray chunk valie.
             *//* After 1.7 the expansion of bit depth only happens if there is a
             * tRNS chunk to expand at this point.
             *//* Add an alpha channel; this will import the tRNS information because tRNS is
 * not valid in an alpha image.  The bit depth will invariably be set to at
 * least 8 prior to 1.7.0.  Palette images will be converted to alpha (using
 * the above API).  With png_set_background the alpha channel is never expanded
 * but this routine is used by pngvalid to simplify code; 'for_background'
 * records this.
 *//* The bit depth of the row changes at this point too (notice that this is
       * the row format, not the sample depth, which is separate.)
       *//* Convert a palette image to an rgb image.  This necessarily converts the tRNS
 * chunk at the same time, because the tRNS will be in palette form.  The way
 * palette validation works means that the original palette is never updated,
 * instead the image_pixel value from the row contains the RGB of the
 * corresponding palette entry and *this* is updated.  Consequently this routine
 * only needs to change the colour type information.
 *//* Store the input information for use in the transforms - these will
    * modify the information.
    *//* Calculate the scaled values, these are simply the values divided by
    * 'max' and the error is initialized to the double precision epsilon value
    * from the header file.
    *//* alpha *//* BGR *//* Green is second for both BGR and RGB: *//* This handles the gray case for 'AG' pixels *//* not palette *//* This permits the caller to default to the sample value. *//* palette *//* Then override as appropriate: *//* Initially just set everything to the same number and the alpha to opaque.
    * Note that this currently assumes a simple palette where entry x has colour
    * rgb(x,x,x)!
    *//*from pngvalid transform of input*//* Initialize the structure for the next pixel - call this before doing any
 * transforms and call it for each pixel since all the fields may need to be
 * reset.
 *//* Shared utility function, see below. *//* For checking the code calculates double precision floating point values
    * along with an error value, accumulated from the transforms.  Because an
    * sBIT setting allows larger error bounds (indeed, by the spec, apparently
    * up to just less than +/-1 in the scaled value) the *lowest* sBIT for each
    * channel is stored.  This sBIT value is folded in to the stored error value
    * at the end of the application of the transforms to the pixel.
    *
    * If sig_bits is set above the red, green, blue and alpha values have been
    * scaled so they only contain the significant bits of the component values.
    *//* Pixel shifted (sig bits only) *//* High bits on right *//* Byte swap 16-bit components *//* Gray channel inverted *//* Alpha channel inverted *//* Alpha at start, not end *//* RGB swapped to BGR *//* tRNS chunk may need processing *//* Scale of samples *//* Defines bit size in row *//* As in the spec. *//* For a palette image. *//* For non-palette images. *//* A local (pngvalid) representation of a PNG pixel, in all its
    * various forms.
    *//* A set of tests to validate libpng image transforms.  The possibilities here
 * are legion because the transforms can be combined in a combinatorial
 * fashion.  To deal with this some measure of restraint is required, otherwise
 * the tests would take forever.
 *//******************************* TRANSFORM TESTS ******************************//* For the moment don't do the palette test - it's a waste of time when
    * compared to the grayscale test.
    *//* Test each colour type over the valid range of bit depths (expressed as
    * log2(bit_depth) in turn, stop as soon as any error is detected.
    *//* keep going *//* READ_INTERLACING *//*do_interlace*//* Test both together: *//* Test the libpng write side against the pngvalid read side: *//* Test with pngvalid generated interlaced images first; we have
            * already verify these are ok (unless pngvalid has self-consistent
            * read/write errors, which is unlikely), so this detects errors in
            * the read side first:
            *//* Now do the tests of libpng interlace handling, after we have made sure
    * that the pngvalid version works:
    *//* Validate the pngvalid code itself: *//* Now validate the interlaced read side - do_interlace true,
            * in the progressive case this does actually make a difference
            * to the code used in the non-interlaced case too.
            *//* First test all the 'size' images against the sequential
            * reader using libpng to deinterlace (where required.)  This
            * validates the write side of libpng.  There are four possibilities
            * to validate.
            *//* Run the tests on each combination.
    *
    * NOTE: on my 32 bit x86 each of the following blocks takes
    * a total of 3.5 seconds if done across every combo of bit depth
    * width and height.  This is a waste of time in practice, hence the
    * hinc and winc stuff:
    *//********************************** SIZE TESTS ********************************//* In either case clean up the store. *//* make sure this hasn't been clobbered. *//* Successful completion. *//* Check for validation. *//*check_end*//* After the last pass loop over the rows again to check that the
             * image is correct.
             *//* Need the total bytes in the image below; we can't get to this point
          * unless the PNG file values have been checked against the expected
          * values.
          *//* The code tests both versions of the images that the sequential
          * reader can produce.
          *//* Note that this takes the store, not the display. *//* Initialize the palette correctly from the png_store_file. *//* Get a png_struct for reading the image. This will throw an error if it
       * fails, so we don't need to check the result.
       *//* Everything is protected by a Try/Catch.  The functions called also
    * typically have local Try/Catch blocks.
    *//* Set up the display (stack frame) variables from the arguments to the
    * function and initialize the locals that are filled in later.
    *//* A single test run checking the standard image to ensure it is not damaged. *//*check_end: see comments above*//* Validate the image - progressive reading only produces one variant for
    * interlaced images.
    *//* This avoids false positives if the validation code is never called! *//* At the end both the 'row' and 'display' arrays should end up identical.
    * In earlier passes 'row' will be partially filled in, with only the pixels
    * that have been read so far, but 'display' will have those pixels
    * replicated to fill the unread pixels while reading an interlaced image.
    *//* The row must be pre-initialized to the magic number here for the size
    * tests to pass:
    *//* This exists because prior to 1.5.18 the progressive reader left the
       * png_struct z_stream unreset at the end of the image, so subsequent
       * attempts to use it simply returns Z_STREAM_END.
       *//* Remove the ", " at the end *//* And finish the read operation (only really necessary if the caller wants
    * to find additional data in png_info from chunks after the last IDAT.)
    *//* The following aids (to some extent) error detection - we can
                * see where png_read_row wrote.  Use opposite values in row and
                * display to make this easier.  Don't use 0xff (which is used in
                * the image write code to fill unused bits) or 0 (which is a
                * likely value to overwrite unused bits with).
                *//* Read the row into a pair of temporary buffers, then do the
                * merge here into the output rows.
                *//* wPass may be zero or this row may not be in this pass.
             * png_read_row must not be called in either case.
             *//* PNG_READ_INTERLACING_SUPPORTED *//* Combine the new row into the old: *//* Validate this just in case. *//* USER_TRANSFORM_INFO *//* Use this opportunity to validate the png 'current' APIs: *//* In the case where the reader doesn't do the interlace it gives
       * us the y in the sub-image:
       *//* When handling interlacing some rows will be absent in each pass, the
    * callback still gets called, but with a NULL pointer.  This is checked
    * in the 'else' clause below.  We need our own 'cbRow', but we can't call
    * png_get_rowbytes because we got no info structure.
    *//*only one image*//* Call with nImages==1 because the progressive reader can only produce one
    * image.
    *//* Validate the height, width and rowbytes plus ensure that sufficient buffer
    * exists for decoding the image.
    *//* For debugging the effect of multiple calls: *//* And the info callback has to call this (or png_read_update_info - see
    * below in the png_modifier code for that variant.
    *//* Note that the validation routine has the side effect of turning on
    * interlace handling in the subsequent code.
    *//* Then ensure there is enough space for the output image(s). *//* Validate the rowbytes here again. *//* handle filler as faked alpha channel *//* Record cbRow now that it can be found. *//* This must be called *after* the png_read_update_info call to get the correct
 * 'rowbytes' value, otherwise png_get_rowbytes will refer to the untransformed
 * image.
 *//* Caller calls png_read_update_info or png_start_read_image now, then calls
    * part2.
    *//* !READ_INTERLACING *//* This should never happen: the relevant tests (!do_interlace) should
          * not be run.
          *//* Read the number of passes - expected to match the value used when
    * creating the image (interlaced or not).  This has the side effect of
    * turning on interlace handling (if do_interlace is not set.)
    *//* Not expected because it should result in the array case
             * above.
             *//* In any case always check for a transparent color (notice that the
    * colour type 3 case must not give a successful return on the get_tRNS call
    * with these arguments!)
    *//* Validate the colour type 3 palette (this can be present on other color
    * types.)
    *//* Important: this is validating the value *before* any transforms have been
    * put in place.  It doesn't matter for the standard tests, where there are
    * no transforms, but it does for other tests where rowbytes may change after
    * png_read_update_info.
    *//* All 8 bits in tRNS for a palette image are significant - see the
          * spec.
          *//* !COLOR *//* Record (but don't check at present) the input sBIT according to the colour
    * type information.
    *//* By passing a 'standard_display' the progressive callbacks can be used
 * directly by the sequential code, the functions suffixed "_imp" are the
 * implementations, the functions without the suffix are the callbacks.
 *
 * The code for the info callback is split into two because this callback calls
 * png_read_update_info or png_start_read_image and what gets called depends on
 * whether the info needs updating (we want to test both calls in pngvalid.)
 *//* npalette is aliased *//* Utility to validate the palette if it should not have changed (the
 * non-transform case).
 *//* no transparency *//* flag value *//* No palette transparency - just set the alpha channel to opaque. *//* transparency *//* Any of these are crash-worthy - given the implementation of
       * png_get_tRNS up to 1.5 an app won't crash if it just checks the
       * result above and fails to check that the variables it passed have
       * actually been filled in!  Note that if the app were to pass the
       * last, png_color_16 *, variable too it couldn't rely on this.
       *//* TODO: fix this in libpng. *//* Oops, if a palette tRNS gets expanded png_read_update_info (at least so
       * far as 1.5.4) does not remove the trans_alpha pointer, only num_trans,
       * so in the above call we get a success, we get a pointer (who knows what
       * to) and we get num_trans == 0:
       *//*returns 1 for a transparent color*//* force error below *//* But there is no palette, so record this: *//* !png_get_PLTE *//* Mark the remainder of the entries with a flag value (other than
       * white/opaque which is the flag value stored above.)
       *//* Utility to read the palette from the PNG file and convert it into
 * store_palette format.  This returns 1 if there is any transparency in the
 * palette (it does not check for a transparent colour in the non-palette case.)
 *//* GCC can't handle the more obviously optimizable version. *//* Check for a non-opaque palette entry: *//* The remaining entries remain white/opaque. *//* Initialize the palette fields - this must be done later because the palette
 * comes from the particular png_store_file that is selected.
 *//* Preset the palette to full intensity/opaque throughout: *//* Preset the transparent color to black: *//* All the rest are filled in after the read_info: *//* Number of entries in the palette. *//* The transparent color, if set. *//* Call update_info, not start_image *//* Doing a speed test *//* color type GRAY or RGB with a tRNS chunk. *//* Transparency information was present. *//* App (row) data is little endian *//* Do interlacing internally *//* Bytes in a row of the output image *//* Width of output row in bits *//* Width of one pixel in bits *//* Number of interlaced passes *//* Height of image *//* Width of image *//* Calculated file ID *//* Output has a filler *//* Input data sBIT values. *//* Test parameters (passed to the function) *//* Because we want to use the same code in both the progressive reader and the
 * sequential reader it is necessary to deal with the fact that the progressive
 * reader callbacks only have one parameter (png_get_progressive_ptr()), so this
 * must contain all the test parameters and all the local variables directly
 * accessible to the sequential reader implementation.
 *
 * The technique adopted is to reinvent part of what Dijkstra termed a
 * 'display'; an array of pointers to the stack frames of enclosing functions so
 * that a nested function definition can access the local (C auto) variables of
 * the functions that contain its definition.  In fact C provides the first
 * pointer (the local variables - the stack frame pointer) and the last (the
 * global variables - the BCPL global vector typically implemented as global
 * addresses), this code requires one more pointer to make the display - the
 * local variables (and function call parameters) of the function that actually
 * invokes either the progressive or sequential reader.
 *
 * Perhaps confusingly this technique is confounded with classes - the
 * 'standard_display' defined here is sub-classed as the 'gamma_display' below.
 * A gamma_display is a standard_display, taking advantage of the ANSI-C
 * requirement that the pointer to the first member of a structure must be the
 * same as the pointer to the structure.  This allows us to reuse standard_
 * functions in the gamma test code; something that could not be done with
 * nested functions!
 *//* a leap second *//* Arbitrary settings: *//* The handle into the formatting code is the RFC1123 support; this test does
    * nothing if that is compiled out.
    *//* This is just to validate the internal PNG formatting code - if this fails
 * then the warning messages the library outputs will probably be garbage.
 *//* Need to do this here because we just write in this test. *//* else there are no cases that work! *//* PNG_WARNINGS_SUPPORTED *//* The following deletes the file that was just written. *//* image writing *//* do_own_interlace *//*data always bigendian*//* The row must not be written if it doesn't exist,
                         * notice that there are two conditions here, either the
                         * row isn't ever in the pass or the row would be but
                         * isn't wide enough to contribute any pixels.  In fact
                         * the wPass test can be used to skip the whole y loop
                         * in this case.
                         *//* If do_own_interlace *and* the image is interlaced we
                      * need a reduced interlace row; this may be reduced to
                      * empty.
                      *//* Now write the whole image, just to make sure that the detected, or
          * undetected, error has not created problems inside libpng.  This
          * doesn't work if there was a png_error in png_write_info because that
          * can abort before PLTE was written.
          *//* And clear these flags *//* expected exit *//* If we get here there is a problem, we have success - no error or
          * no warning - when we shouldn't have success.  Log an error.
          *//* And handle the case where it was only a warning: *//* Normally the error is only detected here: *//* Expect this to throw: *//* Time for a few errors; these are in various optional chunks, the
       * standard tests test the standard chunks pretty well.
       *//*do tRNS*//* no warnings makes these errors undetectable prior to 1.7.0 *//* the error is a warning... *//* Now we know the bit depth we can easily generate an invalid sBIT entry *//* 0 is invalid... *//* TODO: the 'set' functions can probably all be made to take a
 * const png_struct* rather than a modifiable one.
 *//* Like 'make_standard' but errors are deliberately introduced into the calls
 * to ensure that they get detected - it should not be possible to write an
 * invalid image with libpng!
 *//* Tests - individual test cases *//* Return a row based on image id and 'y' for checking: *//*palette: max 8 bits*//* Arguments are colour_type, low bit depth, high bit depth
    *//* This is in case of errors. *//* 1.7.0 removes the hack that prevented app write of an interlaced
             * image if WRITE_INTERLACE was not supported
             *//* The four combinations of DIY interlace and interlace or not -
             * no interlace + DIY should be identical to no interlace with
             * libpng doing it.
             *//* Use the png_store returned by the exception. This may help the compiler
       * because 'ps' is not used in this branch of the setjmp.  Note that fault
       * and ps will always be the same value.
       *//* And store this under the appropriate id, then clean up. *//* Use a compressed text string to test the correct interaction of text
          * compression and IDAT compression.
          *//*method*//* Only get to here if the row has some pixels in it, set the
                * filters to 'all' for the very first row and thereafter to a
                * single filter.  It isn't well documented, but png_set_filter
                * does accept a filter number (per the spec) as well as a bit
                * mask.
                *
                * The code now uses filters at random, except that on the first
                * row of an image it ensures that a previous row filter is in
                * the set so that libpng allocates the row buffer.
                *//* Set to all 1's for error detection (libpng tends to
                      * set unset things to 0).
                      *//* The row must not be written if it doesn't exist, notice
                   * that there are two conditions here, either the row isn't
                   * ever in the pass or the row would be but isn't wide
                   * enough to contribute any pixels.  In fact the wPass test
                   * can be used to skip the whole y loop in this case.
                   *//* If do_interlace *and* the image is interlaced we
                * need a reduced interlace row; this may be reduced
                * to empty.
                *//* If do_interlace is set we don't call png_write_row for every
             * row because some of them are empty.  In fact, for a 1x1 image,
             * most of them are empty!
             *//* The following two are for checking the macros: *//* Prepare the whole image first to avoid making it 7 times: *//* To help consistent error detection make the parts of this buffer
          * that aren't set below all '1':
          *//* Calculate the bit size, divide by 8 to get the byte size - this won't
       * overflow because we know the w values are all small enough even for
       * a system where 'unsigned int' is only 16 bits.
       *//* Yuck: the text must be writable! *//* must be writeable *//* In the event of a problem return control to the Catch statement below
       * to do the clean up - it is not possible to 'return' directly from a Try
       * block.
       *//* Make a name and get an appropriate id for the store: *//* There may be up to 7 remaining bits, these go in the most significant
    * bits of the byte.
    *//* the following ensures bits are set in small images: *//* height is in the range 1 to 16, so: *//* Build a single row for the 'size' test images; this fills in only the
 * first bit_width bits of the sample row.
 *//* Use next_format to enumerate all the combinations we test, including
    * generating multiple low bit depth palette images. Non-A images (palette
    * and direct) are created with and without tRNS chunks.
    *//* The row must not be written if it doesn't exist, notice
                      * that there are two conditions here, either the row isn't
                      * ever in the pass or the row would be but isn't wide
                      * enough to contribute any pixels.  In fact the wPass test
                      * can be used to skip the whole y loop in this case.
                      *//* If do_own_interlace *and* the image is interlaced we need a
                   * reduced interlace row; this may be reduced to empty.
                   *//* do_own_interlace is a pre-defined boolean (a #define) which is
             * set if we have to work out the interlaced rows here.
             *//* Somewhat confusingly this must be called *after* png_write_info
          * because if it is called before, the information in *pp has not been
          * updated to reflect the interlaced image.
          *//* !WRITE_FILTER *//* There may be no filters; skip the setting. *//* Choose filters randomly except that on the very first row ensure that
    * there is at least one previous row filter.
    *//* Make a standardized image given an image colour type, bit depth and
 * interlace type.  The standard images have a very restricted range of
 * rows and heights and are used for testing transforms rather than image
 * layout details.  See make_size_images below for a way to make images
 * that test odd sizes along with the libpng interlace handling.
 *//* The inverse of the above, 'row' is part of row 'y' of the output image,
    * in 'buffer'.  The image is 'w' wide and this is pass 'pass', distribute
    * the pixels of row into buffer and return the number written (to allow
    * this to be checked).
    *//* Note that this can, trivially, be optimized to a memcpy on pass 7, the
    * code is presented this way to make it easier to understand.  In practice
    * consult the code in the libpng source to see other ways of doing this.
    *
    * It is OK for buffer and imageRow to be identical, because 'xin' moves
    * faster than 'xout' and we copy up.
    *//* The following two routines use the PNG interlace support macros from
 * png.h to interlace or deinterlace rows.
 *//* no libpng read interlace support *//* Do the same thing for read interlacing; this controls whether read tests do
 * their own de-interlace or use libpng.
 *//* WRITE_INTERLACING tests *//* libpng 1.7+ *//* This is an internal error - --interlace tests should be skipped, not
       * attempted.
       *//* Prior to 1.7.0 libpng does not support the write of an interlaced image
    * unless PNG_WRITE_INTERLACING_SUPPORTED, even with do_interlace so the
    * code here does the pixel interlace itself, so:
    *//* This is just a helper for compiling on minimal systems with no write
 * interlacing support.  If there is no write interlacing we can't generate test
 * cases with interlace:
 *//* This is just to do the right cast - could be changed to a function to check
 * 'bd' but there isn't much point.
 *//* As above in the 32 bit case. *//* y is maximum 2047, giving 4x65536 pixels, make 'r' increase by 1 at
          * each pixel, g increase by 257 (0x101) and 'b' by 0x1111:
          *//* 65535 pixels, r, g, b, a; just replicate *//* Three bytes per pixel, r, g, b, make b by r^g *//* 65535 pixels, but rotate the values. *//* Generate all 65536 pixel values in order, which includes the 8 bit
          * GA case as well as the 16 bit G case.
          *//* 256 bytes total, 128 bytes in each row set as follows: *//* This won't overflow: *//* The following can only be defined here, now we have the definitions
 * of the transform image sizes.
 *//* Error, will be caught later *//* 4 x 65536 pixels. *//* 65536 pixels *//* Total of 65536 pixels *//* Total of 256 pixels/bytes *//* Total of 128 pixels *//* transform_width(pp, colour_type, bit_depth) current returns the same number
 * every time, so just use a macro:
 *//* Maximum range of size images *//* The larger of the two *//* 16 pixels, max 8 bytes each - 128 bytes *//* The number of passes is related to the interlace type. There was no libpng
 * API to determine this prior to 1.5, so we need an inquiry function:
 *//* bit_depth == 16 *//*RGB*//* makes unset fields random *//* To make this useful the tRNS color needs to match at least one pixel.
    * Random values are fine for gray, including the 16-bit case where we know
    * that the test image contains all the gray values.  For RGB we need more
    * method as only 65536 different RGB values are generated.
    *//*color*//* Fill in the remainder with a detectable value: *//* Set all the entries, but skip trailing opaque entries *//* Just in case fill in the rest with detectable values: *//* Set all entries to detect overread errors. *//* TODO: the png_struct* here can probably be 'const' in the future *//* Initialize a standard palette on a write stream.  The 'do_tRNS' argument
 * indicates whether or not to also set the tRNS chunk.
 *//* 'values' contains 256 ARGB values, but we only need 'npalette'.
       * 'npalette' will always be a power of 2: 2, 4, 16 or 256.  In the low
       * bit depth cases select colors at random, else it is difficult to have
       * a set of low bit depth palette test with any chance of a reasonable
       * range of colors.  Do this by randomly permuting values into the low
       * 'npalette' entries using an XOR mask generated here.  This also
       * permutes the npalette == 256 case in a potentially useful way (there is
       * no relationship between palette index and the color value therein!)
       *//* no transparency/tRNS chunk *//* Fill in the alpha values in the first byte.  Just use all possible values
    * (0..255) in an apparently random order:
    *//* Finally add 192 colors at random - don't worry about matches to things we
    * already have, chance is less than 1/65536.  Don't worry about grays,
    * chance is the same, so we get a duplicate or extra gray less than 1 time
    * in 170.
    *//*but not white*//*need these*//*got black*//* Then add 62 grays (one quarter of the remaining 256 slots). *//* Always put in black and white plus the six primary and secondary colors.
    *//* Make a 'standard' palette.  Because there are only 256 entries in a palette
 * (maximum) this actually makes a random palette in the hope that enough tests
 * will catch enough errors.  (Note that the same palette isn't produced every
 * time for the same test - it depends on what previous tests have been run -
 * but a given set of arguments to pngvalid will always produce the same palette
 * at the same test!  This is why pseudo-random number generators are useful for
 * testing.)
 *
 * The store must be open for write when this is called, otherwise an internal
 * error will occur.  This routine contains its own magic number seed, so the
 * palettes generated don't change if there are intervening errors (changing the
 * calls to the store_mark seed.)
 *//* There are two basic forms of standard images.  Those which attempt to have
 * all the possible pixel values (not possible for 16bpp images, but a range of
 * values are produced) and those which have a range of image sizes.  The former
 * are used for testing transforms, in particular gamma correction and bit
 * reduction and increase.  The latter are reserved for testing the behavior of
 * libpng with respect to 'odd' image sizes - particularly small images where
 * rows become 1 byte and interlace passes disappear.
 *
 * The first, most useful, set are the 'transform' images, the second set of
 * small images are the 'size' images.
 *
 * The transform files are constructed with rows which fit into a 1024 byte row
 * buffer.  This makes allocation easier below.  Further regardless of the file
 * format every row has 128 pixels (giving 1024 bytes for 64bpp formats).
 *
 * Files are stored with no gAMA or sBIT chunks, with a PLTE only when needed
 * and with an ID derived from the colour type, bit depth and interlace type
 * as above (FILEID).  The width (128) and height (variable) are not stored in
 * the FILEID - instead the fields are set to 0, indicating a transform file.
 *
 * The size files ar constructed with rows a maximum of 128 bytes wide, allowing
 * a maximum width of 16 pixels (for the 64bpp case.)  They also have a maximum
 * height of 16 rows.  The width and height are stored in the FILEID and, being
 * non-zero, indicate a size file.
 *
 * Because the PNG filter code is typically the largest CPU consumer within
 * libpng itself there is a tendency to attempt to optimize it.  This results in
 * special case code which needs to be validated.  To cause this to happen the
 * 'size' images are made to use each possible filter, in so far as this is
 * possible for smaller images.
 *
 * For palette image (colour type 3) multiple transform images are stored with
 * the same bit depth to allow testing of more colour combinations -
 * particularly important for testing the gamma code because libpng uses a
 * different code path for palette images.  For size images a single palette is
 * used.
 *//* Standard files - write and save standard files. *//***************************** STANDARD PNG FILES *****************************//* do nothing *//* Remove the sBIT chunk *//* if valid, else *delete* sRGB chunks *//* As above, ignore add and just make a new chunk *//* Chromaticities (in fixed point): *//* Original end points: *//* As with gAMA this just adds the required cHRM chunk to the buffer. *//* This simply dumps the given gamma value into the buffer. *//* Standard modifications to add chunks.  These do not require the _SUPPORTED
 * macros because the chunks can be there regardless of whether this specific
 * libpng supports them.
 *//******************************** MODIFICATIONS *******************************//* Do this first so that the modifier fields are cleared even if an error
    * happens allocating the png_struct.  No allocation is done here so no
    * cleanup is required.
    *//* Set up a modifier. *//* Check the invariants at the end (if this fails it's a problem in this
    * file!)
    *//* Check for EOF: *//* Check that this number of bytes are available (in the current buffer.)
       * (This doesn't quite work - the modifier might delete a chunk; unlikely
       * but possible, it doesn't happen at present because the modifier only
       * adds chunks to standard images.)
       *//* Generate 15 more bits of stuff: *//* This is another Horowitz and Hill random noise generator.  In this case
    * the aim is to stress the progressive reader with truly horrible variable
    * buffer sizes in the range 1..500, so a sequence of 9 bit random numbers
    * is generated.  We could probably just count from 1 to 32767 and get as
    * good a result.
    *//* Like store_progressive_read but the data is getting changed as we go so we
 * need a local buffer.
 *//* The callback: *//* Here to read from the modifier buffer (not directly from
       * the store, as in the flush case above.)
       *//* Take the data from the buffer (if there is any). *//* data + crc *//* The chunk may have been removed: *//* Terminate the while loop *//* Remove this chunk *//* Check for a modification, else leave it be. *//* If we get to here then this chunk may need to be modified.  To
             * do this it must be less than 1024 bytes in total size, otherwise
             * it just gets flushed.
             *//* out of switch *//* Don't do any further processing if the buffer was modified -
                * otherwise the code will end up modifying a chunk that was
                * just added.
                *//* out of while *//* The buffer has been filled with something (we assume)
                         * so output this.  Pend the current chunk.
                         *//* Reset the CRC on a new chunk *//*add*//* Regardless of what the modify function does do not run
                      * this again.
                      *//* Terminators first, they may have to be delayed for added
             * chunks
             *//* Check for something to modify or a terminator chunk. *//* No more bytes to flush, read a header, or handle a pending
             * chunk.
             *//* Read a new chunk and process it until we see PLTE, IDAT or
             * IEND.  'flush' indicates that there is still some data to
             * output from the preceding chunk.
             *//* Cache information from the IHDR (the modified one.) *//* Ignore removal or add if IHDR! *//* Check the list of modifiers for modifications to the IHDR. *//* IHDR *//* signature. *//* Separate the callback into the actual implementation (which is passed the
 * png_modifier explicitly) and the callback, which gets the modifier from the
 * png_struct.
 *//* The cast to png_uint_32 is safe because a crc32 is always a 32 bit value.
    *//* Recalculate the chunk CRC - a complete chunk must be in
    * the buffer, at the start.
    *//* The guts of modification are performed during a read. *//* Enquiry functions to find out what is set.  Notice that there is an implicit
 * assumption below that the first encoding in the list is the one for sRGB.
 *//* Linear, only in the 16 bit case *//* The gammas[] array is an array of screen gammas, not encoding gammas,
       * so we need the inverse:
       *//* Now, if required, set the gamma and encoding fields. *//* not ignored yet - happens in _ini functions. *//* Set the encoding to the one specified by the current encoding counter,
    * first clear out all the settings - this corresponds to an encoding_counter
    * of 0.
    *//* The following must be called before anything else to get the encoding set up
 * on the modifier.  In particular it must be called before the transform init
 * functions are called.
 *//* These only become value after IHDR is read: *//* The following must be set in the next run.  In particular
    * test_uses_encodings must be set in the _ini function of each transform
    * that looks at the encodings.  (Not the 'add' function!)
    *//* Not exhaustive - choose an encoding at random; generate a number in
          * the range 1..(max-1), so the result is always non-zero:
          *//* This will stop the repeat *//* Some transform is encoding dependent *//* Else something needs the current encoding again. *//* (4) encodings with gamma == 1.0 *//* The following test only works after the first time through the
       * png_modifier code because 'bit_depth' is set when the IHDR is read.
       * modifier_reset, below, preserves the setting until after it has called
       * the iterate function (also below.)
       *
       * For this reason do not rely on this function outside a call to
       * modifier_reset.
       *//* (3) total number of encodings *//* (2) gamma values to test *//* (1) nothing *//* Iterate through the usefully testable color encodings.  An encoding is one
 * of:
 *
 * 1) Nothing (no color space, no gamma).
 * 2) Just a gamma value from the gamma array (including 1.0)
 * 3) A color space from the encodings array with the corresponding gamma.
 * 4) The same, but with gamma 1.0 (only really useful with 16 bit calculations)
 *
 * The iterator selects these in turn, the randomizer selects one at random,
 * which is used depends on the setting of the 'test_exhaustive' flag.  Notice
 * that this function changes the colour space encoding so it must only be
 * called on completion of the previous test.  This is what 'modifier_reset'
 * does, below.
 *
 * After the function has been called the 'repeat' flag will still be set; the
 * caller of modifier_reset must reset it at the start of each run of the test!
 *//* Chunk was removed *//* Chunk was added *//* Chunk was modified *//* If the following is set to PLTE, IDAT or IEND and the chunk has not been
    * found and modified (and there is a modify_fn) the modify_fn will be called
    * to add the chunk before the relevant chunk.
    *//* If the following is NULL all matching chunks will be removed: *//* One modification structure must be provided for each chunk to be modified (in
 * fact more than one can be provided if multiple separate changes are desired
 * for a single chunk.)  Modifications include adding a new chunk when a
 * suitable chunk does not exist.
 *
 * The caller of modify_fn will reset the CRC of the chunk and record 'modified'
 * or 'added' as appropriate if the modify_fn returns 1 (true).  If the
 * modify_fn is NULL the chunk is simply removed.
 *//* This complements the above by providing the appropriate quantization for the
 * final value.  Normally this would just be quantization to an integral value,
 * but in the 8 bit calculation case it's actually quantization to a multiple of
 * 257!
 *//* This is the case where the value was calculated at 8-bit precision then
    * scaled to 16 bits.
    *//* switched off *//* The command line parameters are either 8 bit (0..255) or 16 bit (0..65535)
    * and so must be adjusted for low bit depth grayscale:
    *//* This does the same thing as the above however it returns the value to log,
 * rather than raising a warning.  This is useful for debugging to track down
 * exactly what set of parameters cause high error values.
 *//* There is a serious error in the 2 and 4 bit grayscale transform because
    * the gamma table value (8 bits) is simply shifted, not rounded, so the
    * error in 4 bit grayscale gamma is up to the value below.  This is a hack
    * to allow pngvalid to succeed:
    *
    * TODO: fix this in libpng
    *//* Output error - the error in the encoded value.  This is determined by the
 * digitization of the output so can be +/-0.5 in the actual output value.  In
 * the expand_16 case with the current code in libpng the expand happens after
 * all the calculations are done in 8 bit arithmetic, so even though the output
 * depth is 16 the output error is determined by the 8 bit calculation.
 *
 * This limit is not determined by the bit depth of internal calculations.
 *
 * The specified parameter does *not* include the base .5 digitization error but
 * it is added here.
 *//* Percentage error permitted in the linear values.  Note that the specified
    * value is a percentage but this routine returns a simple number.
    *//* Error in the linear composition arithmetic - only relevant when
    * composition actually happens (0 < alpha < 1).
    *//* Absolute error permitted in linear values - affected by the bit depth of
    * the calculations.
    *//* RGB_TO_GRAY *//* Limiting the range is done as a convenience to the caller - it's easier to
    * do it once here than every time at the call site.
    *//* 'value' is in the range 0 to 1, the result is the same value rounded to a
    * multiple of the digitization factor - 8 or 16 bits depending on both the
    * sample depth and the 'assume' setting.  Digitization is normally by
    * rounding and 'do_round' should be 1, if it is 0 the digitized value will
    * be truncated.
    *//* If pm->calculations_use_input_precision is set then operations will happen
 * with the precision of the input, not the precision of the output depth.
 *
 * If pm->assume_16_bit_calculations is set then even 8 bit calculations use 16
 * bit precision.  This only affects those of the following limits that pertain
 * to a calculation - not a digitization operation - unless the following API is
 * called directly.
 *//* This controls use of checks that explicitly know how libpng digitizes the
 * samples in calculations; setting this circumvents simple error limit checking
 * in the rgb_to_gray check, replacing it with an exact copy of the libpng 1.5
 * algorithm.
 *//* Rely on the memset for all the other fields - there are no pointers *//* Means 'off' *//* This returns true if the test should be stopped now because it has already
 * failed and it is running silently.
  *//* Position in buffer *//* Bytes in buffer *//* Count of bytes to flush *//* Buffer information, the buffer size limits the size of the chunks that can
    * be modified - they must fit (including header and CRC) into the buffer!
    *//* Log max error *//* Whether or not to run the low-bit-depth grayscale tests.  This fails on
    * gamma images in some cases because of gross inaccuracies in the grayscale
    * gamma handling for low bit depth.
    *//* main tests *//* Which gamma tests to run: *//* If set assume that the calculations are done in 16 bits even if the sample
    * depth is 8 bits.
    *//* If set assume that the calculation bit depth is set by the input
    * precision, not the output precision.
    *//* When to use the use_input_precision option, this controls the gamma
    * validation code checks.  If set any value that is within the transformed
    * range input-.5 to input+.5 will be accepted, otherwise the value must be
    * within the normal limits.  It should not be necessary to set this; the
    * result should always be exact within the permitted error limits.
    *//* Includes tRNS images *//* Run tests on reading with a combination of transforms, *//* Run the odd-sized image and interlace read/write tests? *//* Run the standard tests? *//* int, but must store '1' *//* Whether or not to interlace. *//* Whether to call png_read_update_info, not png_read_start_image, and how
    * many times to call it.
    *//* Flags: *//* Logged 8 and 16 bit errors ('output' values): *//* Absolute error in 16 bits to log *//* Absolute error in 8 bits to log *//* Log limits - values above this are logged, but not necessarily
    * warned.
    *//* limit on error values, normally 4E-3 *//* This is set by transforms that need to allow a higher limit, it is an
    * internal check on pngvalid to ensure that the calculated error limits are
    * not ridiculous; without this it is too easy to make a mistake in pngvalid
    * that allows any value through.
    *
    * NOTE: this is not checked in release builds.
    *//* Percentage sample error 0..100% *//* Absolute sample error 0..1 *//* Maximum output value error *//* Error control - these are the limits on errors accepted by the gamma tests
    * below.
    *//* Lowest sbit to test (pre-1.7 libpng fails for sbit < 8) *//* Repeat this transform test. *//* Control variables used to iterate through possible encodings, the
    * following must be set to 0 and tested by the function that uses the
    * png_modifier because the modifier only sets it to 1 (true.)
    *//* Something overwrote it *//* For iteration *//* If an encoding has been set *//* 0 if not set *//* Number of gamma tests to run*//* Test values *//* While handling PLTE, IDAT and IEND these chunks may be pended to allow
    * other chunks to be inserted.
    *//* From IHDR *//* Information from IHDR: *//* My state *//* Changes to make *//* I am a png_store *//* READ_TRANSFORMS *//* READ_TRANSFORMS && READ_cHRM *//* End points *//* Encoding (file) gamma of space *//* A description of an (R,G,B) encoding of color (as defined above); this
    * includes the actual colors of the (R,G,B) triples (1,0,0), (0,1,0) and
    * (0,0,1) plus an encoding value that is used to encode the linear
    * components R, G and B to give the actual values R^gamma, G^gamma and
    * B^gamma that are stored.
    *//* A single CIE tristimulus value, representing the unique response of a
    * standard observer to a variety of light spectra.  The observer recognizes
    * all spectra that produce this response as the same color, therefore this
    * is effectively a description of a color.
    *//* Have an IHDR *//* Have a signature *//* Initial value *//* Files may be modified on read.  The following structure contains a complete
 * png_store together with extra members to handle modification and a special
 * read callback for libpng.  To use this the 'modifications' field must be set
 * to a list of png_modification structures that actually perform the
 * modification, otherwise a png_modifier is functionally equivalent to a
 * png_store.  There is a special read function, set_modifier_for_read, which
 * replaces set_store_for_read.
 *//*********************** PNG FILE MODIFICATION ON READ ************************//* The overall cleanup of a store simply calls the above then removes all the
 * saved files.  This does not delete the store itself.
 *//* Both the create APIs can return NULL if used in their default mode
    * (because there is no other way of handling an error because the jmp_buf
    * by default is stored in png_struct and that has not been allocated!)
    * However, given that store_error works correctly in these circumstances
    * we don't ever expect NULL in this program.
    *//* Set the name for png_error *//* The main interface for reading a saved file - pass the id number of the file
 * to retrieve.  Ids must be unique or the earlier file will be hidden.  The API
 * returns a png_struct* and, optionally, a png_info*.  Both of these will be
 * destroyed by store_read_reset above.
 *//* just a cache *//* Always do this to be safe. *//* error already output: continue *//* Cleanup when finished reading (either due to error or in the success case).
 * This routine exists even when there is no read support to make the code
 * tidier (avoid a mass of ifdefs) and so easier to maintain.
 *//* Don't do the slow memory checks if doing a speed test, also if user
       * memory is not supported we can't do it anyway.
       *//* The following is the main write function, it returns a png_struct* and,
 * optionally, a png_info* suitable for writing a new PNG file.  Use
 * store_storefile above to record this file after it has been written.  The
 * returned libpng structures as destroyed by store_write_reset above.
 *//* And make sure that all the memory has been freed - this will output
    * spurious errors in the case of memory corruption above, but this is safe.
    *//* memory corruption: continue. *//* Cleanup when aborting a write or after storing the new file. *//* Setup functions. *//* PNG_USER_MEM_SUPPORTED *//* Unlink this entry, *test == this. *//* First check that this 'memory' really is valid memory - it must be in the
    * pool list.  If it is, use the shared memory_free function to free it.
    *//* Because libpng calls store_free with a dummy png_struct when deleting
    * png_struct or png_info via png_destroy_struct_2 it is necessary to check
    * the passed in png_struct* to ensure it is valid, and not pass it to
    * png_error if it is not.
    *//* is_error *//* NOTE: the PNG user malloc function cannot use the png_ptr it is passed
       * other than to retrieve the allocation pointer!  libpng calls the
       * store_malloc callback in two basic cases:
       *
       * 1) From png_malloc; png_malloc will do a png_error itself if NULL is
       *    returned.
       * 2) From png_struct or png_info structure creation; png_malloc is
       *    to return so cleanup can be performed.
       *
       * To handle this store_malloc can log a message, but can't do anything
       * else.
       *//* The memory callbacks: *//* Get a new mark too. *//* unexpected internal error *//* And reset the other fields too for the next time. *//* The NULL means this will always return, even if the memory is
          * corrupted.
          *//* Finally give the library a chance to find problems too: *//* It should be safe to read the size field now. *//* Note that pp may be NULL (see store_pool_delete below), the caller has
    * found 'memory' in pool->list *and* unlinked this entry, so this is a valid
    * pointer (for sure), but the contents may have been trashed.
    *//* error *//* Else we have to do it ourselves.  png_error eventually calls store_log,
    * above.  store_log accepts a NULL png_struct* - it just changes what gets
    * output by store_message.
    *//* Handle a fatal error in memory allocation.  This calls png_error if the
 * libpng struct is non-NULL, else it outputs a message and returns.  This means
 * that a memory problem while libpng is running will abort (png_error) the
 * handling of particular file while one in cleanup (after the destroy of the
 * struct has returned) will simply keep going and free (or attempt to free)
 * all the memory.
 *//* ID marker *//* Size of memory allocated *//* Singly linked list *//* Originating pool *//* A store_memory is simply the header for an allocated block of memory.  The
 * pointer returned to libpng is just after the end of the header block, the
 * allocated memory is followed by a second copy of the 'mark'.
 *//***************************** MEMORY MANAGEMENT*** ***************************//* The result may be null if there is no palette. *//* This is an internal error (the call has been made outside a read
    * operation.)
    *//* This function can only return NULL if called with '0'! *//* The caller must fill this in: *//* space left *//* !IDAT *//* Check for end of chunk and end-of-file; don't try to read a new
             * chunk header at this point unless instructed to do so by 'min'.
             *//* Return chunk bytes, including the CRC *//* Return the header *//* If there is still some pending IDAT data after the IDAT chunks have
          * been processed there is a problem:
          *//* 4..1 *//* IDAT crc *//* skip the input CRC *//* I.e not the CRC *//* IDAT_pos == IDAT_len *//* Ie: crc32(0UL, "IDAT", 4) *//* zero bytes may occur *//* Middle of IDATs, use 'random' to determine the number of bits
                * to use in the IDAT length.
                *//* Read the next chunk *//* End of IDATs, skip the CRC to make the code above load the
                   * next chunk header next time round.
                   *//* Output another 0 length IDAT *//* The only option here is to add a zero length IDAT, this
                * happens 25% of the time.  Because of the check above
                * chunklen-4U-chunkpos must be zero, we just need to skip the
                * CRC now.
                *//* The last (IDAT) chunk should be positioned at the CRC now: *//* all IDAT data read *//* 1..IDAT_size bytes *//* 1 byte *//* 0 bytes *//* First IDAT *//* Make a new IDAT chunk, if IDAT_len is 0 this is the first IDAT,
             * if IDAT_size is 0 this is the end.  At present this is set up
             * using a random number so that there is a 25% chance before
             * the start of the first IDAT chunk being 0 length.
             *//* The IDAT headers are constructed here; skip the input header. *//* Position read so far *//* Read the header of the next chunk: *//* end of last chunk *//* Need separate implementation and callback to allow use of the same code
 * during progressive read, where the io_ptr is set internally by libpng.
 *//* EOF or error *//* Return total bytes available for read. *//* Return the bytes available for read in the current buffer. *//*DOES NOTHING*//* while (st > 0) *//* must be equal *//* bytes left in chunk*//* chunkpos >= 8 *//* for header and CRC *//* Now process the bytes to be written.  Do this in units of the space in the
    * output (write) buffer or, at the start 4 bytes for the chunk type and
    * length limited in any case by the amount of data.
    *//* Technically this is legal, but in practice libpng never writes more than
    * the maximum chunk size at once so if it happens something weird has
    * changed inside libpng (probably).
    *//* It's valid *//* Each byte in the chunk type must be in one of the ranges 65..90, 97..122
    * (both inclusive), so:
    *//* skip image first row markers *//* The markers: *//* Then put in the marks. *//* For error checking, the whole buffer is set to 10110010 (0xb2 - 178).
    * This deliberately doesn't match the bits in the size test image which are
    * outside the image; these are set to 0xff (all 1).  To make the row
    * comparison work in the 'size' test case the size rows are pre-initialized
    * to the same value prior to calling 'standard_row'.
    *//* We have an adequate sized image; lay out the rows.  There are 2 bytes at
    * the start and three at the end of each (this ensures that the row
    * alignment starts out odd - 2+1 and changes for larger images on each row.)
    *//* These magic tags are used to detect overwrites above. *//* Called from the startup - ignore the error for the moment. *//* The buffer is deliberately mis-aligned. *//* Return a single row from the correct image. *//* These somewhat odd functions are used when reading an image to ensure that
 * the buffer is big enough, the png_struct* is for errors.
 *//* warning *//* And finally throw an exception. *//* PNG_NORETURN *//* Functions to use as PNG callbacks. *//* Internal error function, called with a png_store but no libpng stuff. *//* The warning is copied to the error buffer if there are no errors and it is
    * the first warning.  The error is copied to the error buffer if it is the
    * first error (overwriting any prior warnings).
    *//* Log an error or warning - the relevant count is always incremented. *//* Verbose output to the error stream: *//* Neither reading nor writing (or a memory error in struct delete) *//* Writing a file *//* Reading a file *//* Generate an error message (in the given buffer) *//* And save it. *//* Because the IDAT always has zlib header stuff this must be true: *//* Main interface to file storage, after writing a new PNG file (see the API
 * below) call store_storefile to store the result with the given name and id.
 *//* 0..32 *//* Return the number of bits in 'num' *//* Use this for random 32 bit values; this function makes sure the result is
 * non-zero.
 *//* Initialization and cleanup *//* The end of the new PNG file being written. *//* Position in .new *//* Used when writing a new file *//* Write fields *//* Number of rows in a single image *//* Used when re-chunking IDAT chunks *//* Row size of the image(s) *//* Size of this buffer *//* Buffer for reading interlaced images *//* Position in *next *//* Set when reading *//* Used to read a saved file *//* Read fields *//* Cache of the file store value *//* Accumulated IDAT size in .new *//* Position in chunk *//* Type of chunk (valid if chunkpos >= 4) *//* Length of chunk+overhead (chunkpos >= 8) *//* Share fields *//* Name of test *//* setting (unset,invalid,on,off) *//* option number, 0..30 *//* number of options below: *//* used as a temporary flag *//* use progressive read *//* For cexcept.h exception handling - simply store one of these;
    * the context is a self pointer but it may point to a different
    * png_store (in fact it never does in this program.)
    *//* Overall statistics (retained across successive runs). *//* Total allocation *//* Highest current allocation *//* Current allocation *//* Maximum single allocation *//* Statistics for this run. *//* Before and after data *//* List of allocated memory *//* Back pointer *//* The following is a pool of memory allocated by a single libpng read or write
 * operation.
 *//* May be NULL *//* Number of entries in palette *//* Last buffer in file *//* In this (the last) buffer *//* must be correct (see FILEID) *//* Total size of IDAT data *//* Number of bits in IDAT size *//* as many as you like... *//* record of a single palette entry *//* NOTE: stored in reverse order *//* arbitrary *//* A png_store takes data from the sequential writer or provides data
 * to the sequential reader.  It can also store the result of a PNG
 * write for later retrieval.
 *//*************************** BASIC PNG FILE WRITING ***************************//* Return the index of the changed byte. *//* Compare pixels - they are assumed to start at the first byte in the
 * given buffers.
 *//* Copy a complete row of pixels, taking into account potential partial
 * bytes at the end.
 *//* One or more bytes *//* Don't rely on << or >> supporting '0' here, just in case: *//* The following read the entire pixels and clears the extra: *//* Mask to select the location of the copied pixel: *//* Sub-byte *//* Assume we can multiply by 'size' without overflow because we are
    * just working in a single buffer.
    *//* Copy a single pixel, of a given size, from one buffer to another -
 * while this is basically bit addressed there is an implicit assumption
 * that pixels 8 or more bits in size are byte aligned and that pixels
 * do not otherwise cross byte boundaries.  (This is, so far as I know,
 * universally true in bitmap computer graphics.  [JCB 20101212])
 *
 * NOTE: The to and from buffers may be the same.
 *//* Less than 8 bits per sample.  By default PNG has the big end of
    * the egg on the left of the screen, but if littleendian is set
    * then the big end is on the right.
    *//* Return the sample from the row as an integer. *//* Multiple channels; select one: *//* Alpha channel *//* !palette *//* Find a sample index for the desired sample: *//* Move to the next color type, or return 0 at the end. *//* Palette images are restricted to 8 bit depth *//* No: next bit depth *//*PALETTE*//*GRAY*//* Add multiple palettes for colour type 3, one image with tRNS
       * and one without for other non-alpha formats:
       *//*no alpha channel*//* The following defines the number of different palettes to generate for
 * each log bit depth of a colour type 3 standard image.
 *//* Convenience API and defines to list valid formats.  Note that 16 bit read and
 * write support is required to do 16 bit read tests (we must be able to make a
 * 16 bit image to test!)
 *//* must have a palette *//* Utility to construct a standard name for a standard image. *//* A numeric ID based on PNG file characteristics.  The 'do_interlace' field
 * simply records whether pngvalid did the interlace itself or whether it
 * was done by libpng.  Width and height must be less than 256.  'palette' is an
 * index of the palette to use for formats with a palette otherwise a boolean
 * indicating if a tRNS chunk was generated.
 *//* READ_RGB_TO_GRAY || READ_FILLER *//* READ_TRANSFORMS || WRITE_FILTER *//* 0 .. max-1 *//* READ || WRITE_tRNS || WRITE_FILTER *//* READ_FILLER || READ_RGB_TO_GRAY *//* READ *//* Generate random bytes.  This uses a boring repeatable algorithm and it
 * is implemented here so that it gives the same set of numbers on every
 * architecture.  It's a linear congruential generator (Knuth or Sedgewick
 * "Algorithms") but it comes from the 'feedback taps' table in Horowitz and
 * Hill, "The Art of Electronics" (Pseudo-Random Bit Sequences and Noise
 * Generation.)
 *//* Convert a double precision value to fixed point. *//* Error handling is particularly problematic in production code - error
 * handlers often themselves have bugs which lead to programs that detect
 * minor errors crashing.  The following functions deal with one very
 * common class of errors in error handlers - attempting to format error or
 * warning messages into buffers that are too small.
 *//******************************* UTILITIES ************************************//* !GNUC broken versions *//* For the moment just do it always; all versions of GCC seem to be broken: *//* GCC BUG 66447 (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66447) requires
 * some broken GCC versions to be fixed up to avoid invalid whining about auto
 * variables that are *not* changed within the scope of a setjmp being changed.
 *
 * Feel free to extend the list of broken versions.
 *//* This macro returns the number of elements in an array as an (unsigned int),
 * it is necessary to avoid the inability of certain versions of GCC to use
 * the value of a compile-time constant when performing range checks.  It must
 * be passed an array name.
 *//* The following are macros to reduce typing everywhere where the well known
 * name 'the_exception_context' must be defined.
 *//***************************** EXCEPTION HANDLING *****************************//* Convenience macros. *//* For floor *//* For memcpy, memset *//* For malloc *//* For floating point constants *//* RELEASE_BUILD is true for releases and release candidates: *//* pngvalid requires write support and one of the fixed or floating point APIs.
 * progressive read is also required currently as the progressive read pointer
 * is used to record the 'display' structure.
 *//* For crc32 *//* from config.h, if included *//* For the floating point exception extension *//* For floating point *//* pngvalid.c - validate libpng by constructing then reading png files.
 *
 * Copyright (c) 2021-2025 Cosmin Truta
 * Copyright (c) 2014-2017 John Cunningham Bowler
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * NOTES:
 *   This is a C program that is intended to be linked against libpng.  It
 *   generates bitmaps internally, stores them as PNG files (using the
 *   sequential write code) then reads them back (using the sequential
 *   read code) and validates that the result has the correct data.
 *
 *   The program can be modified and extended to test the correctness of
 *   transformations performed by libpng.
 */ncatNO_COMPETING_THREAD_END__pragma(warning(pop))NO_COMPETING_THREAD_BEGIN__pragma(warning(push))BENIGN_RACE_ENDBENIGN_RACE_BEGIN__analysis_suppress_lock_checking(lock)__function_ignore_lock_checking(lock)__analysis_assume_lock_released(lock)__analysis_assume_lock_acquired(lock)__no_competing_thread__lock_level_order(a,b)CSALCAT2(x,y)CSALCAT1(x,y)__internal_lock_level_order(a,b)__has_lock_level(level)__declare_lock_level(level)__has_lock_property(kind)__releases_shared_lock(lock)__releases_exclusive_lock(lock)__releases_lock(lock)__acquires_shared_lock(lock)__acquires_exclusive_lock(lock)__acquires_lock(lock)__requires_no_locks_held__requires_lock_not_held(lock)__requires_shared_lock_held(lock)__requires_exclusive_lock_held(lock)__requires_lock_held(lock)__interlocked__write_guarded_by(lock)__guarded_by(lock)_Swaps_locks_(left,right)_Replaces_lock_(target,source)_Moves_lock_(target,source)_Detaches_lock_(detached,lock)_Has_lock_kind_(kind)_No_competing_thread_end__No_competing_thread_begin__Benign_race_end__Benign_race_begin__Analysis_suppress_lock_checking_(lock)_Function_ignore_lock_checking_(lock)_Analysis_assume_same_lock_(lock1,lock2)_Analysis_assume_lock_not_held_(lock)_Analysis_assume_lock_held_(lock)_Analysis_assume_lock_released_(lock)_Analysis_assume_lock_acquired_(lock)_No_competing_thread__Lock_level_order_(a,b)_Csalcat2_(x,y)_Csalcat1_(x,y)_Internal_lock_level_order_(a,b)_Has_lock_level_(level)_Create_lock_level_(level)_Internal_set_lock_count_(lock,count)_Post_same_lock_(lock1,lock2)_Releases_nonreentrant_lock_(lock)_Acquires_nonreentrant_lock_(lock)_Releases_shared_lock_(lock)_Releases_exclusive_lock_(lock)_Releases_lock_(lock)_Acquires_shared_lock_(lock)_Acquires_exclusive_lock_(lock)_Acquires_lock_(lock)_Requires_no_locks_held__Requires_lock_not_held_(lock)_Requires_shared_lock_held_(lock)_Requires_exclusive_lock_held_(lock)_Requires_lock_held_(lock)_Interlocked__Write_guarded_by_(lock)_Guarded_by_(lock)_Interlocked_operand_CONCURRENCYSAL_H!defined(__midl) && defined(_PREFAST_) && !defined(_SDV_)// CONCURRENCYSAL_H/*
 * Old spelling: will be deprecated
 *//*
 * refinement and suppression
 *//*
 * threading context
 *//*
 * lock level
 *//*
 * lock properties
 * The following kind options are supported:
 * __has_lock_property(MUTEX)
 * __has_lock_property(EVENT)
 * __has_lock_property(SEMAPHORE)
 * __has_lock_property(OTHER_HANDLE)
 * __has_lock_property(REENTRANT)
 * __has_lock_property(NON_REENTRANT)
 *//*
 * acquire/release locking side effects
 *//*
 * caller/callee locking contracts
 *//*
 * Old spelling
 * Note: the old version may be deprecated in the future!!!
 *//*
 * move semantics
 *//*
 * smart locks (RAII lock wrappers)
 *//*
 * lock kinds
 *//*
 * _Analysis_suppress_lock_checking_ may be deprecated in future versions of SAL
 *//*
 * _Function_ignore_lock_checking_ may be deprecated in future versions of SAL
 *//*
 * acquire/release locking side effects for non-reentrant locks
 *//*
 * interlocked operand used in interlocked instructions
 *//*
 * data protection
 *//*
 * Annotation identifiers
 *//*
 * pre-defined global system locks
 */// ]// [/***
*concurrencysal.h - markers for documenting the concurrent semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains macros for Concurrency SAL annotations. Definitions
*       starting with _Internal are low level macros that are subject to change.
*       Users should not use those low level macros directly.
*       [ANSI]
*
*       [Public]
*
****/<concurrencysal.h>_Raises_SEH_exception__SAL2_Source_(_Raises_SEH_exception_, (x), _Maybe_raises_SEH_exception_ _Analysis_noreturn_)_Maybe_raises_SEH_exception__SAL2_Source_(_Maybe_raises_SEH_exception_, (x), _Pre_ _SA_annotes1(SAL_inTry,__yes))_Strict_type_match__SAL2_Source_(_Strict_type_match, (), _SA_annotes0(SAL_strictType2))_Enum_is_bitflag__SAL2_Source_(_Enum_is_bitflag_, (), _SA_annotes0(SAL_enumIsBitflag))_Function_class_(x)_SAL2_Source_(_Function_class_, (x), _SA_annotes1(SAL_functionClassNew, _SA_SPECSTRIZE(x)))_Called_from_function_class_(x)_In_function_class_(x)_In_function_class_(#x)_Analysis_mode_(mode)__pragma(warning(disable: 28110 28111 28161 28162)) typedef _Analysis_mode_impl_(mode) int __GENSYM(__prefast_analysis_mode_flag);_Analysis_mode_impl_(mode)_SAL2_Source_(_Analysis_mode_impl_, (mode), _SA_annotes1(SAL_analysisMode, #mode))__GENSYM(x)__MKID(x, __COUNTER__)__MKID(x,y)___MKID(x, y)___MKID(x,y)x ## y_Analysis_assume_nullterminated_(x)_Analysis_noreturn__SAL2_Source_(_Analysis_noreturn_, (), _SA_annotes0(SAL_terminates))_Analysis_assume_(expr)__analysis_assume(expr)__fallthrough__inner_fallthrough__on_failure(annotes)_SAL1_1_Source_(__on_failure, (annotes), _On_failure_impl_(annotes _SAL_nop_impl_))__useHeader_Use_decl_anno_impl___data_entrypoint(category)_SAL_L_Source_(__data_entrypoint, (category), __inner_data_entrypoint(category))__control_entrypoint(category)_SAL_L_Source_(__control_entrypoint, (category), __inner_control_entrypoint(category))__blocksOn(resource)_SAL_L_Source_(__blocksOn, (resource), __inner_blocksOn(resource))__format_string_SAL1_1_Source_(__format_string, (), _Printf_format_string_)__callback__inner_callback__override__inner_override__typefix(ctype)_SAL1_Source_(__typefix, (ctype), __inner_typefix(ctype))__checkReturn_SAL1_Source_(__checkReturn, (), _Check_return_)__reserved_SAL1_Source_(__reserved, (), _Reserved_)__nullnullterminated_SAL1_Source_(__nullnulltermiated, (), _SAL_nop_impl_)__nullterminated_SAL1_Source_(__nullterminated, (), _Null_terminated_)__success(expr)_SAL1_1_Source_(__success, (expr), _Success_(expr))__deref_opt_inout_bcount_nz_opt(size)_SAL1_Source_(__deref_opt_inout_bcount_nz_opt, (size), __deref_opt_inout_bcount_opt(size))__deref_opt_inout_ecount_nz_opt(size)_SAL1_Source_(__deref_opt_inout_ecount_nz_opt, (size), __deref_opt_inout_ecount_opt(size))__deref_opt_inout_nz_opt_SAL1_Source_(__deref_opt_inout_nz_opt, (), __deref_opt_inout_opt)__deref_opt_inout_bcount_z_opt(size)_SAL1_Source_(__deref_opt_inout_bcount_z_opt, (size), __deref_opt_inout_bcount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated)__deref_opt_inout_ecount_z_opt(size)_SAL1_Source_(__deref_opt_inout_ecount_z_opt, (size), __deref_opt_inout_ecount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated)__deref_opt_inout_z_opt_SAL1_Source_(__deref_opt_inout_z_opt, (), __deref_opt_inout_opt __pre __deref __nullterminated __post __deref __nullterminated)__deref_opt_inout_bcount_full_opt(size)_SAL1_Source_(__deref_opt_inout_bcount_full_opt, (size), __deref_inout_bcount_full_opt(size) __pre_except_maybenull)__deref_opt_inout_ecount_full_opt(size)_SAL1_Source_(__deref_opt_inout_ecount_full_opt, (size), __deref_inout_ecount_full_opt(size) __pre_except_maybenull)__deref_opt_inout_bcount_part_opt(size,length)_SAL1_Source_(__deref_opt_inout_bcount_part_opt, (size,length), __deref_inout_bcount_part_opt(size,length) __pre_except_maybenull)__deref_opt_inout_ecount_part_opt(size,length)_SAL1_Source_(__deref_opt_inout_ecount_part_opt, (size,length), __deref_inout_ecount_part_opt(size,length) __pre_except_maybenull)__deref_opt_inout_bcount_opt(size)_SAL1_Source_(__deref_opt_inout_bcount_opt, (size), __deref_inout_bcount_opt(size) __pre_except_maybenull)__deref_opt_inout_ecount_opt(size)_SAL1_Source_(__deref_opt_inout_ecount_opt, (size), __deref_inout_ecount_opt(size) __pre_except_maybenull)__deref_opt_inout_opt_SAL1_Source_(__deref_opt_inout_opt, (), __deref_inout_opt __pre_except_maybenull)__deref_opt_out_bcount_nz_opt(size)_SAL1_Source_(__deref_opt_out_bcount_nz_opt, (size), __deref_opt_out_bcount_opt(size))__deref_opt_out_ecount_nz_opt(size)_SAL1_Source_(__deref_opt_out_ecount_nz_opt, (size), __deref_opt_out_ecount_opt(size))__deref_opt_out_nz_opt_SAL1_Source_(__deref_opt_out_nz_opt, (), __deref_opt_out_opt)__deref_opt_out_bcount_z_opt(size)_SAL1_Source_(__deref_opt_out_bcount_z_opt, (size), __deref_opt_out_bcount_opt(size) __post __deref __nullterminated)__deref_opt_out_ecount_z_opt(size)_SAL1_Source_(__deref_opt_out_ecount_z_opt, (size), __deref_opt_out_ecount_opt(size) __post __deref __nullterminated)__deref_opt_out_z_opt_SAL1_Source_(__deref_opt_out_z_opt, (), __post __deref __valid __refparam __pre_except_maybenull __pre_deref_except_maybenull __post_deref_except_maybenull __post __deref __nullterminated)__deref_opt_out_bcount_full_opt(size)_SAL1_Source_(__deref_opt_out_bcount_full_opt, (size), __deref_out_bcount_full_opt(size) __pre_except_maybenull)__deref_opt_out_ecount_full_opt(size)_SAL1_Source_(__deref_opt_out_ecount_full_opt, (size), __deref_out_ecount_full_opt(size) __pre_except_maybenull)__deref_opt_out_bcount_part_opt(size,length)_SAL1_Source_(__deref_opt_out_bcount_part_opt, (size,length), __deref_out_bcount_part_opt(size,length) __pre_except_maybenull)__deref_opt_out_ecount_part_opt(size,length)_SAL1_Source_(__deref_opt_out_ecount_part_opt, (size,length), __deref_out_ecount_part_opt(size,length) __pre_except_maybenull)__deref_opt_out_bcount_opt(size)_SAL1_Source_(__deref_opt_out_bcount_opt, (size), __deref_out_bcount_opt(size) __pre_except_maybenull)__deref_opt_out_ecount_opt(size)_SAL1_Source_(__deref_opt_out_ecount_opt, (size), __deref_out_ecount_opt(size) __pre_except_maybenull)__deref_opt_out_opt_SAL1_Source_(__deref_opt_out_opt, (), _Outptr_opt_result_maybenull_)__deref_opt_bcount_opt(size)_SAL1_Source_(__deref_opt_bcount_opt, (size), __deref_bcount_opt(size) __pre_except_maybenull)__deref_opt_ecount_opt(size)_SAL1_Source_(__deref_opt_ecount_opt, (size), __deref_ecount_opt(size) __pre_except_maybenull)__deref_opt_inout_bcount_nz(size)_SAL1_Source_(__deref_opt_inout_bcount_nz, (size), __deref_opt_inout_bcount(size))__deref_opt_inout_ecount_nz(size)_SAL1_Source_(__deref_opt_inout_ecount_nz, (size), __deref_opt_inout_ecount(size))__deref_opt_inout_nz_SAL1_Source_(__deref_opt_inout_nz, (), __deref_opt_inout)__deref_opt_inout_bcount_z(size)_SAL1_Source_(__deref_opt_inout_bcount_z, (size), __deref_opt_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated)__deref_opt_inout_ecount_z(size)_SAL1_Source_(__deref_opt_inout_ecount_z, (size), __deref_opt_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated)__deref_opt_inout_z_SAL1_Source_(__deref_opt_inout_z, (), __deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated)__deref_opt_inout_bcount_full(size)_SAL1_Source_(__deref_opt_inout_bcount_full, (size), __deref_inout_bcount_full(size) __pre_except_maybenull)__deref_opt_inout_ecount_full(size)_SAL1_Source_(__deref_opt_inout_ecount_full, (size), __deref_inout_ecount_full(size) __pre_except_maybenull)__deref_opt_inout_bcount_part(size,length)_SAL1_Source_(__deref_opt_inout_bcount_part, (size,length), __deref_inout_bcount_part(size,length) __pre_except_maybenull)__deref_opt_inout_ecount_part(size,length)_SAL1_Source_(__deref_opt_inout_ecount_part, (size,length), __deref_inout_ecount_part(size,length) __pre_except_maybenull)__deref_opt_inout_bcount(size)_SAL1_Source_(__deref_opt_inout_bcount, (size), __deref_inout_bcount(size) __pre_except_maybenull)__deref_opt_inout_ecount(size)_SAL1_Source_(__deref_opt_inout_ecount, (size), __deref_inout_ecount(size) __pre_except_maybenull)__deref_opt_inout_SAL1_Source_(__deref_opt_inout, (), _Inout_opt_)__deref_opt_out_bcount_full(size)_SAL1_Source_(__deref_opt_out_bcount_full, (size), __deref_out_bcount_full(size) __pre_except_maybenull)__deref_opt_out_ecount_full(size)_SAL1_Source_(__deref_opt_out_ecount_full, (size), __deref_out_ecount_full(size) __pre_except_maybenull)__deref_opt_out_bcount_part(size,length)_SAL1_Source_(__deref_opt_out_bcount_part, (size,length), __deref_out_bcount_part(size,length) __pre_except_maybenull)__deref_opt_out_ecount_part(size,length)_SAL1_Source_(__deref_opt_out_ecount_part, (size,length), __deref_out_ecount_part(size,length) __pre_except_maybenull)__deref_opt_out_bcount(size)_SAL1_Source_(__deref_opt_out_bcount, (size), __deref_out_bcount(size) __pre_except_maybenull)__deref_opt_out_ecount(size)_SAL1_Source_(__deref_opt_out_ecount, (size), __deref_out_ecount(size) __pre_except_maybenull)__deref_opt_out_z_SAL1_Source_(__deref_opt_out_z, (), _Outptr_opt_result_z_)__deref_opt_out_SAL1_Source_(__deref_opt_out, (), _Outptr_opt_)__deref_opt_bcount(size)_SAL1_Source_(__deref_opt_bcount, (size), __deref_bcount(size) __pre_except_maybenull)__deref_opt_ecount(size)_SAL1_Source_(__deref_opt_ecount, (size), __deref_ecount(size) __pre_except_maybenull)__deref_inout_bcount_nz_opt(size)_SAL1_Source_(__deref_inout_bcount_nz_opt, (size), __deref_inout_bcount_opt(size))__deref_inout_ecount_nz_opt(size)_SAL1_Source_(__deref_inout_ecount_nz_opt, (size), __deref_inout_ecount_opt(size))__deref_inout_nz_opt_SAL1_Source_(__deref_inout_nz_opt, (), __deref_inout_opt)__deref_inout_bcount_z_opt(size)_SAL1_Source_(__deref_inout_bcount_z_opt, (size), __deref_inout_bcount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated)__deref_inout_ecount_z_opt(size)_SAL1_Source_(__deref_inout_ecount_z_opt, (size), __deref_inout_ecount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated)__deref_inout_z_opt_SAL1_Source_(__deref_inout_z_opt, (), __deref_inout_opt __pre __deref __nullterminated __post __deref __nullterminated)__deref_inout_bcount_full_opt(size)_SAL1_Source_(__deref_inout_bcount_full_opt, (size), __deref_inout_bcount_full(size) __pre_deref_except_maybenull __post_deref_except_maybenull)__deref_inout_ecount_full_opt(size)_SAL1_Source_(__deref_inout_ecount_full_opt, (size), __deref_inout_ecount_full(size) __pre_deref_except_maybenull __post_deref_except_maybenull)__deref_inout_bcount_part_opt(size,length)_SAL1_Source_(__deref_inout_bcount_part_opt, (size,length), __deref_inout_bcount_part(size,length) __pre_deref_except_maybenull __post_deref_except_maybenull)__deref_inout_ecount_part_opt(size,length)_SAL1_Source_(__deref_inout_ecount_part_opt, (size,length), __deref_inout_ecount_part(size,length) __pre_deref_except_maybenull __post_deref_except_maybenull)__deref_inout_bcount_opt(size)_SAL1_Source_(__deref_inout_bcount_opt, (size), __deref_inout_bcount(size) __pre_deref_except_maybenull __post_deref_except_maybenull)__deref_inout_ecount_opt(size)_SAL1_Source_(__deref_inout_ecount_opt, (size), __deref_inout_ecount(size) __pre_deref_except_maybenull __post_deref_except_maybenull)__deref_inout_opt_SAL1_Source_(__deref_inout_opt, (), __deref_inout __pre_deref_except_maybenull __post_deref_except_maybenull)__deref_out_bcount_nz_opt(size)_SAL1_Source_(__deref_out_bcount_nz_opt, (size), __deref_out_bcount_opt(size))__deref_out_ecount_nz_opt(size)_SAL1_Source_(__deref_out_ecount_nz_opt, (size), __deref_out_ecount_opt(size))__deref_out_nz_opt_SAL1_Source_(__deref_out_nz_opt, (), __deref_out_opt)__deref_out_bcount_z_opt(size)_SAL1_Source_(__deref_out_bcount_z_opt, (size), __deref_out_bcount_opt(size) __post __deref __nullterminated)__deref_out_ecount_z_opt(size)_SAL1_Source_(__deref_out_ecount_z_opt, (size), __deref_out_ecount_opt(size) __post __deref __nullterminated)__deref_out_z_opt_SAL1_Source_(__deref_out_z_opt, (), _Outptr_result_maybenull_z_)__deref_out_bcount_full_opt(size)_SAL1_Source_(__deref_out_bcount_full_opt, (size), __deref_out_bcount_full(size) __post_deref_except_maybenull)__deref_out_ecount_full_opt(size)_SAL1_Source_(__deref_out_ecount_full_opt, (size), __deref_out_ecount_full(size) __post_deref_except_maybenull)__deref_out_bcount_part_opt(size,length)_SAL1_Source_(__deref_out_bcount_part_opt, (size,length), __deref_out_bcount_part(size,length) __post_deref_except_maybenull)__deref_out_ecount_part_opt(size,length)_SAL1_Source_(__deref_out_ecount_part_opt, (size,length), __deref_out_ecount_part(size,length) __post_deref_except_maybenull)__deref_out_bcount_opt(size)_SAL1_Source_(__deref_out_bcount_opt, (size), __deref_out_bcount(size) __post_deref_except_maybenull)__deref_out_ecount_opt(size)_SAL1_Source_(__deref_out_ecount_opt, (size), __deref_out_ecount(size) __post_deref_except_maybenull)__deref_out_opt_SAL1_Source_(__deref_out_opt, (), __deref_out __post_deref_except_maybenull)__deref_bcount_opt(size)_SAL1_Source_(__deref_bcount_opt, (size), __deref_bcount(size) __post_deref_except_maybenull)__deref_ecount_opt(size)_SAL1_Source_(__deref_ecount_opt, (size), __deref_ecount(size) __post_deref_except_maybenull)__deref_inout_bcount_nz(size)_SAL1_Source_(__deref_inout_bcount_nz, (size), __deref_inout_ecount(size))__deref_inout_ecount_nz(size)_SAL1_Source_(__deref_inout_ecount_nz, (size), __deref_inout_ecount(size))__deref_inout_nz_SAL1_Source_(__deref_inout_nz, (), __deref_inout)__deref_inout_bcount_z(size)_SAL1_Source_(__deref_inout_bcount_z, (size), __deref_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated)__deref_inout_ecount_z(size)_SAL1_Source_(__deref_inout_ecount_z, (size), __deref_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated)__deref_inout_bcount_full(size)_SAL1_Source_(__deref_inout_bcount_full, (size), __deref_inout_bcount_part(size,size))__deref_inout_ecount_full(size)_SAL1_Source_(__deref_inout_ecount_full, (size), __deref_inout_ecount_part(size,size))__deref_inout_bcount_part(size,length)_SAL1_Source_(__deref_inout_bcount_part, (size,length), __deref_inout_bcount(size) __pre __deref __byte_readableTo(length) __post __deref __byte_readableTo(length))__deref_inout_ecount_part(size,length)_SAL1_Source_(__deref_inout_ecount_part, (size,length), __deref_inout_ecount(size) __pre __deref __elem_readableTo(length) __post __deref __elem_readableTo(length))__deref_inout_bcount(size)_SAL1_Source_(__deref_inout_bcount, (size), __deref_inout __pre __deref __byte_writableTo(size) __post _Notref_ __deref __byte_writableTo(size))__deref_inout_ecount(size)_SAL1_Source_(__deref_inout_ecount, (size), __deref_inout __pre __deref __elem_writableTo(size) __post _Notref_ __deref __elem_writableTo(size))__deref_inout_z_SAL1_Source_(__deref_inout_z, (), __deref_inout __pre __deref __nullterminated __post _Notref_ __deref __nullterminated)__deref_inout_SAL1_Source_(__deref_inout, (), _Notref_ __notnull _Notref_ __elem_readableTo(1) __pre __deref __valid __post _Notref_ __deref __valid __refparam)__deref_out_bcount_nz(size)_SAL1_Source_(__deref_out_bcount_nz, (size), __deref_out_ecount(size))__deref_out_ecount_nz(size)_SAL1_Source_(__deref_out_ecount_nz, (size), __deref_out_ecount(size))__deref_out_nz_SAL1_Source_(__deref_out_nz, (), __deref_out)__deref_out_bcount_z(size)_SAL1_Source_(__deref_out_bcount_z, (size), __deref_out_bcount(size) __post __deref __nullterminated)__deref_out_ecount_z(size)_SAL1_Source_(__deref_out_ecount_z, (size), __deref_out_ecount(size) __post __deref __nullterminated)__deref_out_z_SAL1_Source_(__deref_out_z, (), _Outptr_result_z_)__deref_out_bcount_full(size)_SAL1_Source_(__deref_out_bcount_full, (size), __deref_out_bcount_part(size,size))__deref_out_ecount_full(size)_SAL1_Source_(__deref_out_ecount_full, (size), __deref_out_ecount_part(size,size))__deref_out_bcount_part(size,length)_SAL1_Source_(__deref_out_bcount_part, (size,length), _Outptr_result_bytebuffer_to_(size,length))__deref_out_ecount_part(size,length)_SAL1_Source_(__deref_out_ecount_part, (size,length), _Outptr_result_buffer_to_(size,length))__deref_out_bcount(size)_SAL1_Source_(__deref_out_bcount, (size), _Outptr_result_bytebuffer_(size))__deref_out_ecount(size)_SAL1_Source_(__deref_out_ecount, (size), _Outptr_result_buffer_(size))__deref_out_SAL1_Source_(__deref_out, (), _Outptr_)__deref_bcount(size)_SAL1_Source_(__deref_bcount, (size), _Notref_ __ecount(1) __post _Notref_ __elem_readableTo(1) __post _Notref_ __deref _Notref_ __notnull __post __deref __byte_writableTo(size))__deref_ecount(size)_SAL1_Source_(__deref_ecount, (size), _Notref_ __ecount(1) __post _Notref_ __elem_readableTo(1) __post _Notref_ __deref _Notref_ __notnull __post __deref __elem_writableTo(size))__inout_bcount_nz_opt(size)_SAL1_Source_(__inout_bcount_nz_opt, (size), __inout_bcount_opt(size))__inout_ecount_nz_opt(size)_SAL1_Source_(__inout_ecount_nz_opt, (size), __inout_ecount_opt(size))__inout_nz_opt_SAL1_Source_(__inout_nz_opt, (), __inout_opt)__inout_bcount_z_opt(size)_SAL1_Source_(__inout_bcount_z_opt, (size), __inout_bcount_opt(size))__inout_ecount_z_opt(size)_SAL1_Source_(__inout_ecount_z_opt, (size), __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated)__inout_z_opt_SAL1_Source_(__inout_z_opt, (), __inout_opt __pre __nullterminated __post __nullterminated)__inout_bcount_full_opt(size)_SAL1_Source_(__inout_bcount_full_opt, (size), __inout_bcount_full(size) __pre_except_maybenull)__inout_ecount_full_opt(size)_SAL1_Source_(__inout_ecount_full_opt, (size), __inout_ecount_full(size) __pre_except_maybenull)__inout_bcount_part_opt(size,length)_SAL1_Source_(__inout_bcount_part_opt, (size,length), __inout_bcount_part(size,length) __pre_except_maybenull)__inout_ecount_part_opt(size,length)_SAL1_Source_(__inout_ecount_part_opt, (size,length), __inout_ecount_part(size,length) __pre_except_maybenull)__inout_bcount_opt(size)_SAL1_Source_(__inout_bcount_opt, (size), __inout_bcount(size) __pre_except_maybenull)__inout_ecount_opt(size)_SAL1_Source_(__inout_ecount_opt, (size), __inout_ecount(size) __pre_except_maybenull)__inout_opt_SAL1_Source_(__inout_opt, (), _Inout_opt_)__out_bcount_nz_opt(size)_SAL1_Source_(__out_bcount_nz_opt, (size), __out_bcount_opt(size) __post __nullterminated)__out_ecount_nz_opt(size)_SAL1_Source_(__out_ecount_nz_opt, (size), __out_ecount_opt(size) __post __nullterminated)__out_bcount_full_z_opt(size)_SAL1_Source_(__out_bcount_full_z_opt, (size), __out_bcount_full_opt(size) __post __nullterminated)__out_ecount_full_z_opt(size)_SAL1_Source_(__out_ecount_full_z_opt, (size), __out_ecount_full_opt(size) __post __nullterminated)__out_bcount_part_z_opt(size,length)_SAL1_Source_(__out_bcount_part_z_opt, (size,length), __out_bcount_part_opt(size,length) __post __nullterminated)__out_ecount_part_z_opt(size,length)_SAL1_Source_(__out_ecount_part_z_opt, (size,length), __out_ecount_part_opt(size,length) __post __nullterminated)__out_bcount_z_opt(size)_SAL1_Source_(__out_bcount_z_opt, (size), __out_bcount_opt(size) __post __nullterminated)__out_ecount_z_opt(size)_SAL1_Source_(__out_ecount_z_opt, (size), __out_ecount_opt(size) __post __nullterminated)__out_bcount_full_opt(size)_SAL1_Source_(__out_bcount_full_opt, (size), __out_bcount_full(size) __pre_except_maybenull)__out_ecount_full_opt(size)_SAL1_Source_(__out_ecount_full_opt, (size), __out_ecount_full(size) __pre_except_maybenull)__out_bcount_part_opt(size,length)_SAL1_Source_(__out_bcount_part_opt, (size,length), __out_bcount_part(size,length) __pre_except_maybenull)__out_ecount_part_opt(size,length)_SAL1_Source_(__out_ecount_part_opt, (size,length), __out_ecount_part(size,length) __pre_except_maybenull)__out_bcount_opt(size)_SAL1_Source_(__out_bcount_opt, (size), _Out_writes_bytes_opt_(size))__out_ecount_opt(size)_SAL1_Source_(__out_ecount_opt, (size), _Out_writes_opt_(size))__out_opt_SAL1_Source_(__out_opt, (), _Out_opt_)__in_bcount_nz_opt(size)_SAL1_Source_(__in_bcount_nz_opt, (size), __in_bcount_opt(size))__in_ecount_nz_opt(size)_SAL1_Source_(__in_ecount_nz_opt, (size), __in_ecount_opt(size))__in_nz_opt_SAL1_Source_(__in_nz_opt, (), __in_opt)__in_bcount_z_opt(size)_SAL1_Source_(__in_bcount_z_opt, (size), __in_bcount_opt(size) __pre __nullterminated)__in_ecount_z_opt(size)_SAL1_Source_(__in_ecount_z_opt, (size), __in_ecount_opt(size) __pre __nullterminated)__in_z_opt_SAL1_Source_(__in_z_opt, (), _In_opt_z_)__in_bcount_opt(size)_SAL1_Source_(__in_bcount_opt, (size), _In_reads_bytes_opt_(size))__in_ecount_opt(size)_SAL1_Source_(__in_ecount_opt, (size), _In_reads_opt_(size))__in_opt_SAL1_Source_(__in_opt, (), _In_opt_)__bcount_opt(size)_SAL1_Source_(__bcount_opt, (size), __bcount(size) __pre_except_maybenull)__ecount_opt(size)_SAL1_Source_(__ecount_opt, (size), __ecount(size) __pre_except_maybenull)__inout_bcount_nz(size)_SAL1_Source_(__inout_bcount_nz, (size), __inout_bcount(size))__inout_ecount_nz(size)_SAL1_Source_(__inout_ecount_nz, (size), __inout_ecount(size))__inout_nz_SAL1_Source_(__inout_nz, (), __inout)__inout_bcount_z(size)_SAL1_Source_(__inout_bcount_z, (size), __inout_bcount(size) __pre __nullterminated __post __nullterminated)__inout_ecount_z(size)_SAL1_Source_(__inout_ecount_z, (size), _Inout_updates_z_(size))__inout_z_SAL1_Source_(__inout_z, (), _Inout_z_)__inout_bcount_full(size)_SAL1_Source_(__inout_bcount_full, (size), _Inout_updates_bytes_all_(size))__inout_ecount_full(size)_SAL1_Source_(__inout_ecount_full, (size), _Inout_updates_all_(size))__inout_bcount_part(size,length)_SAL1_Source_(__inout_bcount_part, (size,length), _Inout_updates_bytes_to_(size,length))__inout_ecount_part(size,length)_SAL1_Source_(__inout_ecount_part, (size,length), _Inout_updates_to_(size,length))__inout_bcount(size)_SAL1_Source_(__inout_bcount, (size), _Inout_updates_bytes_(size))__inout_ecount(size)_SAL1_Source_(__inout_ecount, (size), _Inout_updates_(size))__inout_SAL1_Source_(__inout, (), _Inout_)__out_bcount_nz(size)_SAL1_Source_(__out_bcount_nz, (size), __bcount(size) __post __valid __refparam)__out_ecount_nz(size)_SAL1_Source_(__out_ecount_nz, (size), __ecount(size) __post __valid __refparam)__out_nz_opt_SAL1_Source_(__out_nz_opt, (), __post __valid __refparam __post_except_maybenull_)__out_nz_SAL1_Source_(__out_nz, (), __post __valid __refparam)__out_bcount_full_z(size)_SAL1_Source_(__out_bcount_full_z, (size), __out_bcount_full(size) __post __nullterminated)__out_ecount_full_z(size)_SAL1_Source_(__out_ecount_full_z, (size), __out_ecount_full(size) __post __nullterminated)__out_bcount_part_z(size,length)_SAL1_Source_(__out_bcount_part_z, (size,length), __out_bcount_part(size,length) __post __nullterminated)__out_ecount_part_z(size,length)_SAL1_Source_(__out_ecount_part_z, (size,length), __out_ecount_part(size,length) __post __nullterminated)__out_bcount_z(size)_SAL1_Source_(__out_bcount_z, (size), __bcount(size) __post __valid __refparam __post __nullterminated)__out_ecount_z(size)_SAL1_Source_(__out_ecount_z, (size), __ecount(size) __post __valid __refparam __post __nullterminated)__out_z_opt_SAL1_Source_(__out_z_opt, (), __post __valid __refparam __post __nullterminated __pre_except_maybenull)__out_z_SAL1_Source_(__out_z, (), __post __valid __refparam __post __nullterminated)__out_bcount_full(size)_SAL1_Source_(__out_bcount_full, (size), _Out_writes_bytes_all_(size))__out_ecount_full(size)_SAL1_Source_(__out_ecount_full, (size), _Out_writes_all_(size))__out_bcount_part(size,length)_SAL1_Source_(__out_bcount_part, (size,length), _Out_writes_bytes_to_(size,length))__out_ecount_part(size,length)_SAL1_Source_(__out_ecount_part, (size,length), _Out_writes_to_(size,length))__out_bcount(size)_SAL1_Source_(__out_bcount, (size), _Out_writes_bytes_(size))__out_ecount(size)_SAL1_Source_(__out_ecount, (size), _Out_writes_(size))__out_SAL1_Source_(__out, (), _Out_)__in_bcount_nz(size)_SAL1_Source_(__in_bcount_nz, (size), __in_bcount(size))__in_ecount_nz(size)_SAL1_Source_(__in_ecount_nz, (size), __in_ecount(size))__in_nz_SAL1_Source_(__in_nz, (), __in)__in_bcount_z(size)_SAL1_Source_(__in_bcount_z, (size), __in_bcount(size) __pre __nullterminated)__in_ecount_z(size)_SAL1_Source_(__in_ecount_z, (size), _In_reads_z_(size))__in_z_SAL1_Source_(__in_z, (), _In_z_)__in_bcount(size)_SAL1_Source_(__in_bcount, (size), _In_reads_bytes_(size))__in_ecount(size)_SAL1_Source_(__in_ecount, (size), _In_reads_(size))__in_SAL1_Source_(__in, (), _In_)__bcount(size)_SAL1_Source_(__bcount, (size), __notnull __byte_writableTo(size))__ecount(size)_SAL1_Source_(__ecount, (size), __notnull __elem_writableTo(size))__inexpressible_writableTo(size)__inexpressible_readableTo(size)__pre_deref_except_maybenull__post_deref_except_maybenull__pre_except_maybenull__post_except_maybenull__inner_data_entrypoint(category)__inner_control_entrypoint(category)__refparam__inner_fallthrough_dec__inner_blocksOn(resource)__exceptthat__postcond(expr)__precond(expr)__post__pre__deref__byte_writableTo(size)__elem_writableTo(size)__writableTo(size)__byte_readableTo(size)__elem_readableTo(size)__readableTo(extent)__maybevalid__notvalid__valid__maybereadonly__notreadonly__readonly__maybenull__notnull__null__nothrow__specstrings__inner_exceptthat__inner_typefix(ctype)_NullNull_terminated_impl__Null_terminated_impl__Writable_elements_impl_(size)_Writable_bytes_impl_(size)_Readable_elements_impl_(size)_Readable_bytes_impl_(size)_Deref2_ret1_impl_(p1)_Deref2_post1_impl_(p1)_Deref2_pre1_impl_(p1)_Deref_ret3_impl_(p1,p2,p3)_Deref_ret2_impl_(p1,p2)_Deref_ret1_impl_(p1)_Deref_post3_impl_(p1,p2,p3)_Deref_post2_impl_(p1,p2)_Deref_post1_impl_(p1)_Deref_pre3_impl_(p1,p2,p3)_Deref_pre2_impl_(p1,p2)_Deref_pre1_impl_(p1)_Ret3_impl_(p1,p2,p3)_Ret2_impl_(p1,p2)_Ret1_impl_(p1)_Post3_impl_(p1,p2,p3)_Post2_impl_(p1,p2)_Post1_impl_(p1)_Post_impl__Pre3_impl_(p1,p2,p3)_Pre2_impl_(p1,p2)_Pre1_impl_(p1)_Pre_impl__Field_range_impl_(min,max)_Maybevalid_impl__Notvalid_impl__Valid_impl__Maybenull_impl__Notnull_impl__Null_impl__Post_satisfies_impl_(expr)_Pre_satisfies_impl_(expr)_Satisfies_impl_(expr)_Deref_ret_range_impl_(min,max)_Deref_out_range_impl_(min,max)_Deref_in_range_impl_(min,max)_Ret_range_impl_(min,max)_Out_range_impl_(min,max)_In_range_impl_(min,max)_Range_impl_(min,max)_Deref_ret_bound_impl__Deref_out_bound_impl__Deref_in_bound_impl__Ret_bound_impl__Out_bound_impl__In_bound_impl__Always_impl_(annos)_On_failure_impl_(annos)_Success_impl_(expr)_Must_inspect_impl__Ret_valid_impl__Pre_valid_impl__Notref_impl__Notliteral_impl__Literal_impl__Points_to_data_impl__At_buffer_impl_(target,iter,bound,annos)_GrouP_impl_(annos)_Group_impl_(annos)_When_impl_(expr,annos)_At_impl_(target,annos)__QUALIFIER(type,fun)__PRIMOP(type,fun)__ANNOTATION(fun)_SA_annotes3(n,pp1,pp2,pp3)_SA_annotes2(n,pp1,pp2)_SA_annotes1(n,pp1)_SA_annotes0(n)_Deref_inout_z__SAL1_1_Source_(_Deref_inout_z_, (), _Deref_prepost_z_)_Deref_inout_z_bytecap_c_(size)_SAL1_1_Source_(_Deref_inout_z_bytecap_c_, (size), _Deref_pre_z_bytecap_c_(size) _Deref_post_z_)_Deref_out_z_bytecap_c_(size)_SAL1_1_Source_(_Deref_out_z_bytecap_c_, (size), _Deref_pre_bytecap_c_(size) _Deref_post_z_)_Deref_inout_z_cap_c_(size)_SAL1_1_Source_(_Deref_inout_z_cap_c_, (size), _Deref_pre_z_cap_c_(size) _Deref_post_z_)_Deref_out_z_cap_c_(size)_SAL1_1_Source_(_Deref_out_z_cap_c_, (size), _Deref_pre_cap_c_(size) _Deref_post_z_)_Deref_prepost_opt_valid__SAL1_1_Source_(_Deref_prepost_opt_valid_, (), _Deref_pre_opt_valid_ _Deref_post_opt_valid_)_Deref_prepost_valid__SAL1_1_Source_(_Deref_prepost_valid_, (), _Deref_pre_valid_ _Deref_post_valid_)_Deref_prepost_opt_bytecount_x_(size)_SAL1_1_Source_(_Deref_prepost_opt_bytecount_x_, (size), _Deref_pre_opt_bytecount_x_(size) _Deref_post_opt_bytecount_x_(size))_Deref_prepost_bytecount_x_(size)_SAL1_1_Source_(_Deref_prepost_bytecount_x_, (size), _Deref_pre_bytecount_x_(size) _Deref_post_bytecount_x_(size))_Deref_prepost_opt_count_x_(size)_SAL1_1_Source_(_Deref_prepost_opt_count_x_, (size), _Deref_pre_opt_count_x_(size) _Deref_post_opt_count_x_(size))_Deref_prepost_count_x_(size)_SAL1_1_Source_(_Deref_prepost_count_x_, (size), _Deref_pre_count_x_(size) _Deref_post_count_x_(size))_Deref_prepost_opt_bytecount_(size)_SAL1_1_Source_(_Deref_prepost_opt_bytecount_, (size), _Deref_pre_opt_bytecount_(size) _Deref_post_opt_bytecount_(size))_Deref_prepost_bytecount_(size)_SAL1_1_Source_(_Deref_prepost_bytecount_, (size), _Deref_pre_bytecount_(size) _Deref_post_bytecount_(size))_Deref_prepost_opt_count_(size)_SAL1_1_Source_(_Deref_prepost_opt_count_, (size), _Deref_pre_opt_count_(size) _Deref_post_opt_count_(size))_Deref_prepost_count_(size)_SAL1_1_Source_(_Deref_prepost_count_, (size), _Deref_pre_count_(size) _Deref_post_count_(size))_Deref_prepost_opt_valid_bytecap_x_(size)_SAL1_1_Source_(_Deref_prepost_opt_valid_bytecap_x_, (size), _Deref_pre_opt_valid_bytecap_x_(size) _Deref_post_opt_valid_bytecap_x_(size))_Deref_prepost_valid_bytecap_x_(size)_SAL1_1_Source_(_Deref_prepost_valid_bytecap_x_, (size), _Deref_pre_valid_bytecap_x_(size) _Deref_post_valid_bytecap_x_(size))_Deref_prepost_opt_valid_cap_x_(size)_SAL1_1_Source_(_Deref_prepost_opt_valid_cap_x_, (size), _Deref_pre_opt_valid_cap_x_(size) _Deref_post_opt_valid_cap_x_(size))_Deref_prepost_valid_cap_x_(size)_SAL1_1_Source_(_Deref_prepost_valid_cap_x_, (size), _Deref_pre_valid_cap_x_(size) _Deref_post_valid_cap_x_(size))_Deref_prepost_opt_valid_bytecap_(size)_SAL1_1_Source_(_Deref_prepost_opt_valid_bytecap_, (size), _Deref_pre_opt_valid_bytecap_(size) _Deref_post_opt_valid_bytecap_(size))_Deref_prepost_valid_bytecap_(size)_SAL1_1_Source_(_Deref_prepost_valid_bytecap_, (size), _Deref_pre_valid_bytecap_(size) _Deref_post_valid_bytecap_(size))_Deref_prepost_opt_valid_cap_(size)_SAL1_1_Source_(_Deref_prepost_opt_valid_cap_, (size), _Deref_pre_opt_valid_cap_(size) _Deref_post_opt_valid_cap_(size))_Deref_prepost_valid_cap_(size)_SAL1_1_Source_(_Deref_prepost_valid_cap_, (size), _Deref_pre_valid_cap_(size) _Deref_post_valid_cap_(size))_Deref_prepost_opt_z_bytecap_(size)_SAL1_1_Source_(_Deref_prepost_opt_z_bytecap_, (size), _Deref_pre_opt_z_bytecap_(size) _Deref_post_opt_z_bytecap_(size))_Deref_prepost_z_bytecap_(size)_SAL1_1_Source_(_Deref_prepost_z_bytecap_, (size), _Deref_pre_z_bytecap_(size) _Deref_post_z_bytecap_(size))_Deref_prepost_opt_z_cap_(size)_SAL1_1_Source_(_Deref_prepost_opt_z_cap_, (size), _Deref_pre_opt_z_cap_(size) _Deref_post_opt_z_cap_(size))_Deref_prepost_z_cap_(size)_SAL1_1_Source_(_Deref_prepost_z_cap_, (size), _Deref_pre_z_cap_(size) _Deref_post_z_cap_(size))_Deref_prepost_opt_bytecap_x_(size)_SAL1_1_Source_(_Deref_prepost_opt_bytecap_x_, (size), _Deref_pre_opt_bytecap_x_(size) _Deref_post_opt_bytecap_x_(size))_Deref_prepost_bytecap_x_(size)_SAL1_1_Source_(_Deref_prepost_bytecap_x_, (size), _Deref_pre_bytecap_x_(size) _Deref_post_bytecap_x_(size))_Deref_prepost_opt_cap_x_(size)_SAL1_1_Source_(_Deref_prepost_opt_cap_x_, (size), _Deref_pre_opt_cap_x_(size) _Deref_post_opt_cap_x_(size))_Deref_prepost_cap_x_(size)_SAL1_1_Source_(_Deref_prepost_cap_x_, (size), _Deref_pre_cap_x_(size) _Deref_post_cap_x_(size))_Deref_prepost_opt_bytecap_(size)_SAL1_1_Source_(_Deref_prepost_opt_bytecap_, (size), _Deref_pre_opt_bytecap_(size) _Deref_post_opt_bytecap_(size))_Deref_prepost_bytecap_(size)_SAL1_1_Source_(_Deref_prepost_bytecap_, (size), _Deref_pre_bytecap_(size) _Deref_post_bytecap_(size))_Deref_prepost_opt_cap_(size)_SAL1_1_Source_(_Deref_prepost_opt_cap_, (size), _Deref_pre_opt_cap_(size) _Deref_post_opt_cap_(size))_Deref_prepost_cap_(size)_SAL1_1_Source_(_Deref_prepost_cap_, (size), _Deref_pre_cap_(size) _Deref_post_cap_(size))_Deref_prepost_opt_z__SAL1_1_Source_(_Deref_prepost_opt_z_, (), _Deref_pre_opt_z_ _Deref_post_opt_z_)_Deref_prepost_z__SAL1_1_Source_(_Deref_prepost_z_, (), _Deref_pre_z_ _Deref_post_z_)_SAL1_1_Source_(_Prepost_opt_valid_, (), _Pre_opt_valid_ _Post_valid_)_SAL1_1_Source_(_Prepost_valid_, (), _Pre_valid_ _Post_valid_)_Prepost_opt_bytecount_x_(size)_SAL1_1_Source_(_Prepost_opt_bytecount_x_, (size), _Pre_opt_bytecount_x_(size) _Post_bytecount_x_(size))_Prepost_bytecount_x_(size)_SAL1_1_Source_(_Prepost_bytecount_x_, (size), _Pre_bytecount_x_(size) _Post_bytecount_x_(size))_Prepost_opt_count_x_(size)_SAL1_1_Source_(_Prepost_opt_count_x_, (size), _Pre_opt_count_x_(size) _Post_count_x_(size))_Prepost_count_x_(size)_SAL1_1_Source_(_Prepost_count_x_, (size), _Pre_count_x_(size) _Post_count_x_(size))_Prepost_opt_bytecount_c_(size)_SAL1_1_Source_(_Prepost_opt_bytecount_c_, (size), _Pre_opt_bytecount_c_(size) _Post_bytecount_c_(size))_Prepost_bytecount_c_(size)_SAL1_1_Source_(_Prepost_bytecount_c_, (size), _Pre_bytecount_c_(size) _Post_bytecount_c_(size))_Prepost_opt_count_c_(size)_SAL1_1_Source_(_Prepost_opt_count_c_, (size), _Pre_opt_count_c_(size) _Post_count_c_(size))_Prepost_count_c_(size)_SAL1_1_Source_(_Prepost_count_c_, (size), _Pre_count_c_(size) _Post_count_c_(size))_Prepost_opt_bytecount_(size)_SAL1_1_Source_(_Prepost_opt_bytecount_, (size), _Pre_opt_bytecount_(size) _Post_bytecount_(size))_Prepost_bytecount_(size)_SAL1_1_Source_(_Prepost_bytecount_, (size), _Pre_bytecount_(size) _Post_bytecount_(size))_Prepost_opt_count_(size)_SAL1_1_Source_(_Prepost_opt_count_, (size), _Pre_opt_count_(size) _Post_count_(size))_Prepost_count_(size)_SAL1_1_Source_(_Prepost_count_, (size), _Pre_count_(size) _Post_count_(size))_Prepost_opt_z__SAL1_1_Source_(_Prepost_opt_z_, (), _Pre_opt_z_ _Post_z_)_Post_z_bytecount_x_(size)_SAL1_1_Source_(_Post_z_bytecount_x_, (size), _Post2_impl_(__zterm_impl,__bytecount_x_impl(size)) _Post_valid_impl_)_Post_z_count_x_(size)_SAL1_1_Source_(_Post_z_count_x_, (size), _Post2_impl_(__zterm_impl,__count_x_impl(size)) _Post_valid_impl_)_Post_z_bytecount_c_(size)_SAL1_1_Source_(_Post_z_bytecount_c_, (size), _Post2_impl_(__zterm_impl,__bytecount_c_impl(size)) _Post_valid_impl_)_Post_z_count_c_(size)_SAL1_1_Source_(_Post_z_count_c_, (size), _Post2_impl_(__zterm_impl,__count_c_impl(size)) _Post_valid_impl_)_Post_z_bytecount_(size)_SAL1_1_Source_(_Post_z_bytecount_, (size), _Post2_impl_(__zterm_impl,__bytecount_impl(size)) _Post_valid_impl_)_Post_z_count_(size)_SAL1_1_Source_(_Post_z_count_, (size), _Post2_impl_(__zterm_impl,__count_impl(size)) _Post_valid_impl_)_Post_bytecount_x_(size)_SAL1_1_Source_(_Post_bytecount_x_, (size), _Post1_impl_(__bytecount_x_impl(size)) _Post_valid_impl_)_Post_count_x_(size)_SAL1_1_Source_(_Post_count_x_, (size), _Post1_impl_(__count_x_impl(size)) _Post_valid_impl_)_Post_bytecount_c_(size)_SAL1_1_Source_(_Post_bytecount_c_, (size), _Post1_impl_(__bytecount_c_impl(size)) _Post_valid_impl_)_Post_count_c_(size)_SAL1_1_Source_(_Post_count_c_, (size), _Post1_impl_(__count_c_impl(size)) _Post_valid_impl_)_Post_bytecount_(size)_SAL1_1_Source_(_Post_bytecount_, (size), _Post1_impl_(__bytecount_impl(size)) _Post_valid_impl_)_Post_count_(size)_SAL1_1_Source_(_Post_count_, (size), _Post1_impl_(__count_impl(size)) _Post_valid_impl_)_Post_bytecap_(size)_SAL1_1_Source_(_Post_bytecap_, (size), _Post1_impl_(__bytecap_impl(size)))_Post_cap_(size)_SAL1_1_Source_(_Post_cap_, (size), _Post1_impl_(__cap_impl(size)))_SAL_L_Source_(_Post_maybez_, (), _Post1_impl_(__maybezterm_impl))_Pre_opt_ptrdiff_count_(ptr)_SAL1_1_Source_(_Pre_opt_ptrdiff_count_, (ptr), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_x_impl(__ptrdiff(ptr))) _Pre_valid_impl_)_Pre_ptrdiff_count_(ptr)_SAL1_1_Source_(_Pre_ptrdiff_count_, (ptr), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_x_impl(__ptrdiff(ptr))) _Pre_valid_impl_)_Pre_opt_bytecount_x_(size)_SAL1_1_Source_(_Pre_opt_bytecount_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)_Pre_bytecount_x_(size)_SAL1_1_Source_(_Pre_bytecount_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)_Pre_opt_count_x_(size)_SAL1_1_Source_(_Pre_opt_count_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_x_impl(size)) _Pre_valid_impl_)_Pre_count_x_(size)_SAL1_1_Source_(_Pre_count_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_x_impl(size)) _Pre_valid_impl_)_Pre_opt_bytecount_c_(size)_SAL1_1_Source_(_Pre_opt_bytecount_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)_Pre_bytecount_c_(size)_SAL1_1_Source_(_Pre_bytecount_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)_Pre_opt_count_c_(size)_SAL1_1_Source_(_Pre_opt_count_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_c_impl(size)) _Pre_valid_impl_)_Pre_count_c_(size)_SAL1_1_Source_(_Pre_count_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_c_impl(size)) _Pre_valid_impl_)_Pre_opt_bytecount_(size)_SAL1_1_Source_(_Pre_opt_bytecount_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)_Pre_bytecount_(size)_SAL1_1_Source_(_Pre_bytecount_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)_Pre_opt_count_(size)_SAL1_1_Source_(_Pre_opt_count_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_impl(size)) _Pre_valid_impl_)_Pre_count_(size)_SAL1_1_Source_(_Pre_count_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_impl(size)) _Pre_valid_impl_)_Pre_opt_valid_bytecap_x_(size)_SAL1_1_Source_(_Pre_opt_valid_bytecap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)_Pre_valid_bytecap_x_(size)_SAL1_1_Source_(_Pre_valid_bytecap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)_Pre_opt_valid_cap_x_(size)_SAL1_1_Source_(_Pre_opt_valid_cap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_x_impl(size)) _Pre_valid_impl_)_Pre_valid_cap_x_(size)_SAL1_1_Source_(_Pre_valid_cap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_x_impl(size)) _Pre_valid_impl_)_Pre_opt_valid_bytecap_c_(size)_SAL1_1_Source_(_Pre_opt_valid_bytecap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)_Pre_valid_bytecap_c_(size)_SAL1_1_Source_(_Pre_valid_bytecap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)_Pre_opt_valid_cap_c_(size)_SAL1_1_Source_(_Pre_opt_valid_cap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_impl(size)) _Pre_valid_impl_)_Pre_valid_cap_c_(size)_SAL1_1_Source_(_Pre_valid_cap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_impl(size)) _Pre_valid_impl_)_Pre_opt_valid_bytecap_(size)_SAL1_1_Source_(_Pre_opt_valid_bytecap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(size)) _Pre_valid_impl_)_Pre_valid_bytecap_(size)_SAL1_1_Source_(_Pre_valid_bytecap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl(size)) _Pre_valid_impl_)_Pre_opt_valid_cap_(size)_SAL1_1_Source_(_Pre_opt_valid_cap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(size)) _Pre_valid_impl_)_Pre_valid_cap_(size)_SAL1_1_Source_(_Pre_valid_cap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(size)) _Pre_valid_impl_)_Pre_opt_z_bytecap_x_(size)_SAL1_1_Source_(_Pre_opt_z_bytecap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)_Pre_z_bytecap_x_(size)_SAL1_1_Source_(_Pre_z_bytecap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)_Pre_opt_z_cap_x_(size)_SAL1_1_Source_(_Pre_opt_z_cap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_x_impl(size)) _Pre_valid_impl_)_Pre_z_cap_x_(size)_SAL1_1_Source_(_Pre_z_cap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_x_impl(size)) _Pre_valid_impl_)_Pre_opt_z_bytecap_c_(size)_SAL1_1_Source_(_Pre_opt_z_bytecap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)_Pre_z_bytecap_c_(size)_SAL1_1_Source_(_Pre_z_bytecap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)_Pre_opt_z_cap_c_(size)_SAL1_1_Source_(_Pre_opt_z_cap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_c_impl(size)) _Pre_valid_impl_)_Pre_z_cap_c_(size)_SAL1_1_Source_(_Pre_z_cap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_c_impl(size)) _Pre_valid_impl_)_Pre_opt_z_bytecap_(size)_SAL1_1_Source_(_Pre_opt_z_bytecap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_impl(size)) _Pre_valid_impl_)_Pre_z_bytecap_(size)_SAL1_1_Source_(_Pre_z_bytecap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_impl(size)) _Pre_valid_impl_)_Pre_opt_z_cap_(size)_SAL1_1_Source_(_Pre_opt_z_cap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_impl(size)) _Pre_valid_impl_)_Pre_z_cap_(size)_SAL1_1_Source_(_Pre_z_cap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_impl(size)) _Pre_valid_impl_)_Pre_opt_ptrdiff_cap_(ptr)_SAL1_1_Source_(_Pre_opt_ptrdiff_cap_, (ptr), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_x_impl(__ptrdiff(ptr))))_Pre_ptrdiff_cap_(ptr)_SAL1_1_Source_(_Pre_ptrdiff_cap_, (ptr), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_x_impl(__ptrdiff(ptr))))_Pre_opt_bytecap_x_(size)_SAL1_1_Source_(_Pre_opt_bytecap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)))_Pre_bytecap_x_(size)_SAL1_1_Source_(_Pre_bytecap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)))_Pre_opt_cap_x_(size)_SAL1_1_Source_(_Pre_opt_cap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_x_impl(size)))_Pre_cap_x_(size)_SAL1_1_Source_(_Pre_cap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_x_impl(size)))_Pre_opt_cap_for_(param)_SAL1_1_Source_(_Pre_opt_cap_for_, (param), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_for_impl(param)))_Pre_cap_for_(param)_SAL1_1_Source_(_Pre_cap_for_, (param), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_for_impl(param)))_Pre_opt_cap_m_(mult,size)_SAL1_1_Source_(_Pre_opt_cap_m_, (mult,size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__mult_impl(mult,size)))_Pre_cap_m_(mult,size)_SAL1_1_Source_(_Pre_cap_m_, (mult,size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__mult_impl(mult,size)))_Pre_opt_cap_c_one__SAL1_1_Source_(_Pre_opt_cap_c_one_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_one_notref_impl))_Pre_cap_c_one__SAL1_1_Source_(_Pre_cap_c_one_, (), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_one_notref_impl))_Pre_opt_bytecap_c_(size)_SAL1_1_Source_(_Pre_opt_bytecap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)))_Pre_bytecap_c_(size)_SAL1_1_Source_(_Pre_bytecap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)))_Pre_opt_cap_c_(size)_SAL1_1_Source_(_Pre_opt_cap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_impl(size)))_Pre_cap_c_(size)_SAL1_1_Source_(_Pre_cap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_impl(size)))_Pre_opt_bytecap_(size)_SAL1_1_Source_(_Pre_opt_bytecap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(size)))_Pre_bytecap_(size)_SAL1_1_Source_(_Pre_bytecap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl(size)))_Pre_opt_cap_(size)_SAL1_1_Source_(_Pre_opt_cap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(size)))_Pre_cap_(size)_SAL1_1_Source_(_Pre_cap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(size)))_Pre_writeonly__SAL1_1_Source_(_Pre_writeonly_, (), _Pre1_impl_(__writeaccess_impl_notref))_Pre_readonly__SAL1_1_Source_(_Pre_readonly_, (), _Pre1_impl_(__readaccess_impl_notref))_Pre_opt_z__SAL1_1_Source_(_Pre_opt_z_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__zterm_impl) _Pre_valid_impl_)_Ret_opt_z_bytecount_(size)_SAL1_1_Source_(_Ret_opt_z_bytecount_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecount_impl(size)) _Ret_valid_impl_)_Ret_z_bytecount_(size)_SAL1_1_Source_(_Ret_z_bytecount_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecount_impl(size)) _Ret_valid_impl_)_Ret_opt_z_count_(size)_SAL1_1_Source_(_Ret_opt_z_count_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__count_impl(size)) _Ret_valid_impl_)_Ret_z_count_(size)_SAL1_1_Source_(_Ret_z_count_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__count_impl(size)) _Ret_valid_impl_)_Ret_opt_bytecount_x_(size)_SAL1_1_Source_(_Ret_opt_bytecount_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecount_x_impl(size)) _Ret_valid_impl_)_Ret_bytecount_x_(size)_SAL1_1_Source_(_Ret_bytecount_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecount_x_impl(size)) _Ret_valid_impl_)_Ret_opt_count_x_(size)_SAL1_1_Source_(_Ret_opt_count_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__count_x_impl(size)) _Ret_valid_impl_)_Ret_count_x_(size)_SAL1_1_Source_(_Ret_count_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__count_x_impl(size)) _Ret_valid_impl_)_Ret_opt_bytecount_c_(size)_SAL1_1_Source_(_Ret_opt_bytecount_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecount_c_impl(size)) _Ret_valid_impl_)_Ret_bytecount_c_(size)_SAL1_1_Source_(_Ret_bytecount_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecount_c_impl(size)) _Ret_valid_impl_)_Ret_opt_count_c_(size)_SAL1_1_Source_(_Ret_opt_count_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__count_c_impl(size)) _Ret_valid_impl_)_Ret_count_c_(size)_SAL1_1_Source_(_Ret_count_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__count_c_impl(size)) _Ret_valid_impl_)_Ret_opt_bytecount_(size)_SAL1_1_Source_(_Ret_opt_bytecount_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecount_impl(size)) _Ret_valid_impl_)_Ret_bytecount_(size)_SAL1_1_Source_(_Ret_bytecount_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecount_impl(size)) _Ret_valid_impl_)_Ret_opt_count_(size)_SAL1_1_Source_(_Ret_opt_count_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__count_impl(size)) _Ret_valid_impl_)_Ret_count_(size)_SAL1_1_Source_(_Ret_count_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__count_impl(size)) _Ret_valid_impl_)_Ret_opt_z_bytecap_(size)_SAL1_1_Source_(_Ret_opt_z_bytecap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecap_impl(size)) _Ret_valid_impl_)_Ret_z_bytecap_(size)_SAL1_1_Source_(_Ret_z_bytecap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecap_impl(size)) _Ret_valid_impl_)_Ret_opt_z_cap_(size)_SAL1_1_Source_(_Ret_opt_z_cap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__cap_impl(size)) _Ret_valid_impl_)_Ret_z_cap_(size)_SAL1_1_Source_(_Ret_z_cap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__cap_impl(size)) _Ret_valid_impl_)_Ret_opt_bytecap_x_(size)_SAL1_1_Source_(_Ret_opt_bytecap_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecap_x_impl(size)))_Ret_bytecap_x_(size)_SAL1_1_Source_(_Ret_bytecap_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecap_x_impl(size)))_Ret_opt_cap_x_(size)_SAL1_1_Source_(_Ret_opt_cap_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__cap_x_impl(size)))_Ret_cap_x_(size)_SAL1_1_Source_(_Ret_cap_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__cap_x_impl(size)))_Ret_opt_bytecap_c_(size)_SAL1_1_Source_(_Ret_opt_bytecap_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecap_c_impl(size)))_Ret_bytecap_c_(size)_SAL1_1_Source_(_Ret_bytecap_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecap_c_impl(size)))_Ret_opt_cap_c_(size)_SAL1_1_Source_(_Ret_opt_cap_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__cap_c_impl(size)))_Ret_cap_c_(size)_SAL1_1_Source_(_Ret_cap_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__cap_c_impl(size)))_Ret_opt_bytecap_(size)_SAL1_1_Source_(_Ret_opt_bytecap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecap_impl(size)))_Ret_bytecap_(size)_SAL1_1_Source_(_Ret_bytecap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecap_impl(size)))_Ret_opt_cap_(size)_SAL1_1_Source_(_Ret_opt_cap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__cap_impl(size)))_Ret_cap_(size)_SAL1_1_Source_(_Ret_cap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__cap_impl(size)))_Ret_opt_z__SAL1_1_Source_(_Ret_opt_z_, (), _Ret2_impl_(__maybenull_impl,__zterm_impl) _Ret_valid_impl_)_Ret_opt_valid__SAL1_1_Source_(_Ret_opt_valid_, (), _Ret1_impl_(__maybenull_impl_notref) _Ret_valid_impl_)_Deref2_pre_readonly__SAL1_1_Source_(_Deref2_pre_readonly_, (), _Deref2_pre1_impl_(__readaccess_impl_notref))_Deref_ret_opt_z__SAL1_1_Source_(_Deref_ret_opt_z_, (), _Deref_ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__zterm_impl))_Deref_ret_z__SAL1_1_Source_(_Deref_ret_z_, (), _Deref_ret1_impl_(__notnull_impl_notref) _Deref_ret1_impl_(__zterm_impl))_SAL1_1_Source_(_Deref_post_null_, (), _Deref_post1_impl_(__null_impl_notref))_Deref_post_maybenull__SAL1_1_Source_(_Deref_post_maybenull_, (), _Deref_post1_impl_(__maybenull_impl_notref))_Deref_post_notnull__SAL1_1_Source_(_Deref_post_notnull_, (), _Deref_post1_impl_(__notnull_impl_notref))_Deref_post_opt_valid__SAL1_1_Source_(_Deref_post_opt_valid_, (), _Deref_post1_impl_(__maybenull_impl_notref) _Post_valid_impl_)_SAL1_1_Source_(_Deref_post_valid_, (), _Deref_post1_impl_(__notnull_impl_notref) _Post_valid_impl_)_Deref_post_opt_bytecount_x_(size)_SAL1_1_Source_(_Deref_post_opt_bytecount_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecount_x_impl(size)) _Post_valid_impl_)_Deref_post_bytecount_x_(size)_SAL1_1_Source_(_Deref_post_bytecount_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecount_x_impl(size)) _Post_valid_impl_)_Deref_post_opt_count_x_(size)_SAL1_1_Source_(_Deref_post_opt_count_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__count_x_impl(size)) _Post_valid_impl_)_Deref_post_count_x_(size)_SAL1_1_Source_(_Deref_post_count_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__count_x_impl(size)) _Post_valid_impl_)_Deref_post_opt_bytecount_c_(size)_SAL1_1_Source_(_Deref_post_opt_bytecount_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecount_c_impl(size)) _Post_valid_impl_)_Deref_post_bytecount_c_(size)_SAL1_1_Source_(_Deref_post_bytecount_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecount_c_impl(size)) _Post_valid_impl_)_Deref_post_opt_count_c_(size)_SAL1_1_Source_(_Deref_post_opt_count_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__count_c_impl(size)) _Post_valid_impl_)_Deref_post_count_c_(size)_SAL1_1_Source_(_Deref_post_count_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__count_c_impl(size)) _Post_valid_impl_)_Deref_post_opt_bytecount_(size)_SAL1_1_Source_(_Deref_post_opt_bytecount_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecount_impl(size)) _Post_valid_impl_)_Deref_post_bytecount_(size)_SAL1_1_Source_(_Deref_post_bytecount_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecount_impl(size)) _Post_valid_impl_)_Deref_post_opt_count_(size)_SAL1_1_Source_(_Deref_post_opt_count_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__count_impl(size)) _Post_valid_impl_)_Deref_post_count_(size)_SAL1_1_Source_(_Deref_post_count_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__count_impl(size)) _Post_valid_impl_)_Deref_post_opt_valid_bytecap_x_(size)_SAL1_1_Source_(_Deref_post_opt_valid_bytecap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)) _Post_valid_impl_)_Deref_post_valid_bytecap_x_(size)_SAL1_1_Source_(_Deref_post_valid_bytecap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)) _Post_valid_impl_)_Deref_post_opt_valid_cap_x_(size)_SAL1_1_Source_(_Deref_post_opt_valid_cap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size)) _Post_valid_impl_)_Deref_post_valid_cap_x_(size)_SAL1_1_Source_(_Deref_post_valid_cap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size)) _Post_valid_impl_)_Deref_post_opt_valid_bytecap_c_(size)_SAL1_1_Source_(_Deref_post_opt_valid_bytecap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)) _Post_valid_impl_)_Deref_post_valid_bytecap_c_(size)_SAL1_1_Source_(_Deref_post_valid_bytecap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)) _Post_valid_impl_)_Deref_post_opt_valid_cap_c_(size)_SAL1_1_Source_(_Deref_post_opt_valid_cap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size)) _Post_valid_impl_)_Deref_post_valid_cap_c_(size)_SAL1_1_Source_(_Deref_post_valid_cap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size)) _Post_valid_impl_)_Deref_post_opt_valid_bytecap_(size)_SAL1_1_Source_(_Deref_post_opt_valid_bytecap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size)) _Post_valid_impl_)_Deref_post_valid_bytecap_(size)_SAL1_1_Source_(_Deref_post_valid_bytecap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size)) _Post_valid_impl_)_Deref_post_opt_valid_cap_(size)_SAL1_1_Source_(_Deref_post_opt_valid_cap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_impl(size)) _Post_valid_impl_)_Deref_post_valid_cap_(size)_SAL1_1_Source_(_Deref_post_valid_cap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_impl(size)) _Post_valid_impl_)_Deref_post_opt_z_bytecap_x_(size)_SAL1_1_Source_(_Deref_post_opt_z_bytecap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Post_valid_impl_)_Deref_post_z_bytecap_x_(size)_SAL1_1_Source_(_Deref_post_z_bytecap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Post_valid_impl_)_Deref_post_opt_z_cap_x_(size)_SAL1_1_Source_(_Deref_post_opt_z_cap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_x_impl(size)) _Post_valid_impl_)_Deref_post_z_cap_x_(size)_SAL1_1_Source_(_Deref_post_z_cap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_x_impl(size)) _Post_valid_impl_)_Deref_post_opt_z_bytecap_c_(size)_SAL1_1_Source_(_Deref_post_opt_z_bytecap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Post_valid_impl_)_Deref_post_z_bytecap_c_(size)_SAL1_1_Source_(_Deref_post_z_bytecap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Post_valid_impl_)_Deref_post_opt_z_cap_c_(size)_SAL1_1_Source_(_Deref_post_opt_z_cap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_c_impl(size)) _Post_valid_impl_)_Deref_post_z_cap_c_(size)_SAL1_1_Source_(_Deref_post_z_cap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_c_impl(size)) _Post_valid_impl_)_Deref_post_opt_z_bytecap_(size)_SAL1_1_Source_(_Deref_post_opt_z_bytecap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_impl(size)) _Post_valid_impl_)_Deref_post_z_bytecap_(size)_SAL1_1_Source_(_Deref_post_z_bytecap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_impl(size)) _Post_valid_impl_)_Deref_post_opt_z_cap_(size)_SAL1_1_Source_(_Deref_post_opt_z_cap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_impl(size)) _Post_valid_impl_)_Deref_post_z_cap_(size)_SAL1_1_Source_(_Deref_post_z_cap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_impl(size)) _Post_valid_impl_)_Deref_post_opt_bytecap_x_(size)_SAL1_1_Source_(_Deref_post_opt_bytecap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)))_Deref_post_bytecap_x_(size)_SAL1_1_Source_(_Deref_post_bytecap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)))_Deref_post_opt_cap_x_(size)_SAL1_1_Source_(_Deref_post_opt_cap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size)))_Deref_post_cap_x_(size)_SAL1_1_Source_(_Deref_post_cap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size)))_Deref_post_opt_bytecap_c_(size)_SAL1_1_Source_(_Deref_post_opt_bytecap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)))_Deref_post_bytecap_c_(size)_SAL1_1_Source_(_Deref_post_bytecap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)))_Deref_post_opt_cap_c_(size)_SAL1_1_Source_(_Deref_post_opt_cap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size)))_Deref_post_cap_c_(size)_SAL1_1_Source_(_Deref_post_cap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size)))_Deref_post_opt_bytecap_(size)_SAL1_1_Source_(_Deref_post_opt_bytecap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size)))_Deref_post_bytecap_(size)_SAL1_1_Source_(_Deref_post_bytecap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size)))_Deref_post_opt_cap_(size)_SAL1_1_Source_(_Deref_post_opt_cap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_impl(size)))_Deref_post_cap_(size)_SAL1_1_Source_(_Deref_post_cap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_impl(size)))_Deref_post_opt_z__SAL1_1_Source_(_Deref_post_opt_z_, (), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__zterm_impl) _Post_valid_impl_)_Deref_post_z__SAL1_1_Source_(_Deref_post_z_, (), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__zterm_impl) _Post_valid_impl_)_Deref_pre_writeonly__SAL1_1_Source_(_Deref_pre_writeonly_, (), _Deref_pre1_impl_(__writeaccess_impl_notref))_SAL1_1_Source_(_Deref_pre_readonly_, (), _Deref_pre1_impl_(__readaccess_impl_notref))_Deref_pre_null__SAL1_1_Source_(_Deref_pre_null_, (), _Deref_pre1_impl_(__null_impl_notref))_Deref_pre_maybenull__SAL1_1_Source_(_Deref_pre_maybenull_, (), _Deref_pre1_impl_(__maybenull_impl_notref))_Deref_pre_notnull__SAL1_1_Source_(_Deref_pre_notnull_, (), _Deref_pre1_impl_(__notnull_impl_notref))_Deref_pre_invalid__SAL1_1_Source_(_Deref_pre_invalid_, (), _Deref_pre1_impl_(__notvalid_impl))_Deref_pre_opt_valid__SAL1_1_Source_(_Deref_pre_opt_valid_, (), _Deref_pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_)_Deref_pre_valid__SAL1_1_Source_(_Deref_pre_valid_, (), _Deref_pre1_impl_(__notnull_impl_notref) _Pre_valid_impl_)_Deref_pre_opt_bytecount_x_(size)_SAL1_1_Source_(_Deref_pre_opt_bytecount_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)_Deref_pre_bytecount_x_(size)_SAL1_1_Source_(_Deref_pre_bytecount_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_count_x_(size)_SAL1_1_Source_(_Deref_pre_opt_count_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__count_x_impl(size)) _Pre_valid_impl_)_Deref_pre_count_x_(size)_SAL1_1_Source_(_Deref_pre_count_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__count_x_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_bytecount_c_(size)_SAL1_1_Source_(_Deref_pre_opt_bytecount_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)_Deref_pre_bytecount_c_(size)_SAL1_1_Source_(_Deref_pre_bytecount_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_count_c_(size)_SAL1_1_Source_(_Deref_pre_opt_count_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__count_c_impl(size)) _Pre_valid_impl_)_Deref_pre_count_c_(size)_SAL1_1_Source_(_Deref_pre_count_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__count_c_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_bytecount_(size)_SAL1_1_Source_(_Deref_pre_opt_bytecount_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)_Deref_pre_bytecount_(size)_SAL1_1_Source_(_Deref_pre_bytecount_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_count_(size)_SAL1_1_Source_(_Deref_pre_opt_count_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__count_impl(size)) _Pre_valid_impl_)_Deref_pre_count_(size)_SAL1_1_Source_(_Deref_pre_count_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__count_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_valid_bytecap_x_(size)_SAL1_1_Source_(_Deref_pre_opt_valid_bytecap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)_Deref_pre_valid_bytecap_x_(size)_SAL1_1_Source_(_Deref_pre_valid_bytecap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_valid_cap_x_(size)_SAL1_1_Source_(_Deref_pre_opt_valid_cap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_x_impl(size)) _Pre_valid_impl_)_Deref_pre_valid_cap_x_(size)_SAL1_1_Source_(_Deref_pre_valid_cap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__cap_x_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_valid_bytecap_c_(size)_SAL1_1_Source_(_Deref_pre_opt_valid_bytecap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)_Deref_pre_valid_bytecap_c_(size)_SAL1_1_Source_(_Deref_pre_valid_bytecap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_valid_cap_c_(size)_SAL1_1_Source_(_Deref_pre_opt_valid_cap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_c_impl(size)) _Pre_valid_impl_)_Deref_pre_valid_cap_c_(size)_SAL1_1_Source_(_Deref_pre_valid_cap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__cap_c_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_valid_bytecap_(size)_SAL1_1_Source_(_Deref_pre_opt_valid_bytecap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_impl(size)) _Pre_valid_impl_)_Deref_pre_valid_bytecap_(size)_SAL1_1_Source_(_Deref_pre_valid_bytecap_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecap_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_valid_cap_(size)_SAL1_1_Source_(_Deref_pre_opt_valid_cap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_impl(size)) _Pre_valid_impl_)_Deref_pre_valid_cap_(size)_SAL1_1_Source_(_Deref_pre_valid_cap_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__cap_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_z_bytecap_x_(size)_SAL1_1_Source_(_Deref_pre_opt_z_bytecap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)_Deref_pre_z_bytecap_x_(size)_SAL1_1_Source_(_Deref_pre_z_bytecap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_z_cap_x_(size)_SAL1_1_Source_(_Deref_pre_opt_z_cap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_x_impl(size)) _Pre_valid_impl_)_Deref_pre_z_cap_x_(size)_SAL1_1_Source_(_Deref_pre_z_cap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_x_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_z_bytecap_c_(size)_SAL1_1_Source_(_Deref_pre_opt_z_bytecap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)_Deref_pre_z_bytecap_c_(size)_SAL1_1_Source_(_Deref_pre_z_bytecap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_z_cap_c_(size)_SAL1_1_Source_(_Deref_pre_opt_z_cap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_c_impl(size)) _Pre_valid_impl_)_Deref_pre_z_cap_c_(size)_SAL1_1_Source_(_Deref_pre_z_cap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_c_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_z_bytecap_(size)_SAL1_1_Source_(_Deref_pre_opt_z_bytecap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_impl(size)) _Pre_valid_impl_)_Deref_pre_z_bytecap_(size)_SAL1_1_Source_(_Deref_pre_z_bytecap_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_z_cap_(size)_SAL1_1_Source_(_Deref_pre_opt_z_cap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_impl(size)) _Pre_valid_impl_)_Deref_pre_z_cap_(size)_SAL1_1_Source_(_Deref_pre_z_cap_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_impl(size)) _Pre_valid_impl_)_Deref_pre_opt_bytecap_x_(size)_SAL1_1_Source_(_Deref_pre_opt_bytecap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_x_impl(size)))_Deref_pre_bytecap_x_(size)_SAL1_1_Source_(_Deref_pre_bytecap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecap_x_impl(size)))_Deref_pre_opt_cap_x_(size)_SAL1_1_Source_(_Deref_pre_opt_cap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_x_impl(size)))_Deref_pre_cap_x_(size)_SAL1_1_Source_(_Deref_pre_cap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__cap_x_impl(size)))_Deref_pre_opt_bytecap_c_(size)_SAL1_1_Source_(_Deref_pre_opt_bytecap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_c_impl(size)))_Deref_pre_bytecap_c_(size)_SAL1_1_Source_(_Deref_pre_bytecap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecap_c_impl(size)))_Deref_pre_opt_cap_c_(size)_SAL1_1_Source_(_Deref_pre_opt_cap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_c_impl(size)))_Deref_pre_cap_c_(size)_SAL1_1_Source_(_Deref_pre_cap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__cap_c_impl(size)))_Deref_pre_opt_bytecap_(size)_SAL1_1_Source_(_Deref_pre_opt_bytecap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_impl(size)))_Deref_pre_bytecap_(size)_SAL1_1_Source_(_Deref_pre_bytecap_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecap_impl(size)))_Deref_pre_opt_cap_(size)_SAL1_1_Source_(_Deref_pre_opt_cap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_impl(size)))_Deref_pre_cap_(size)_SAL1_1_Source_(_Deref_pre_cap_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__cap_impl(size)))_Deref_pre_opt_z__SAL1_1_Source_(_Deref_pre_opt_z_, (), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__zterm_impl) _Pre_valid_impl_)_Deref_pre_z__SAL1_1_Source_(_Deref_pre_z_, (), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__zterm_impl) _Pre_valid_impl_)_Deref_opt_out_opt_z__SAL1_1_Source_(_Deref_opt_out_opt_z_, (), _Out_opt_ _Deref_post_opt_z_)_Deref_opt_out_z__SAL1_1_Source_(_Deref_opt_out_z_, (), _Out_opt_ _Deref_post_z_)_Deref_out_opt_z__SAL1_1_Source_(_Deref_out_opt_z_, (), _Out_ _Deref_post_opt_z_)_Deref_out_z__SAL1_1_Source_(_Deref_out_z_, (), _Out_ _Deref_post_z_)_Deref_opt_out_opt__SAL1_1_Source_(_Deref_opt_out_opt_, (), _Out_opt_ _Deref_post_opt_valid_)_Deref_opt_out__SAL1_1_Source_(_Deref_opt_out_, (), _Out_opt_ _Deref_post_valid_)_Deref_out_opt__SAL1_1_Source_(_Deref_out_opt_, (), _Out_ _Deref_post_opt_valid_)_Deref_out__SAL1_1_Source_(_Deref_out_, (), _Out_ _Deref_post_valid_)_Deref_ret_bound__SAL1_1_Source_(_Deref_ret_bound_, (), _Deref_ret_bound_impl_)_Deref_inout_bound__SAL1_1_Source_(_Deref_inout_bound_, (), _Deref_in_bound_ _Deref_out_bound_)_Deref_out_bound__SAL1_1_Source_(_Deref_out_bound_, (), _Deref_out_bound_impl_)_Deref_in_bound__SAL1_1_Source_(_Deref_in_bound_, (), _Deref_in_bound_impl_)_Ret_bound__SAL1_1_Source_(_Ret_bound_, (), _Ret_bound_impl_)_Out_bound__SAL1_1_Source_(_Out_bound_, (), _Out_bound_impl_)_In_bound__SAL1_1_Source_(_In_bound_, (), _In_bound_impl_)_Ret_opt__SAL1_1_Source_(_Ret_opt_, (), _Ret_opt_valid_)_Ret__SAL1_1_Source_(_Ret_, (), _Ret_valid_)_Inout_opt_z_bytecap_x_(size)_SAL1_1_Source_(_Inout_opt_z_bytecap_x_, (size), _Pre_opt_z_bytecap_x_(size) _Post_z_)_Inout_z_bytecap_x_(size)_SAL1_1_Source_(_Inout_z_bytecap_x_, (size), _Pre_z_bytecap_x_(size) _Post_z_)_Inout_opt_z_cap_x_(size)_SAL1_1_Source_(_Inout_opt_z_cap_x_, (size), _Pre_opt_z_cap_x_(size) _Post_z_)_Inout_z_cap_x_(size)_SAL1_1_Source_(_Inout_z_cap_x_, (size), _Pre_z_cap_x_(size) _Post_z_)_Inout_opt_z_bytecap_c_(size)_SAL1_1_Source_(_Inout_opt_z_bytecap_c_, (size), _Pre_opt_z_bytecap_c_(size) _Post_z_)_Inout_z_bytecap_c_(size)_SAL1_1_Source_(_Inout_z_bytecap_c_, (size), _Pre_z_bytecap_c_(size) _Post_z_)_Inout_opt_z_cap_c_(size)_SAL1_1_Source_(_Inout_opt_z_cap_c_, (size), _Pre_opt_z_cap_c_(size) _Post_z_)_Inout_z_cap_c_(size)_SAL1_1_Source_(_Inout_z_cap_c_, (size), _Pre_z_cap_c_(size) _Post_z_)_Inout_opt_z_bytecap_(size)_SAL1_1_Source_(_Inout_opt_z_bytecap_, (size), _Pre_opt_z_bytecap_(size) _Post_z_)_Inout_z_bytecap_(size)_SAL1_1_Source_(_Inout_z_bytecap_, (size), _Pre_z_bytecap_(size) _Post_z_)_Inout_opt_z_cap_(size)_SAL1_1_Source_(_Inout_opt_z_cap_, (size), _Pre_opt_z_cap_(size) _Post_z_)_Inout_z_cap_(size)_SAL1_1_Source_(_Inout_z_cap_, (size), _Pre_z_cap_(size) _Post_z_)_Inout_opt_bytecap_x_(size)_SAL1_1_Source_(_Inout_opt_bytecap_x_, (size), _Pre_opt_valid_bytecap_x_(size) _Post_valid_)_Inout_bytecap_x_(size)_SAL1_1_Source_(_Inout_bytecap_x_, (size), _Pre_valid_bytecap_x_(size) _Post_valid_)_Inout_opt_cap_x_(size)_SAL1_1_Source_(_Inout_opt_cap_x_, (size), _Pre_opt_valid_cap_x_(size) _Post_valid_)_Inout_cap_x_(size)_SAL1_1_Source_(_Inout_cap_x_, (size), _Pre_valid_cap_x_(size) _Post_valid_)_Inout_opt_bytecap_c_(size)_SAL1_1_Source_(_Inout_opt_bytecap_c_, (size), _Pre_opt_valid_bytecap_c_(size) _Post_valid_)_Inout_bytecap_c_(size)_SAL1_1_Source_(_Inout_bytecap_c_, (size), _Pre_valid_bytecap_c_(size) _Post_valid_)_Inout_opt_cap_c_(size)_SAL1_1_Source_(_Inout_opt_cap_c_, (size), _Pre_opt_valid_cap_c_(size) _Post_valid_)_Inout_cap_c_(size)_SAL1_1_Source_(_Inout_cap_c_, (size), _Pre_valid_cap_c_(size) _Post_valid_)_Inout_opt_bytecap_(size)_SAL1_1_Source_(_Inout_opt_bytecap_, (size), _Pre_opt_valid_bytecap_(size) _Post_valid_)_Inout_bytecap_(size)_SAL1_1_Source_(_Inout_bytecap_, (size), _Pre_valid_bytecap_(size) _Post_valid_)_Inout_opt_cap_(size)_SAL1_1_Source_(_Inout_opt_cap_, (size), _Pre_opt_valid_cap_(size) _Post_valid_)_Inout_cap_(size)_SAL1_1_Source_(_Inout_cap_, (size), _Pre_valid_cap_(size) _Post_valid_)_Inout_opt_bytecount_x_(size)_SAL1_1_Source_(_Inout_opt_bytecount_x_, (size), _Prepost_opt_bytecount_x_(size))_Inout_bytecount_x_(size)_SAL1_1_Source_(_Inout_bytecount_x_, (size), _Prepost_bytecount_x_(size))_Inout_opt_count_x_(size)_SAL1_1_Source_(_Inout_opt_count_x_, (size), _Prepost_opt_count_x_(size))_Inout_count_x_(size)_SAL1_1_Source_(_Inout_count_x_, (size), _Prepost_count_x_(size))_Inout_opt_ptrdiff_count_(size)_SAL1_1_Source_(_Inout_opt_ptrdiff_count_, (size), _Pre_opt_ptrdiff_count_(size))_Inout_ptrdiff_count_(size)_SAL1_1_Source_(_Inout_ptrdiff_count_, (size), _Pre_ptrdiff_count_(size))_Inout_opt_z_bytecount_c_(size)_SAL1_1_Source_(_Inout_opt_z_bytecount_c_, (size), _Prepost_z_ _Prepost_opt_bytecount_c_(size))_Inout_z_bytecount_c_(size)_SAL1_1_Source_(_Inout_z_bytecount_c_, (size), _Prepost_z_ _Prepost_bytecount_c_(size))_Inout_opt_z_count_c_(size)_SAL1_1_Source_(_Inout_opt_z_count_c_, (size), _Prepost_z_ _Prepost_opt_count_c_(size))_Inout_z_count_c_(size)_SAL1_1_Source_(_Inout_z_count_c_, (size), _Prepost_z_ _Prepost_count_c_(size))_Inout_opt_z_bytecount_(size)_SAL1_1_Source_(_Inout_opt_z_bytecount_, (size), _Prepost_z_ _Prepost_opt_bytecount_(size))_Inout_z_bytecount_(size)_SAL1_1_Source_(_Inout_z_bytecount_, (size), _Prepost_z_ _Prepost_bytecount_(size))_Inout_opt_z_count_(size)_SAL1_1_Source_(_Inout_opt_z_count_, (size), _Prepost_z_ _Prepost_opt_count_(size))_Inout_z_count_(size)_SAL1_1_Source_(_Inout_z_count_, (size), _Prepost_z_ _Prepost_count_(size))_Inout_opt_bytecount_c_(size)_SAL1_1_Source_(_Inout_opt_bytecount_c_, (size), _Prepost_opt_bytecount_c_(size))_Inout_bytecount_c_(size)_SAL1_1_Source_(_Inout_bytecount_c_, (size), _Prepost_bytecount_c_(size))_Inout_opt_count_c_(size)_SAL1_1_Source_(_Inout_opt_count_c_, (size), _Prepost_opt_count_c_(size))_Inout_count_c_(size)_SAL1_1_Source_(_Inout_count_c_, (size), _Prepost_count_c_(size))_Inout_opt_bytecount_(size)_SAL1_1_Source_(_Inout_opt_bytecount_, (size), _Prepost_opt_bytecount_(size))_Inout_bytecount_(size)_SAL1_1_Source_(_Inout_bytecount_, (size), _Prepost_bytecount_(size))_Inout_opt_count_(size)_SAL1_1_Source_(_Inout_opt_count_, (size), _Prepost_opt_count_(size))_Inout_count_(size)_SAL1_1_Source_(_Inout_count_, (size), _Prepost_count_(size))_Out_opt_z_bytecapcount_(capcount)_SAL1_1_Source_(_Out_opt_z_bytecapcount_, (capcount), _Pre_opt_bytecap_(capcount) _Post_valid_impl_ _Post_z_bytecount_(capcount))_Out_z_bytecapcount_(capcount)_SAL1_1_Source_(_Out_z_bytecapcount_, (capcount), _Pre_bytecap_(capcount) _Post_valid_impl_ _Post_z_bytecount_(capcount))_Out_opt_z_capcount_(capcount)_SAL1_1_Source_(_Out_opt_z_capcount_, (capcount), _Pre_opt_cap_(capcount) _Post_valid_impl_ _Post_z_count_(capcount))_Out_z_capcount_(capcount)_SAL1_1_Source_(_Out_z_capcount_, (capcount), _Pre_cap_(capcount) _Post_valid_impl_ _Post_z_count_(capcount))_Out_opt_bytecapcount_x_(capcount)_SAL1_1_Source_(_Out_opt_bytecapcount_x_, (capcount), _Pre_opt_bytecap_x_(capcount) _Post_valid_impl_ _Post_bytecount_x_(capcount))_Out_bytecapcount_x_(capcount)_SAL1_1_Source_(_Out_bytecapcount_x_, (capcount), _Pre_bytecap_x_(capcount) _Post_valid_impl_ _Post_bytecount_x_(capcount))_Out_opt_capcount_x_(capcount)_SAL1_1_Source_(_Out_opt_capcount_x_, (capcount), _Pre_opt_cap_x_(capcount) _Post_valid_impl_ _Post_count_x_(capcount))_Out_capcount_x_(capcount)_SAL1_1_Source_(_Out_capcount_x_, (capcount), _Pre_cap_x_(capcount) _Post_valid_impl_ _Post_count_x_(capcount))_Out_opt_bytecapcount_(capcount)_SAL1_1_Source_(_Out_opt_bytecapcount_, (capcount), _Pre_opt_bytecap_(capcount) _Post_valid_impl_ _Post_bytecount_(capcount))_Out_bytecapcount_(capcount)_SAL1_1_Source_(_Out_bytecapcount_, (capcount), _Pre_bytecap_(capcount) _Post_valid_impl_ _Post_bytecount_(capcount))_Out_opt_capcount_(capcount)_SAL1_1_Source_(_Out_opt_capcount_, (capcount), _Pre_opt_cap_(capcount) _Post_valid_impl_ _Post_count_(capcount))_Out_capcount_(capcount)_SAL1_1_Source_(_Out_capcount_, (capcount), _Pre_cap_(capcount) _Post_valid_impl_ _Post_count_(capcount))_Out_opt_z_bytecap_post_bytecount_(cap,count)_SAL1_1_Source_(_Out_opt_z_bytecap_post_bytecount_, (cap,count), _Pre_opt_bytecap_(cap) _Post_valid_impl_ _Post_z_bytecount_(count))_Out_z_bytecap_post_bytecount_(cap,count)_SAL1_1_Source_(_Out_z_bytecap_post_bytecount_, (cap,count), _Pre_bytecap_(cap) _Post_valid_impl_ _Post_z_bytecount_(count))_Out_opt_z_cap_post_count_(cap,count)_SAL1_1_Source_(_Out_opt_z_cap_post_count_, (cap,count), _Pre_opt_cap_(cap) _Post_valid_impl_ _Post_z_count_(count))_Out_z_cap_post_count_(cap,count)_SAL1_1_Source_(_Out_z_cap_post_count_, (cap,count), _Pre_cap_(cap) _Post_valid_impl_ _Post_z_count_(count))_Out_opt_bytecap_post_bytecount_(cap,count)_SAL1_1_Source_(_Out_opt_bytecap_post_bytecount_, (cap,count), _Pre_opt_bytecap_(cap) _Post_valid_impl_ _Post_bytecount_(count))_Out_bytecap_post_bytecount_(cap,count)_SAL1_1_Source_(_Out_bytecap_post_bytecount_, (cap,count), _Pre_bytecap_(cap) _Post_valid_impl_ _Post_bytecount_(count))_Out_opt_cap_post_count_(cap,count)_SAL1_1_Source_(_Out_opt_cap_post_count_, (cap,count), _Pre_opt_cap_(cap) _Post_valid_impl_ _Post_count_(count))_Out_cap_post_count_(cap,count)_SAL1_1_Source_(_Out_cap_post_count_, (cap,count), _Pre_cap_(cap) _Post_valid_impl_ _Post_count_(count))_Out_opt_z_bytecap_x_(size)_SAL1_1_Source_(_Out_opt_z_bytecap_x_, (size), _Pre_opt_bytecap_x_(size) _Post_valid_impl_ _Post_z_)_Out_z_bytecap_x_(size)_SAL1_1_Source_(_Out_z_bytecap_x_, (size), _Pre_bytecap_x_(size) _Post_valid_impl_ _Post_z_)_Out_opt_z_cap_x_(size)_SAL1_1_Source_(_Out_opt_z_cap_x_, (size), _Pre_opt_cap_x_(size) _Post_valid_impl_ _Post_z_)_Out_z_cap_x_(size)_SAL1_1_Source_(_Out_z_cap_x_, (size), _Pre_cap_x_(size) _Post_valid_impl_ _Post_z_)_Out_opt_z_bytecap_c_(size)_SAL1_1_Source_(_Out_opt_z_bytecap_c_, (size), _Pre_opt_bytecap_c_(size) _Post_valid_impl_ _Post_z_)_Out_z_bytecap_c_(size)_SAL1_1_Source_(_Out_z_bytecap_c_, (size), _Pre_bytecap_c_(size) _Post_valid_impl_ _Post_z_)_Out_opt_z_cap_c_(size)_SAL1_1_Source_(_Out_opt_z_cap_c_, (size), _Pre_opt_cap_c_(size) _Post_valid_impl_ _Post_z_)_Out_z_cap_c_(size)_SAL1_1_Source_(_Out_z_cap_c_, (size), _Pre_cap_c_(size) _Post_valid_impl_ _Post_z_)_Out_opt_z_bytecap_(size)_SAL1_1_Source_(_Out_opt_z_bytecap_, (size), _Pre_opt_bytecap_(size) _Post_valid_impl_ _Post_z_)_Out_z_bytecap_(size)_SAL1_1_Source_(_Out_z_bytecap_, (size), _Pre_bytecap_(size) _Post_valid_impl_ _Post_z_)_Out_opt_z_cap_(size)_SAL1_1_Source_(_Out_opt_z_cap_, (size), _Pre_opt_cap_(size) _Post_valid_impl_ _Post_z_)_Out_z_cap_(size)_SAL1_1_Source_(_Out_z_cap_, (size), _Pre_cap_(size) _Post_valid_impl_ _Post_z_)_Out_opt_bytecap_x_(size)_SAL1_1_Source_(_Out_opt_bytecap_x_, (size), _Pre_opt_bytecap_x_(size) _Post_valid_impl_)_Out_bytecap_x_(size)_SAL1_1_Source_(_Out_bytecap_x_, (size), _Pre_bytecap_x_(size) _Post_valid_impl_)_Out_opt_cap_x_(size)_SAL1_1_Source_(_Out_opt_cap_x_, (size), _Pre_opt_cap_x_(size) _Post_valid_impl_)_Out_cap_x_(size)_SAL1_1_Source_(_Out_cap_x_, (size), _Pre_cap_x_(size) _Post_valid_impl_)_Out_opt_ptrdiff_cap_(size)_SAL1_1_Source_(_Out_opt_ptrdiff_cap_, (size), _Pre_opt_ptrdiff_cap_(size) _Post_valid_impl_)_Out_ptrdiff_cap_(size)_SAL1_1_Source_(_Out_ptrdiff_cap_, (size), _Pre_ptrdiff_cap_(size) _Post_valid_impl_)_Out_opt_z_cap_m_(mult,size)_SAL1_1_Source_(_Out_opt_z_cap_m_, (mult,size), _Pre_opt_cap_m_(mult,size) _Post_valid_impl_ _Post_z_)_Out_z_cap_m_(mult,size)_SAL1_1_Source_(_Out_z_cap_m_, (mult,size), _Pre_cap_m_(mult,size) _Post_valid_impl_ _Post_z_)_Out_opt_cap_m_(mult,size)_SAL1_1_Source_(_Out_opt_cap_m_, (mult,size), _Pre_opt_cap_m_(mult,size) _Post_valid_impl_)_Out_cap_m_(mult,size)_SAL1_1_Source_(_Out_cap_m_, (mult,size), _Pre_cap_m_(mult,size) _Post_valid_impl_)_Out_opt_bytecap_c_(size)_SAL1_1_Source_(_Out_opt_bytecap_c_, (size), _Pre_opt_bytecap_c_(size) _Post_valid_impl_)_Out_bytecap_c_(size)_SAL1_1_Source_(_Out_bytecap_c_, (size), _Pre_bytecap_c_(size) _Post_valid_impl_)_Out_opt_cap_c_(size)_SAL1_1_Source_(_Out_opt_cap_c_, (size), _Pre_opt_cap_c_(size) _Post_valid_impl_)_Out_cap_c_(size)_SAL1_1_Source_(_Out_cap_c_, (size), _Pre_cap_c_(size) _Post_valid_impl_)_Out_opt_bytecap_(size)_SAL1_1_Source_(_Out_opt_bytecap_, (size), _Pre_opt_bytecap_(size) _Post_valid_impl_)_Out_bytecap_(size)_SAL1_1_Source_(_Out_bytecap_, (size), _Pre_bytecap_(size) _Post_valid_impl_)_Out_opt_cap_(size)_SAL1_1_Source_(_Out_opt_cap_, (size), _Pre_opt_cap_(size) _Post_valid_impl_)_Out_cap_(size)_SAL1_1_Source_(_Out_cap_, (size), _Pre_cap_(size) _Post_valid_impl_)_In_opt_bytecount_x_(size)_SAL1_1_Source_(_In_opt_bytecount_x_, (size), _Pre_opt_bytecount_x_(size) _Deref_pre_readonly_)_In_bytecount_x_(size)_SAL1_1_Source_(_In_bytecount_x_, (size), _Pre_bytecount_x_(size) _Deref_pre_readonly_)_In_opt_count_x_(size)_SAL1_1_Source_(_In_opt_count_x_, (size), _Pre_opt_count_x_(size) _Deref_pre_readonly_)_In_count_x_(size)_SAL1_1_Source_(_In_count_x_, (size), _Pre_count_x_(size) _Deref_pre_readonly_)_In_opt_ptrdiff_count_(size)_SAL1_1_Source_(_In_opt_ptrdiff_count_, (size), _Pre_opt_ptrdiff_count_(size) _Deref_pre_readonly_)_In_ptrdiff_count_(size)_SAL1_1_Source_(_In_ptrdiff_count_, (size), _Pre_ptrdiff_count_(size) _Deref_pre_readonly_)_In_opt_z_bytecount_c_(size)_SAL1_1_Source_(_In_opt_z_bytecount_c_, (size), _Pre_opt_z_ _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_)_In_z_bytecount_c_(size)_SAL1_1_Source_(_In_z_bytecount_c_, (size), _Pre_z_ _Pre_bytecount_c_(size) _Deref_pre_readonly_)_In_opt_z_count_c_(size)_SAL1_1_Source_(_In_opt_z_count_c_, (size), _Pre_opt_z_ _Pre_opt_count_c_(size) _Deref_pre_readonly_)_In_z_count_c_(size)_SAL1_1_Source_(_In_z_count_c_, (size), _Pre_z_ _Pre_count_c_(size) _Deref_pre_readonly_)_In_opt_z_bytecount_(size)_SAL1_1_Source_(_In_opt_z_bytecount_, (size), _Pre_opt_z_ _Pre_opt_bytecount_(size) _Deref_pre_readonly_)_In_z_bytecount_(size)_SAL1_1_Source_(_In_z_bytecount_, (size), _Pre_z_ _Pre_bytecount_(size) _Deref_pre_readonly_)_In_opt_z_count_(size)_SAL1_1_Source_(_In_opt_z_count_, (size), _Pre_opt_z_ _Pre_opt_count_(size) _Deref_pre_readonly_)_In_z_count_(size)_SAL1_1_Source_(_In_z_count_, (size), _Pre_z_ _Pre_count_(size) _Deref_pre_readonly_)_In_opt_bytecount_c_(size)_SAL1_1_Source_(_In_opt_bytecount_c_, (size), _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_)_In_bytecount_c_(size)_SAL1_1_Source_(_In_bytecount_c_, (size), _Pre_bytecount_c_(size) _Deref_pre_readonly_)_In_opt_count_c_(size)_SAL1_1_Source_(_In_opt_count_c_, (size), _Pre_opt_count_c_(size) _Deref_pre_readonly_)_In_count_c_(size)_SAL1_1_Source_(_In_count_c_, (size), _Pre_count_c_(size) _Deref_pre_readonly_)_In_opt_bytecount_(size)_SAL1_1_Source_(_In_opt_bytecount_, (size), _Pre_opt_bytecount_(size) _Deref_pre_readonly_)_In_bytecount_(size)_SAL1_1_Source_(_In_bytecount_, (size), _Pre_bytecount_(size) _Deref_pre_readonly_)_In_opt_count_(size)_SAL1_1_Source_(_In_opt_count_, (size), _Pre_opt_count_(size) _Deref_pre_readonly_)_In_count_(size)_SAL1_1_Source_(_In_count_, (size), _Pre_count_(size) _Deref_pre_readonly_)_Prepost_z__SAL2_Source_(_Prepost_z_, (), _Pre_z_ _Post_z_)_Post_maybenull__SAL2_Source_(_Post_maybenull_, (), _Post1_impl_(__maybenull_impl))_Post_null__SAL2_Source_(_Post_null_, (), _Post1_impl_(__null_impl))_Post_notnull__SAL2_Source_(_Post_notnull_, (), _Post1_impl_(__notnull_impl))_Post_ptr_invalid__SAL2_Source_(_Post_ptr_invalid_, (), _Post1_impl_(__notvalid_impl))_Post_invalid__SAL2_Source_(_Post_invalid_, (), _Deref_post1_impl_(__notvalid_impl))_SAL2_Source_(_Post_valid_, (), _Post_valid_impl_)_SAL2_Source_(_Post_z_, (), _Post1_impl_(__zterm_impl) _Post_valid_impl_)_Pre_null__SAL2_Source_(_Pre_null_, (), _Pre1_impl_(__null_impl_notref))_SAL2_Source_(_Pre_maybenull_, (), _Pre1_impl_(__maybenull_impl_notref))_SAL2_Source_(_Pre_notnull_, (), _Pre1_impl_(__notnull_impl_notref))_Pre_unknown__SAL2_Source_(_Pre_unknown_, (), _Pre1_impl_(__maybevalid_impl))_Pre_invalid__SAL2_Source_(_Pre_invalid_, (), _Deref_pre1_impl_(__notvalid_impl))_SAL2_Source_(_Pre_opt_valid_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_)_SAL2_Source_(_Pre_valid_, (), _Pre1_impl_(__notnull_impl_notref) _Pre_valid_impl_)_SAL2_Source_(_Pre_z_, (), _Pre1_impl_(__zterm_impl) _Pre_valid_impl_)_Maybenull__SAL2_Source_(_Maybenull_, (), _Maybenull_impl_)_Notnull__SAL2_Source_(_Notnull_, (), _Notnull_impl_)_Null__SAL2_Source_(_Null_, (), _Null_impl_)_Post_writable_byte_size_(size)_SAL2_Source_(_Post_writable_byte_size_, (size), _Post1_impl_(__bytecap_impl(size)))_Post_readable_byte_size_(size)_SAL2_Source_(_Post_readable_byte_size_, (size), _Post1_impl_(__bytecount_impl(size)) _Post_valid_impl_)_Post_writable_size_(size)_SAL2_Source_(_Post_writable_size_, (size), _Post1_impl_(__cap_impl(size)))_Post_readable_size_(size)_SAL2_Source_(_Post_readable_size_, (size), _Post1_impl_(__count_impl(size)) _Post_valid_impl_)_Pre_writable_byte_size_(size)_SAL2_Source_(_Pre_writable_byte_size_, (size), _Pre1_impl_(__bytecap_impl(size)))_Pre_readable_byte_size_(size)_SAL2_Source_(_Pre_readable_byte_size_, (size), _Pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)_Pre_writable_size_(size)_SAL2_Source_(_Pre_writable_size_, (size), _Pre1_impl_(__cap_impl(size)))_Pre_readable_size_(size)_SAL2_Source_(_Pre_readable_size_, (size), _Pre1_impl_(__count_impl(size)) _Pre_valid_impl_)_NullNull_terminated__SAL2_Source_(_NullNull_terminated_, (), _NullNull_terminated_impl_)_Null_terminated__SAL2_Source_(_Null_terminated_, (), _Null_terminated_impl_)_Writable_elements_(size)_SAL2_Source_(_Writable_elements_, (size), _Writable_elements_impl_(size))_Writable_bytes_(size)_SAL2_Source_(_Writable_bytes_, (size), _Writable_bytes_impl_(size))_Readable_elements_(size)_SAL2_Source_(_Readable_elements_, (size), _Readable_elements_impl_(size))_Readable_bytes_(size)_SAL2_Source_(_Readable_bytes_, (size), _Readable_bytes_impl_(size))_Maybevalid__Notvalid__Valid__Post__Pre__Field_range_(min,max)_SAL2_Source_(_Field_range_, (min,max), _Field_range_impl_(min,max))_Field_z__SAL2_Source_(_Field_z_, (), _Null_terminated_)_Field_size_bytes_full_opt_(size)_SAL2_Source_(_Field_size_bytes_full_opt_, (size), _Field_size_bytes_part_opt_(size, size))_Field_size_bytes_full_(size)_SAL2_Source_(_Field_size_bytes_full_, (size), _Field_size_bytes_part_(size, size))_Field_size_bytes_part_opt_(size,count)_SAL2_Source_(_Field_size_bytes_part_opt_, (size, count), _Maybenull_ _Writable_bytes_(size) _Readable_bytes_(count))_Field_size_bytes_part_(size,count)_SAL2_Source_(_Field_size_bytes_part_, (size, count), _Notnull_ _Writable_bytes_(size) _Readable_bytes_(count))_Field_size_bytes_opt_(size)_SAL2_Source_(_Field_size_bytes_opt_, (size), _Maybenull_ _Writable_bytes_(size))_Field_size_bytes_(size)_SAL2_Source_(_Field_size_bytes_, (size), _Notnull_ _Writable_bytes_(size))_Field_size_full_opt_(size)_SAL2_Source_(_Field_size_full_opt_, (size), _Field_size_part_opt_(size, size))_Field_size_full_(size)_SAL2_Source_(_Field_size_full_, (size), _Field_size_part_(size, size))_Field_size_part_opt_(size,count)_SAL2_Source_(_Field_size_part_opt_, (size, count), _Maybenull_ _Writable_elements_(size) _Readable_elements_(count))_Field_size_part_(size,count)_SAL2_Source_(_Field_size_part_, (size, count), _Notnull_ _Writable_elements_(size) _Readable_elements_(count))_Field_size_opt_(size)_SAL2_Source_(_Field_size_opt_, (size), _Maybenull_ _Writable_elements_(size))_Field_size_(size)_SAL2_Source_(_Field_size_, (size), _Notnull_ _Writable_elements_(size))_Struct_size_bytes_(size)_SAL2_Source_(_Struct_size_bytes_, (size), _Writable_bytes_(size))_Post_satisfies_(cond)_SAL2_Source_(_Post_satisfies_, (cond), _Post_satisfies_impl_(cond))_Pre_satisfies_(cond)_SAL2_Source_(_Pre_satisfies_, (cond), _Pre_satisfies_impl_(cond))_Unchanged_(e)_SAL2_Source_(_Unchanged_, (e), _At_(e, _Post_equal_to_(_Old_(e)) _Const_))_Post_equal_to_(expr)_SAL2_Source_(_Post_equal_to_, (expr), _Out_range_(==, expr))_Pre_equal_to_(expr)_SAL2_Source_(_Pre_equal_to_, (expr), _In_range_(==, expr))_Deref_ret_range_(lb,ub)_SAL2_Source_(_Deref_ret_range_, (lb,ub), _Deref_ret_range_impl_(lb,ub))_Deref_out_range_(lb,ub)_SAL2_Source_(_Deref_out_range_, (lb,ub), _Deref_out_range_impl_(lb,ub))_Deref_in_range_(lb,ub)_SAL2_Source_(_Deref_in_range_, (lb,ub), _Deref_in_range_impl_(lb,ub))_Ret_range_(lb,ub)_SAL2_Source_(_Ret_range_, (lb,ub), _Ret_range_impl_(lb,ub))_Out_range_(lb,ub)_SAL2_Source_(_Out_range_, (lb,ub), _Out_range_impl_(lb,ub))_In_range_(lb,ub)_SAL2_Source_(_In_range_, (lb,ub), _In_range_impl_(lb,ub))_Scanf_s_format_string_params_(x)_SAL2_Source_(_Scanf_s_format_string_params_, (x), _Format_string_impl_("scanf_s", x))_Scanf_format_string_params_(x)_SAL2_Source_(_Scanf_format_string_params_, (x), _Format_string_impl_("scanf", x))_Printf_format_string_params_(x)_SAL2_Source_(_Printf_format_string_params_, (x), _Format_string_impl_("printf", x))_Format_string_impl_(kind,where)_SA_annotes2(SAL_IsFormatString2, kind, where)_SAL2_Source_(_Scanf_s_format_string_, (), _Scanf_s_format_string_impl_)_SAL2_Source_(_Scanf_format_string_, (), _Scanf_format_string_impl_)_SAL2_Source_(_Printf_format_string_, (), _Printf_format_string_impl_)_Must_inspect_result__SAL2_Source_(_Must_inspect_result_, (), _Must_inspect_impl_ _Check_return_impl_)_SAL2_Source_(_Check_return_, (), _Check_return_impl_)_Notliteral__SAL2_Source_(_Notliteral_, (), _Pre_ _Notliteral_impl_)_Literal__SAL2_Source_(_Literal_, (), _Pre_ _Literal_impl_)_Points_to_data__SAL2_Source_(_Points_to_data_, (), _Pre_ _Points_to_data_impl_)_Ret_writes_bytes_to_maybenull_(size,count)_SAL2_Source_(_Ret_writes_bytes_to_maybenull_, (size,count), _Ret3_impl_(__maybenull_impl, __bytecap_impl(size), __bytecount_impl(count)) _Ret_valid_impl_)_Ret_writes_to_maybenull_(size,count)_SAL2_Source_(_Ret_writes_to_maybenull_, (size,count), _Ret3_impl_(__maybenull_impl, __cap_impl(size), __count_impl(count)) _Ret_valid_impl_)_Ret_writes_bytes_to_(size,count)_SAL2_Source_(_Ret_writes_bytes_to_, (size,count), _Ret3_impl_(__notnull_impl, __bytecap_impl(size), __bytecount_impl(count)) _Ret_valid_impl_)_Ret_writes_to_(size,count)_SAL2_Source_(_Ret_writes_to_, (size,count), _Ret3_impl_(__notnull_impl, __cap_impl(size), __count_impl(count)) _Ret_valid_impl_)_Ret_writes_bytes_maybenull_(size)_SAL2_Source_(_Ret_writes_bytes_maybenull_, (size), _Ret2_impl_(__maybenull_impl,__bytecount_impl(size)) _Ret_valid_impl_)_Ret_writes_maybenull_z_(size)_SAL2_Source_(_Ret_writes_maybenull_z_, (size), _Ret3_impl_(__maybenull_impl,__count_impl(size),__zterm_impl) _Ret_valid_impl_)_Ret_writes_maybenull_(size)_SAL2_Source_(_Ret_writes_maybenull_, (size), _Ret2_impl_(__maybenull_impl,__count_impl(size)) _Ret_valid_impl_)_Ret_writes_bytes_(size)_SAL2_Source_(_Ret_writes_bytes_, (size), _Ret2_impl_(__notnull_impl, __bytecount_impl(size)) _Ret_valid_impl_)_Ret_writes_z_(size)_SAL2_Source_(_Ret_writes_z_, (size), _Ret3_impl_(__notnull_impl, __count_impl(size), __zterm_impl) _Ret_valid_impl_)_Ret_writes_(size)_SAL2_Source_(_Ret_writes_, (size), _Ret2_impl_(__notnull_impl, __count_impl(size)) _Ret_valid_impl_)_Ret_valid__SAL2_Source_(_Ret_valid_, (), _Ret1_impl_(__notnull_impl_notref) _Ret_valid_impl_)_Ret_null__SAL2_Source_(_Ret_null_, (), _Ret1_impl_(__null_impl))_Ret_maybenull__SAL2_Source_(_Ret_maybenull_, (), _Ret1_impl_(__maybenull_impl))_Ret_notnull__SAL2_Source_(_Ret_notnull_, (), _Ret1_impl_(__notnull_impl))_Ret_maybenull_z__SAL2_Source_(_Ret_maybenull_z_, (), _Ret2_impl_(__maybenull_impl,__zterm_impl) _Ret_valid_impl_)_Ret_z__SAL2_Source_(_Ret_z_, (), _Ret2_impl_(__notnull_impl, __zterm_impl) _Ret_valid_impl_)_Result_zeroonfailure__SAL2_Source_(_Result_zeroonfailure_, (), _On_failure_(_Notref_impl_ _Deref_impl_ _Out_range_(==, 0)))_Result_nullonfailure__SAL2_Source_(_Result_nullonfailure_, (), _On_failure_(_Notref_impl_ _Deref_impl_ _Post_null_))_Outref_result_nullonfailure__SAL2_Source_(_Outref_result_nullonfailure_, (), _Outref_ _On_failure_(_Post_null_))_Outref_result_bytebuffer_all_maybenull_(size)_SAL2_Source_(_Outref_result_bytebuffer_all_maybenull_, (size), _Outref_result_bytebuffer_to_maybenull_(size, _Old_(size)))_Outref_result_buffer_all_maybenull_(size)_SAL2_Source_(_Outref_result_buffer_all_maybenull_, (size), _Outref_result_buffer_to_maybenull_(size, _Old_(size)))_Outref_result_bytebuffer_to_maybenull_(size,count)_SAL2_Source_(_Outref_result_bytebuffer_to_maybenull_, (size, count), _Outref_result_bytebuffer_maybenull_(size) _Post1_impl_(__bytecount_impl(count)))_Outref_result_buffer_to_maybenull_(size,count)_SAL2_Source_(_Outref_result_buffer_to_maybenull_, (size, count), _Outref_result_buffer_maybenull_(size) _Post1_impl_(__count_impl(count)))_Outref_result_bytebuffer_maybenull_(size)_SAL2_Source_(_Outref_result_bytebuffer_maybenull_, (size), _Outref_result_maybenull_ _Post1_impl_(__bytecap_impl(size)))_Outref_result_buffer_maybenull_(size)_SAL2_Source_(_Outref_result_buffer_maybenull_, (size), _Outref_result_maybenull_ _Post1_impl_(__cap_impl(size)))_Outref_result_bytebuffer_all_(size)_SAL2_Source_(_Outref_result_bytebuffer_all_, (size), _Outref_result_bytebuffer_to_(size, _Old_(size)))_Outref_result_buffer_all_(size)_SAL2_Source_(_Outref_result_buffer_all_, (size), _Outref_result_buffer_to_(size, _Old_(size)))_Outref_result_bytebuffer_to_(size,count)_SAL2_Source_(_Outref_result_bytebuffer_to_, (size, count), _Outref_result_bytebuffer_(size) _Post1_impl_(__bytecount_impl(count)))_Outref_result_buffer_to_(size,count)_SAL2_Source_(_Outref_result_buffer_to_, (size, count), _Outref_result_buffer_(size) _Post1_impl_(__count_impl(count)))_Outref_result_bytebuffer_(size)_SAL2_Source_(_Outref_result_bytebuffer_, (size), _Outref_ _Post1_impl_(__bytecap_impl(size)))_Outref_result_buffer_(size)_SAL2_Source_(_Outref_result_buffer_, (size), _Outref_ _Post1_impl_(__cap_impl(size)))_Outref_result_maybenull__SAL2_Source_(_Outref_result_maybenull_, (), _Pre2_impl_(__notnull_impl_notref, __cap_c_one_notref_impl) _Post_maybenull_ _Post_valid_impl_)_Outref__SAL2_Source_(_Outref_, (), _Out_impl_ _Post_notnull_)_Outptr_opt_result_bytebuffer_all_maybenull_(size)_SAL2_Source_(_Outptr_opt_result_bytebuffer_all_maybenull_, (size), _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __bytecount_impl(size)))_Outptr_result_bytebuffer_all_maybenull_(size)_SAL2_Source_(_Outptr_result_bytebuffer_all_maybenull_, (size), _Out_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __bytecount_impl(size)))_Outptr_opt_result_bytebuffer_to_maybenull_(size,count)_SAL2_Source_(_Outptr_opt_result_bytebuffer_to_maybenull_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__maybenull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))_Outptr_result_bytebuffer_to_maybenull_(size,count)_SAL2_Source_(_Outptr_result_bytebuffer_to_maybenull_, (size, count), _Out_impl_ _Deref_post3_impl_(__maybenull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))_Outptr_opt_result_bytebuffer_maybenull_(size)_SAL2_Source_(_Outptr_opt_result_bytebuffer_maybenull_, (size), _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __bytecap_impl(size)))_Outptr_result_bytebuffer_maybenull_(size)_SAL2_Source_(_Outptr_result_bytebuffer_maybenull_, (size), _Out_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __bytecap_impl(size)))_Outptr_opt_result_bytebuffer_all_(size)_SAL2_Source_(_Outptr_opt_result_bytebuffer_all_, (size), _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __bytecount_impl(size)))_Outptr_result_bytebuffer_all_(size)_SAL2_Source_(_Outptr_result_bytebuffer_all_, (size), _Out_impl_ _Deref_post2_impl_(__notnull_impl_notref, __bytecount_impl(size)))_Outptr_opt_result_bytebuffer_to_(size,count)_SAL2_Source_(_Outptr_opt_result_bytebuffer_to_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__notnull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))_Outptr_result_bytebuffer_to_(size,count)_SAL2_Source_(_Outptr_result_bytebuffer_to_, (size, count), _Out_impl_ _Deref_post3_impl_(__notnull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))_Outptr_opt_result_bytebuffer_(size)_SAL2_Source_(_Outptr_opt_result_bytebuffer_, (size), _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __bytecap_impl(size)))_Outptr_result_bytebuffer_(size)_SAL2_Source_(_Outptr_result_bytebuffer_, (size), _Out_impl_ _Deref_post2_impl_(__notnull_impl_notref, __bytecap_impl(size)))_Outptr_opt_result_buffer_all_maybenull_(size)_SAL2_Source_(_Outptr_opt_result_buffer_all_maybenull_, (size), _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(size)))_Outptr_result_buffer_all_maybenull_(size)_SAL2_Source_(_Outptr_result_buffer_all_maybenull_, (size), _Out_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(size)))_Outptr_opt_result_buffer_to_maybenull_(size,count)_SAL2_Source_(_Outptr_opt_result_buffer_to_maybenull_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__maybenull_impl_notref, __cap_impl(size), __count_impl(count)))_Outptr_result_buffer_to_maybenull_(size,count)_SAL2_Source_(_Outptr_result_buffer_to_maybenull_, (size, count), _Out_impl_ _Deref_post3_impl_(__maybenull_impl_notref, __cap_impl(size), __count_impl(count)))_Outptr_opt_result_buffer_maybenull_(size)_SAL2_Source_(_Outptr_opt_result_buffer_maybenull_, (size), _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __cap_impl(size)))_Outptr_result_buffer_maybenull_(size)_SAL2_Source_(_Outptr_result_buffer_maybenull_, (size), _Out_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __cap_impl(size)))_Outptr_opt_result_buffer_all_(size)_SAL2_Source_(_Outptr_opt_result_buffer_all_, (size), _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __count_impl(size)))_Outptr_result_buffer_all_(size)_SAL2_Source_(_Outptr_result_buffer_all_, (size), _Out_impl_ _Deref_post2_impl_(__notnull_impl_notref, __count_impl(size)))_Outptr_opt_result_buffer_to_(size,count)_SAL2_Source_(_Outptr_opt_result_buffer_to_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__notnull_impl_notref, __cap_impl(size), __count_impl(count)))_Outptr_result_buffer_to_(size,count)_SAL2_Source_(_Outptr_result_buffer_to_, (size, count), _Out_impl_ _Deref_post3_impl_(__notnull_impl_notref, __cap_impl(size), __count_impl(count)))_Outptr_opt_result_buffer_(size)_SAL2_Source_(_Outptr_opt_result_buffer_, (size), _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __cap_impl(size)))_Outptr_result_buffer_(size)_SAL2_Source_(_Outptr_result_buffer_, (size), _Out_impl_ _Deref_post2_impl_(__notnull_impl_notref, __cap_impl(size)))_COM_Outptr_opt_result_maybenull__SAL2_Source_(_COM_Outptr_opt_result_maybenull_, (), _Outptr_opt_result_maybenull_ _On_failure_(_Deref_post_null_))_COM_Outptr_opt__SAL2_Source_(_COM_Outptr_opt_, (), _Outptr_opt_ _On_failure_(_Deref_post_null_))_COM_Outptr_result_maybenull__SAL2_Source_(_COM_Outptr_result_maybenull_, (), _Outptr_result_maybenull_ _On_failure_(_Deref_post_null_))_COM_Outptr__SAL2_Source_(_COM_Outptr_, (), _Outptr_ _On_failure_(_Deref_post_null_))_Outptr_opt_result_nullonfailure__SAL2_Source_(_Outptr_opt_result_nullonfailure_, (), _Outptr_opt_ _On_failure_(_Deref_post_null_))_SAL2_Source_(_Outptr_result_nullonfailure_, (), _Outptr_ _On_failure_(_Deref_post_null_))_Outptr_opt_result_maybenull_z__SAL2_Source_(_Outptr_opt_result_maybenull_z_, (), _Out_opt_impl_ _Deref_post_opt_z_)_Outptr_result_maybenull_z__SAL2_Source_(_Outptr_result_maybenull_z_, (), _Out_impl_ _Deref_post_opt_z_)_Outptr_opt_result_z__SAL2_Source_(_Outptr_opt_result_z_, (), _Out_opt_impl_ _Deref_post_z_)_Outptr_result_z__SAL2_Source_(_Outptr_result_z_, (), _Out_impl_ _Deref_post_z_)_Outptr_opt_result_maybenull__SAL2_Source_(_Outptr_opt_result_maybenull_, (), _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(1)))_Outptr_opt__SAL2_Source_(_Outptr_opt_, (), _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __count_impl(1)))_SAL2_Source_(_Outptr_result_maybenull_, (), _Out_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(1)))_SAL2_Source_(_Outptr_, (), _Out_impl_ _Deref_post2_impl_(__notnull_impl_notref, __count_impl(1)))_Inout_updates_bytes_all_opt_(size)_SAL2_Source_(_Inout_updates_bytes_all_opt_, (size), _Inout_updates_bytes_to_opt_(_Old_(size), _Old_(size)))_Inout_updates_bytes_all_(size)_SAL2_Source_(_Inout_updates_bytes_all_, (size), _Inout_updates_bytes_to_(_Old_(size), _Old_(size)))_Inout_updates_bytes_to_opt_(size,count)_SAL2_Source_(_Inout_updates_bytes_to_opt_, (size,count), _Out_writes_bytes_to_opt_(size,count) _Pre_valid_impl_ _Pre1_impl_(__bytecount_impl(size)))_Inout_updates_bytes_to_(size,count)_SAL2_Source_(_Inout_updates_bytes_to_, (size,count), _Out_writes_bytes_to_(size,count) _Pre_valid_impl_ _Pre1_impl_(__bytecount_impl(size)))_Inout_updates_bytes_opt_(size)_SAL2_Source_(_Inout_updates_bytes_opt_, (size), _Pre_opt_bytecap_(size) _Pre_valid_impl_ _Post_valid_impl_)_Inout_updates_bytes_(size)_SAL2_Source_(_Inout_updates_bytes_, (size), _Pre_bytecap_(size) _Pre_valid_impl_ _Post_valid_impl_)_Inout_updates_all_opt_(size)_SAL2_Source_(_Inout_updates_all_opt_, (size), _Inout_updates_to_opt_(_Old_(size), _Old_(size)))_Inout_updates_all_(size)_SAL2_Source_(_Inout_updates_all_, (size), _Inout_updates_to_(_Old_(size), _Old_(size)))_Inout_updates_to_opt_(size,count)_SAL2_Source_(_Inout_updates_to_opt_, (size,count), _Out_writes_to_opt_(size,count) _Pre_valid_impl_ _Pre1_impl_(__count_impl(size)))_Inout_updates_to_(size,count)_SAL2_Source_(_Inout_updates_to_, (size,count), _Out_writes_to_(size,count) _Pre_valid_impl_ _Pre1_impl_(__count_impl(size)))_Inout_updates_opt_z_(size)_SAL2_Source_(_Inout_updates_opt_z_, (size), _Pre_opt_cap_(size) _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl))_Inout_updates_z_(size)_SAL2_Source_(_Inout_updates_z_, (size), _Pre_cap_(size) _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl))_Inout_updates_opt_(size)_SAL2_Source_(_Inout_updates_opt_, (size), _Pre_opt_cap_(size) _Pre_valid_impl_ _Post_valid_impl_)_Inout_updates_(size)_SAL2_Source_(_Inout_updates_, (size), _Pre_cap_(size) _Pre_valid_impl_ _Post_valid_impl_)_Inout_opt_z__SAL2_Source_(_Inout_opt_z_, (), _Prepost_opt_z_)_Inout_z__SAL2_Source_(_Inout_z_, (), _Prepost_z_)_SAL2_Source_(_Inout_opt_, (), _Prepost_opt_valid_)_SAL2_Source_(_Inout_, (), _Prepost_valid_)_Out_writes_to_ptr_opt_z_(ptr)_SAL2_Source_(_Out_writes_to_ptr_opt_z_, (ptr), _Pre_opt_ptrdiff_cap_(ptr) _Post_valid_impl_ Post_z_)_Out_writes_to_ptr_z_(ptr)_SAL2_Source_(_Out_writes_to_ptr_z_, (ptr), _Pre_ptrdiff_cap_(ptr) _Post_valid_impl_ Post_z_)_Out_writes_to_ptr_opt_(ptr)_SAL2_Source_(_Out_writes_to_ptr_opt_, (ptr), _Pre_opt_ptrdiff_cap_(ptr) _Post_valid_impl_)_Out_writes_to_ptr_(ptr)_SAL2_Source_(_Out_writes_to_ptr_, (ptr), _Pre_ptrdiff_cap_(ptr) _Post_valid_impl_)_Out_writes_bytes_all_opt_(size)_SAL2_Source_(_Out_writes_bytes_all_opt_, (size), _Out_writes_bytes_to_opt_(_Old_(size), _Old_(size)))_Out_writes_bytes_all_(size)_SAL2_Source_(_Out_writes_bytes_all_, (size), _Out_writes_bytes_to_(_Old_(size), _Old_(size)))_Out_writes_bytes_to_opt_(size,count)_SAL2_Source_(_Out_writes_bytes_to_opt_, (size,count), _Pre_opt_bytecap_(size) _Post_valid_impl_ _Post_bytecount_(count))_Out_writes_bytes_to_(size,count)_SAL2_Source_(_Out_writes_bytes_to_, (size,count), _Pre_bytecap_(size) _Post_valid_impl_ _Post_bytecount_(count))_Out_writes_all_opt_(size)_SAL2_Source_(_Out_writes_all_opt_, (size), _Out_writes_to_opt_(_Old_(size), _Old_(size)))_Out_writes_all_(size)_SAL2_Source_(_Out_writes_all_, (size), _Out_writes_to_(_Old_(size), _Old_(size)))_Out_writes_to_opt_(size,count)_SAL2_Source_(_Out_writes_to_opt_, (size,count), _Pre_opt_cap_(size) _Post_valid_impl_ _Post_count_(count))_Out_writes_to_(size,count)_SAL2_Source_(_Out_writes_to_, (size,count), _Pre_cap_(size) _Post_valid_impl_ _Post_count_(count))_Out_writes_opt_z_(size)_SAL2_Source_(_Out_writes_opt_z_, (size), _Pre_opt_cap_(size) _Post_valid_impl_ _Post_z_)_Out_writes_z_(size)_SAL2_Source_(_Out_writes_z_, (size), _Pre_cap_(size) _Post_valid_impl_ _Post_z_)_Out_writes_bytes_opt_(size)_SAL2_Source_(_Out_writes_bytes_opt_, (size), _Pre_opt_bytecap_(size) _Post_valid_impl_)_Out_writes_bytes_(size)_SAL2_Source_(_Out_writes_bytes_, (size), _Pre_bytecap_(size) _Post_valid_impl_)_Out_writes_opt_(size)_SAL2_Source_(_Out_writes_opt_, (size), _Pre_opt_cap_(size) _Post_valid_impl_)_Out_writes_(size)_SAL2_Source_(_Out_writes_, (size), _Pre_cap_(size) _Post_valid_impl_)_SAL2_Source_(_Out_opt_, (), _Out_opt_impl_)_SAL2_Source_(_Out_, (), _Out_impl_)_In_reads_to_ptr_opt_z_(ptr)_SAL2_Source_(_In_reads_to_ptr_opt_z_, (ptr), _Pre_opt_ptrdiff_count_(ptr) _Deref_pre_readonly_ _Pre_opt_z_)_In_reads_to_ptr_z_(ptr)_SAL2_Source_(_In_reads_to_ptr_z_, (ptr), _In_reads_to_ptr_(ptr) _Pre_z_)_In_reads_to_ptr_opt_(ptr)_SAL2_Source_(_In_reads_to_ptr_opt_, (ptr), _Pre_opt_ptrdiff_count_(ptr) _Deref_pre_readonly_)_In_reads_to_ptr_(ptr)_SAL2_Source_(_In_reads_to_ptr_, (ptr), _Pre_ptrdiff_count_(ptr) _Deref_pre_readonly_)_In_reads_or_z_opt_(size)_SAL2_Source_(_In_reads_or_z_opt_, (size), _In_opt_ _When_(_String_length_(_Curr_) < (size), _Pre_z_) _When_(_String_length_(_Curr_) >= (size), _Pre1_impl_(__count_impl(size))))_In_reads_or_z_(size)_SAL2_Source_(_In_reads_or_z_, (size), _In_ _When_(_String_length_(_Curr_) < (size), _Pre_z_) _When_(_String_length_(_Curr_) >= (size), _Pre1_impl_(__count_impl(size))))_In_reads_opt_z_(size)_SAL2_Source_(_In_reads_opt_z_, (size), _Pre_opt_count_(size) _Deref_pre_readonly_ _Pre_opt_z_)_In_reads_z_(size)_SAL2_Source_(_In_reads_z_, (size), _In_reads_(size) _Pre_z_)_In_reads_bytes_opt_(size)_SAL2_Source_(_In_reads_bytes_opt_, (size), _Pre_opt_bytecount_(size) _Deref_pre_readonly_)_In_reads_bytes_(size)_SAL2_Source_(_In_reads_bytes_, (size), _Pre_bytecount_(size) _Deref_pre_readonly_)_In_reads_opt_(size)_SAL2_Source_(_In_reads_opt_, (size), _Pre_opt_count_(size) _Deref_pre_readonly_)_In_reads_(size)_SAL2_Source_(_In_reads_, (size), _Pre_count_(size) _Deref_pre_readonly_)_SAL2_Source_(_In_opt_z_, (), _In_opt_ _Pre1_impl_(__zterm_impl))_SAL2_Source_(_In_z_, (), _In_ _Pre1_impl_(__zterm_impl))_SAL2_Source_(_In_opt_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_ _Deref_pre_readonly_)_SAL2_Source_(_In_, (), _Pre1_impl_(__notnull_impl_notref) _Pre_valid_impl_ _Deref_pre1_impl_(__readaccess_impl_notref))_Const__SAL2_Source_(_Const_, (), _Pre1_impl_(__readaccess_impl_notref))_Reserved__SAL2_Source_(_Reserved_, (), _Pre1_impl_(__null_impl))_Inout_defensive_(annotes)_Pre_defensive_ _Post_defensive_ _Group_(annotes)_Out_defensive_(annotes)_Post_defensive_ _Group_(annotes)_In_defensive_(annotes)_Pre_defensive_ _Group_(annotes)_Post_defensive__SA_annotes0(SAL_post_defensive)_Pre_defensive__SA_annotes0(SAL_pre_defensive)_Notref__Use_decl_annotations__Always_(annos)_Always_impl_(annos _SAL_nop_impl_)_On_failure_(annos)_On_failure_impl_(annos _SAL_nop_impl_)_Return_type_success_(expr)_SAL2_Source_(_Return_type_success_, (expr), _Success_impl_(expr))_Success_(expr)_SAL2_Source_(_Success_, (expr), _Success_impl_(expr))_GrouP_(annos)_GrouP_impl_(annos _SAL_nop_impl_)_Group_(annos)_Group_impl_(annos _SAL_nop_impl_)_When_(expr,annos)_When_impl_(expr, annos _SAL_nop_impl_)_At_buffer_(target,iter,bound,annos)_At_buffer_impl_(target, iter, bound, annos _SAL_nop_impl_)_At_(target,annos)_At_impl_(target, annos _SAL_nop_impl_)_SAL_L_Source_(Name,args,annotes)_SA_annotes3(SAL_name, #Name, "", "2") _Group_(annotes _SAL_nop_impl_)_SAL2_Source_(Name,args,annotes)_SAL1_2_Source_(Name,args,annotes)_SA_annotes3(SAL_name, #Name, "", "1.2") _Group_(annotes _SAL_nop_impl_)_SAL1_1_Source_(Name,args,annotes)_SA_annotes3(SAL_name, #Name, "", "1.1") _Group_(annotes _SAL_nop_impl_)_SAL1_Source_(Name,args,annotes)_SA_annotes3(SAL_name, #Name, "", "1") _Group_(annotes _SAL_nop_impl_)_USE_ATTRIBUTES_FOR_SAL_USE_DECLSPECS_FOR_SAL__SAL_H_VERSION180000000_SAL_VERSION__ATTR_SAL_PREFAST_!defined(_USE_ATTRIBUTES_FOR_SAL)!_USE_DECLSPECS_FOR_SAL!_USE_ATTRIBUTES_FOR_SAL_USE_DECLSPECS_FOR_SAL && ( defined( MIDL_PASS ) || defined(__midl) || defined(RC_INVOKED) || !defined(_PREFAST_) )_USE_ATTRIBUTES_FOR_SAL && ( !defined(_MSC_EXTENSIONS) || defined( MIDL_PASS ) || defined(__midl) || defined(RC_INVOKED) )_USE_DECLSPECS_FOR_SAL || _USE_ATTRIBUTES_FOR_SALdefined(UNDOCKED_WINDOWS_UCRT) && !_USE_ATTRIBUTES_FOR_SAL_SAL_L_Source_region Input Buffer SAL 1 compatibility macrosendregion Input Buffer SAL 1 compatibility macros_USE_ATTRIBUTES_FOR_SAL || _USE_DECLSPECS_FOR_SALdefined(_MSC_EXTENSIONS) && !defined( MIDL_PASS ) && !defined(__midl) && !defined(RC_INVOKED) && defined(_PFT_VER)!defined(__midl) && defined(_PREFAST_)_USING_V110_SDK71_(!defined(_MSVC_LANG) || _MSVC_LANG < 201703l)__analysis_assume_Analysis_assume__M_IX86_In_function_class_(__In_impl_ char*);SAL_functionClassNew(__In_impl_ char*);SAL_analysisMode(__AuToQuOtE __In_impl_ char *mode);_MSC_EXTENSIONS// Function class annotations.//  _Analysis_operator_new_never_fails_ (operator new never fails)//  _Analysis_operator_new_null_        (operator new returns null)//  _Analysis_operator_new_throw_   (operator new throws)// The following are predefined:// ][// so avoid reporting them on other platforms.// Floating point warnings are only meaningful in kernel-mode on x86// Synthesize a unique symbol.// as a declaration.// They take effect at the point of declaration; use at global scope// Set the analysis mode (global flags to analysis)./*
-------------------------------------------------------------------------------
Advanced Annotation Definitions

Any of these may be used to directly annotate functions, and may be used in
combination with each other or with regular buffer macros. For an explanation
of each annotation, see the advanced annotations section.
-------------------------------------------------------------------------------
*//*
-------------------------------------------------------------------------------
Buffer Annotation Definitions

Any of these may be used to directly annotate functions, but only one should
be used for each parameter. To determine which annotation to use for a given
buffer, use the table in the buffer annotations section.
-------------------------------------------------------------------------------
*//* !defined(__midl) && defined(_PREFAST_) *//*
     Pre-defined data entry point categories include: Registry, File, Network.
    *//*
     Macros to classify the entrypoints and indicate their category.

     Pre-defined control point categories include: RPC, LPC, DeviceDriver, UserToKernel, ISAPI, COM.

    *//*
     __inner_*

     Helper macros that directly correspond to certain high-level annotations.

    *//*
     _refparam

     Added to all out parameter macros to indicate that they are all reference
     parameters.
    *//*
     __exceptthat

     Given a set of annotations Q containing __exceptthat maybeP, the effect of
     the except clause is to erase any P or notP annotations (explicit or
     implied) within Q at the same level of dereferencing that the except
     clause appears, and to replace it with maybeP.

      Example 1: __valid __pre_except_maybenull on a pointer p means that the
                 pointer may be null, and is otherwise valid, thus overriding
                 the implicit notnull annotation implied by __valid on
                 pointers.

      Example 2: __valid __deref __pre_except_maybenull on an int **p means
                 that p is not null (implied by valid), but the elements
                 pointed to by p could be null, and are otherwise valid.
    *//*
     __postcond(<expr>)

     When <expr> is true, the next annotation applies in the postcondition state
     (currently not enabled)
    *//*
     __precond(<expr>)

     When <expr> is true, the next annotation applies in the precondition state
     (currently not enabled)
    *//*
     __post __next_annotation

     The next annotation applies in the postcondition state
    *//*
     __pre __next_annotation

     The next annotation applies in the precondition state
    *//*
     __deref p

     Annotates a pointer p. The next annotation applies one dereference down
     in the type. If readableTo(p, size) then the next annotation applies to
     all elements *(p+i) for which i satisfies the size. If p is a pointer
     to a struct, the next annotation applies to all fields of the struct.
    *//*
     __byte_writableTo(size)

     Annotates a buffer pointer p as being writable to size bytes.
    *//*
     __elem_writableTo(size)

     Annotates a buffer pointer p as being writable to size elements.
    *//*
     __writableTo(extent) p

     Annotates a buffer pointer p. If the buffer can be modified, extent
     describes how much of the buffer is writable (usually the allocation
     size). For a writer of the buffer, this is an explicit permission to
     write up to that amount, rather than a restriction to write only up to it.
    *//*
     __byte_readableTo(size)

     Annotates a buffer pointer p as being readable to size bytes.
    *//*

     __elem_readableTo(size)

     Annotates a buffer pointer p as being readable to size elements.
    *//*
     __readableTo(extent) p

     Annotates a buffer pointer p.  If the buffer can be read, extent describes
     how much of the buffer is readable. For a reader of the buffer, this is
     an explicit permission to read up to that amount, rather than a restriction to
     read only up to it.
    *//*
     __valid v
     __notvalid v
     __maybevalid v

     Annotates any value v. States that the value satisfies all properties of
     valid values of its type. For example, for a string buffer, valid means
     that the buffer pointer is either NULL or points to a NULL-terminated string.
    *//*
     __readonly l
     __notreadonly l
     __maybereadonly l

     Annotates a location l. States that location l is not modified after
     this point.  If the annotation is placed on the precondition state of
     a function, the restriction only applies until the postcondition state
     of the function.  __maybereadonly states that the annotated location
     may be modified, whereas __notreadonly states that a location must be
     modified.
    *//*
     __null p
     __notnull p
     __maybenull p

     Annotates a pointer p. States that pointer p is null. Commonly used
     in the negated form __notnull or the possibly null form __maybenull.
    *//*
     In the primitive "SAL_*" annotations "SAL" stands for Standard
     Annotation Language.  These "SAL_*" annotations are the
     primitives the compiler understands and high-level MACROs
     will decompose into these primitives.
    *//*
    The helper annotations are only understood by the compiler version used by
    various defect detection tools. When the regular compiler is running, they
    are defined into nothing, and do not affect the compiled code.
*//*
 -------------------------------------------------------------------------------
 Helper Macro Definitions

 These express behavior common to many of the high-level annotations.
 DO NOT USE THESE IN YOUR CODE.
 -------------------------------------------------------------------------------
*//*
 -------------------------------------------------------------------------------
 Introduction

 sal.h provides a set of annotations to describe how a function uses its
 parameters - the assumptions it makes about them, and the guarantees it makes
 upon finishing.

 Annotations may be placed before either a function parameter's type or its return
 type, and describe the function's behavior regarding the parameter or return value.
 There are two classes of annotations: buffer annotations and advanced annotations.
 Buffer annotations describe how functions use their pointer parameters, and
 advanced annotations either describe complex/unusual buffer behavior, or provide
 additional information about a parameter that is not otherwise expressible.

 -------------------------------------------------------------------------------
 Buffer Annotations

 The most important annotations in sal.h provide a consistent way to annotate
 buffer parameters or return values for a function. Each of these annotations describes
 a single buffer (which could be a string, a fixed-length or variable-length array,
 or just a pointer) that the function interacts with: where it is, how large it is,
 how much is initialized, and what the function does with it.

 The appropriate macro for a given buffer can be constructed using the table below.
 Just pick the appropriate values from each category, and combine them together
 with a leading underscore. Some combinations of values do not make sense as buffer
 annotations. Only meaningful annotations can be added to your code; for a list of
 these, see the buffer annotation definitions section.

 Only a single buffer annotation should be used for each parameter.

 |------------|------------|---------|--------|----------|----------|---------------|
 |   Level    |   Usage    |  Size   | Output | NullTerm | Optional |  Parameters   |
 |------------|------------|---------|--------|----------|----------|---------------|
 | <>         | <>         | <>      | <>     | _z       | <>       | <>            |
 | _deref     | _in        | _ecount | _full  | _nz      | _opt     | (size)        |
 | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
 |            | _inout     |         |        |          |          |               |
 |            |            |         |        |          |          |               |
 |------------|------------|---------|--------|----------|----------|---------------|

 Level: Describes the buffer pointer's level of indirection from the parameter or
          return value 'p'.

 <>         : p is the buffer pointer.
 _deref     : *p is the buffer pointer. p must not be NULL.
 _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
                the annotation is ignored.

 Usage: Describes how the function uses the buffer.

 <>     : The buffer is not accessed. If used on the return value or with _deref, the
            function will provide the buffer, and it will be uninitialized at exit.
            Otherwise, the caller must provide the buffer. This should only be used
            for alloc and free functions.
 _in    : The function will only read from the buffer. The caller must provide the
            buffer and initialize it. Cannot be used with _deref.
 _out   : The function will only write to the buffer. If used on the return value or
            with _deref, the function will provide the buffer and initialize it.
            Otherwise, the caller must provide the buffer, and the function will
            initialize it.
 _inout : The function may freely read from and write to the buffer. The caller must
            provide the buffer and initialize it. If used with _deref, the buffer may
            be reallocated by the function.

 Size: Describes the total size of the buffer. This may be less than the space actually
         allocated for the buffer, in which case it describes the accessible amount.

 <>      : No buffer size is given. If the type specifies the buffer size (such as
             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
             element long. Must be used with _in, _out, or _inout.
 _ecount : The buffer size is an explicit element count.
 _bcount : The buffer size is an explicit byte count.

 Output: Describes how much of the buffer will be initialized by the function. For
           _inout buffers, this also describes how much is initialized at entry. Omit this
           category for _in buffers; they must be fully initialized by the caller.

 <>    : The type specifies how much is initialized. For instance, a function initializing
           an LPWSTR must NULL-terminate the string.
 _full : The function initializes the entire buffer.
 _part : The function initializes part of the buffer, and explicitly indicates how much.

 NullTerm: States if the present of a '\0' marks the end of valid elements in the buffer.
 _z    : A '\0' indicated the end of the buffer
 _nz     : The buffer may not be null terminated and a '\0' does not indicate the end of the
          buffer.
 Optional: Describes if the buffer itself is optional.

 <>   : The pointer to the buffer must not be NULL.
 _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.

 Parameters: Gives explicit counts for the size and length of the buffer.

 <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
 (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
 (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
                   and _bcount_part.

 -------------------------------------------------------------------------------
 Buffer Annotation Examples

 LWSTDAPI_(BOOL) StrToIntExA(
     __in LPCSTR pszString,
     DWORD dwFlags,
     __out int *piRet                     -- A pointer whose dereference will be filled in.
 );

 void MyPaintingFunction(
     __in HWND hwndControl,               -- An initialized read-only parameter.
     __in_opt HDC hdcOptional,            -- An initialized read-only parameter that might be NULL.
     __inout IPropertyStore *ppsStore     -- An initialized parameter that may be freely used
                                          --   and modified.
 );

 LWSTDAPI_(BOOL) PathCompactPathExA(
     __out_ecount(cchMax) LPSTR pszOut,   -- A string buffer with cch elements that will
                                          --   be NULL terminated on exit.
     __in LPCSTR pszSrc,
     UINT cchMax,
     DWORD dwFlags
 );

 HRESULT SHLocalAllocBytes(
     size_t cb,
     __deref_bcount(cb) T **ppv           -- A pointer whose dereference will be set to an
                                          --   uninitialized buffer with cb bytes.
 );

 __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at
     entry and exit, and may be written to by this function.

 __out_ecount_part(count, *countOut) : A buffer with count elements that will be
     partially initialized by this function. The function indicates how much it
     initialized by setting *countOut.

 -------------------------------------------------------------------------------
 Advanced Annotations

 Advanced annotations describe behavior that is not expressible with the regular
 buffer macros. These may be used either to annotate buffer parameters that involve
 complex or conditional behavior, or to enrich existing annotations with additional
 information.

 __success(expr) f :
     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,
     all the function's guarantees (as given by other annotations) must hold. If <expr>
     is false at exit, the caller should not expect any of the function's guarantees
     to hold. If not used, the function must always satisfy its guarantees. Added
     automatically to functions that indicate success in standard ways, such as by
     returning an HRESULT.

 __nullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     NULL character or pointer. May be used on typedefs, which marks valid (properly
     initialized) instances of that type as being NULL-terminated.

 __nullnullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     sequence of two NULL characters or pointers. May be used on typedefs, which marks
     valid instances of that type as being double-NULL terminated.

 __reserved v :
     Value v must be 0/NULL, reserved for future use.

 __checkReturn v :
     Return value v must not be ignored by callers of this function.

 __typefix(ctype) v :
     Value v should be treated as an instance of ctype, rather than its declared type.

 __override f :
     Specify C#-style 'override' behaviour for overriding virtual methods.

 __callback f :
     Function f can be used as a function pointer.

 __format_string p :
     Pointer p is a string that contains % markers in the style of printf.

 __blocksOn(resource) f :
     Function f blocks on the resource 'resource'.

 __fallthrough :
     Annotates switch statement labels where fall-through is desired, to distinguish
     from forgotten break statements.

 -------------------------------------------------------------------------------
 Advanced Annotation Examples

 __success(return != FALSE) LWSTDAPI_(BOOL)
 PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
    pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.

 typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.

 __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be
     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.

 -------------------------------------------------------------------------------
*/// This section contains the deprecated annotations// Obsolete -- may be needed for transition to attributes.//[__P_impl(__d_=0)]// !__cplusplus // ]// !__cplusplus // ][// minimum attribute expansion for foreground build// this is a special case!// _SA_annotes1(SAL_valid, __maybe)// _SA_annotes1(SAL_valid, __no)// _SA_annotes1(SAL_valid, __yes)// _SA_annotes1(SAL_null, __maybe)// _SA_annotes1(SAL_null, __no)// _SA_annotes1(SAL_null, __yes)// For SAL2, we need to expect general expressions.// To be declared well-known soon.// Only appears in model files, but needs to be declared.//??? resolve with PFD// Declare annotations that need to be declared.// Using "nothing" for sal// namespace.// Done this way so that they don't appear in the regular compiler's// Declare a function to be an annotation or primop (respectively).// Using declspecs for sal// Benign declspec needed here for WindowsPREfast// Using attributes for sal/* nothing */// defer that check to the plugin.// Normally the parser does some simple type checking of annotation params,// We're tying to phase this out, someday.  The parser quotes the param.// suitable for annotating general code.// The following are for the implementation machinery, and are not// exist.// here to assure that only necessary differences in the annotations// forms but are part of the implementation of the macros.  These are collected// Sharable "_impl" macros: these can be shared between the various annotation// up even higher level annotations.// but it does form a complete annotation; usually they are used to build// A symbol ending in _impl_ is reserved to the implementation as well,// to build up more complete annotations.// symbols will be used in the _PreN..., _PostN... and _RetN... annotations// annotations, it might be, but it should not be assumed so.)  Those// of attribute annotations, usually is not.  (In the case of some declspec// not required to be a legal standalone annotation, and in the case// A symbol that ends with _impl is the very lowest level macro.  It is// of attributes.// annotations; many of those come from sourceannotations.h in the case// A symbol the begins with _SA_ is for the machinery of creating any// Naming conventions://============================================================================//   Implementation Layer:// used with references to arrays// _Deref_<miscellaneous>// describing conditions for array elements or dereferenced pointer parameters that hold before and after the call// short version for _Deref_pre_<ann> _Deref_post_<ann>// _Deref_<both> ---// describing conditions that hold before and after the function call// _Prepost_ ---// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_count_(return+1) char* szFrom, size_t cchFrom );// e.g. int strlen( _In_z_ _Post_count_(return+1) const char* sz );// e.g. SIZE_T HeapSize( _In_ HANDLE hHeap, DWORD dwFlags, _Pre_notnull_ _Post_bytecap_(return) LPCVOID lpMem );// buffer maybe zero-terminated after the call// char * strncpy(_Out_cap_(_Count) _Post_maybez_ char * _Dest, _In_z_ const char * _Source, _In_ size_t _Count)// Valid buffer extent described by the difference to another pointer parameter// Valid buffer extent described by a complex expression// Valid buffer extent described by a constant expression// Valid buffer extent described by another parameter// e.g. void AppendCharRange( _Pre_count_(cchFrom) const char* rgFrom, size_t cchFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );// known capacity and valid but unknown readable extent// e.g. void AppendStr( _Pre_z_ const char* szFrom, _Pre_z_cap_(cchTo) _Post_z_ char* szTo, size_t cchTo );// buffer capacity described by the difference to another pointer parameter// buffer capacity described by a complex condition// e.g. int strcpy(_Pre_cap_for_(src) char* dst, const char* src);// buffer capacity described by size of other buffer, only used by dangerous legacy APIs// buffer capacity is described by another parameter multiplied by a constant expression// buffer capacity described by a constant expression// buffer capacity described by another parameter// e.g. void FreeMemory( _Pre_bytecap_(cb) _Post_ptr_invalid_ void* pv, size_t cb );// restrict access rights// _Pre_ annotations ---// return value is nullterminated and length is given by another parameter// Valid Buffer extent is described by a complex expression// Valid Buffer extent is described by a constant expression// Valid Buffer extent is described by another parameter// e.g. _Ret_opt_bytecount_(cb) void* AllocateZeroInitializedMemory( size_t cb );// return value is nullterminated and capacity is given by another parameter// Buffer capacity is described by a complex condition// Buffer capacity is described by a constant expression// Buffer capacity is described by another parameter// e.g. _Ret_opt_bytecap_(cb) void* AllocateMemory( size_t cb );// e.g. _Ret_opt_valid_ LPSTR void* CloneSTR( _Pre_valid_ LPSTR src );// _Ret_ ---// special _Deref_ ---// _Deref_ret_ ---// e.g. void GetStrings( _Out_count_(cElems) _Deref_post_valid_ LPSTR const rgStr[], size_t cElems );// buffer capacity is described by a complex expression// buffer capacity is described by a constant expression// valid buffer extent is described by another parameter// e.g. HRESULT HrAllocateZeroInitializedMemory( size_t cb, _Out_ _Deref_post_bytecount_(cb) void** ppv );// convenience macros for nullterminated buffers with given capacity// buffer capacity is described by another parameter// e.g. HRESULT HrAllocateMemory( size_t cb, _Out_ _Deref_post_bytecap_(cb) void** ppv );// e.g. void CloneString( _In_z_ const Wchar_t* wzIn _Out_ _Deref_post_z_ wchar_t** pWzOut );// describing conditions for array elements or dereferenced pointer parameters that hold after the call// _Deref_post_ ---// e.g. void PrintStringArray( _In_count_(cElems) _Deref_pre_valid_ LPCSTR rgStr[], size_t cElems );// valid buffer extent is described by a complex expression// valid buffer extent is described by a constant expression// e.g. void SaveMatrix( _In_count_(n) _Deref_pre_count_(n) const Elem** matrix, size_t n );// buffer capacity is described by a complex condition// e.g. void FillInArrayOfStr32( _In_count_(cStrings) _Deref_pre_cap_c_(32) _Deref_post_z_ wchar_t* const rgpwch[] );// e.g. void SaveStringArray( _In_count_(cStrings) _Deref_pre_z_ const wchar_t* const rgpwch[] );// describing conditions for array elements of dereferenced pointer parameters that must be met before the call// _Deref_pre_ ---// e.g.  void CloneString( _In_z_ const wchar_t* wzFrom, _Deref_out_z_ wchar_t** pWzTo );// e.g.  HRESULT HrCreatePoint( _Deref_out_opt_ POINT** ppPT );// annotations to express 'boundedness' of integral value parameter// returning pointers to valid objects// e.g. void AppendStr( _In_z_ const char* szFrom, _Inout_z_cap_(cchTo) char* szTo, size_t cchTo );// inout string buffers with writable size// e.g. void AppendToLPSTR( _In_ LPCSTR szFrom, _Inout_cap_(cchTo) LPSTR* szTo, size_t cchTo );// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndices, size_t cIndices );// nullterminated 'inout' buffers with initialized elements before and after the call// 'inout' buffers with initialized elements before and after the call// e.g. GetString( _Out_z_capcount_(*pLen+1) char* sz, size_t* pLen );// only use with dereferenced arguments e.g. '*pcch'// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Out_z_cap_post_count_(cchTo,return+1) char* szTo, size_t cchTo );// a zero terminated string is filled into a buffer of given capacity// e.g. size_t CopyCharRange( _In_count_(cchFrom) const char* rgchFrom, size_t cchFrom, _Out_cap_post_count_(cchTo,return)) char* rgchTo, size_t cchTo );// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );// e.g. void Foo( _Out_ptrdiff_cap_(pchMax) char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }// buffer capacity is described by another pointer// e.g. void GetIndices( _Out_cap_(cIndices) int* rgIndices, size_t cIndices );// 'out' with buffer size// e.g. void Set3ColMatrix( _In_count_x_(3*cRows) const Elem* matrix, int cRows );// 'x' version for complex expressions that are not supported by the current compiler version// e.g. void Foo( _In_ptrdiff_count_(pchMax) const char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }// nullterminated valid buffer extent described by a constant extression// nullterminated valid buffer extent described by another parameter// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )// nullterminated  'input' buffers with given size// valid buffer extent described by a constant extression// valid buffer extent described by another parameter/*==========================================================================

   This section contains definitions for macros defined for VS2010 and earlier.
   Usage of these macros is still supported, but the SAL 2 macros defined above
   are recommended instead.  This comment block is retained to assist in
   understanding SAL that still uses the older syntax.

   The macros are defined in 3 layers:

   _In_/_Out_ Layer:
   ----------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. Its macros start with _In_, _Out_ or _Inout_. For the
   typical case they provide the most concise annotations.

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_, _Post_, _Ret_,
   _Deref_pre_ _Deref_post_ and _Deref_ret_. This layer provides the most
   flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.


   Annotation Syntax:
   |--------------|----------|----------------|-----------------------------|
   |   Usage      | Nullness | ZeroTerminated |  Extent                     |
   |--------------|----------|----------------|-----------------------------|
   | _In_         | <>       | <>             | <>                          |
   | _Out_        | opt_     | z_             | [byte]cap_[c_|x_]( size )   |
   | _Inout_      |          |                | [byte]count_[c_|x_]( size ) |
   | _Deref_out_  |          |                | ptrdiff_cap_( ptr )         |
   |--------------|          |                | ptrdiff_count_( ptr )       |
   | _Ret_        |          |                |                             |
   | _Deref_ret_  |          |                |                             |
   |--------------|          |                |                             |
   | _Pre_        |          |                |                             |
   | _Post_       |          |                |                             |
   | _Deref_pre_  |          |                |                             |
   | _Deref_post_ |          |                |                             |
   |--------------|----------|----------------|-----------------------------|

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, _Deref_pre_, _Deref_post_ are for
   formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the pointer can be NULL the annotation contains _opt. If the macro
   does not contain '_opt' the pointer may not be NULL.

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   |------|---------------|---------------|
   | Unit | Writ/Readable | Argument Type |
   |------|---------------|---------------|
   |  <>  | cap_          | <>            |
   | byte | count_        | c_            |
   |      |               | x_            |
   |------|---------------|---------------|

   'cap' (capacity) describes the writable size of the buffer and is typically used
   with _Out_. The default unit is elements. Use 'bytecap' if the size is given in bytes
   'count' describes the readable size of the buffer and is typically used with _In_.
   The default unit is elements. Use 'bytecount' if the size is given in bytes.

   Argument syntax for cap_, bytecap_, count_, bytecount_:
   (<parameter>|return)[+n]  e.g. cch, return, cb+2

   If the buffer size is a constant expression use the c_ postfix.
   E.g. cap_c_(20), count_c_(MAX_PATH), bytecount_c_(16)

   If the buffer size is given by a limiting pointer use the ptrdiff_ versions
   of the macros.

   If the buffer size is neither a parameter nor a constant expression use the x_
   postfix. e.g. bytecount_x_(num*size) x_ annotations accept any arbitrary string.
   No analysis can be done for x_ annotations but they at least tell the tool that
   the buffer has some sort of extent description. x_ annotations might be supported
   by future compiler versions.

============================================================================*/// e.g. HRESULT GetObject(_Outptr_ _On_failure_(_At_(*p, _Post_null_)) T **p);// e.g. void ThrowExceptionIfNull( _Post_notnull_ const void* pv );// e.g. void free( _Post_ptr_invalid_ void* pv );// e.g. HRESULT InitStruct( _Post_valid_ Struct* pobj );// buffer will be a zero-terminated string after the call// void CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_ char* szFrom, size_t cchFrom );// describing conditions that hold after the function call// _Post_ annotations ---// used with allocated but not yet initialized objects// Overrides recursive valid when some field is not yet initialized when using _Inout_// valid size unknown or indicated by type (e.g.:LPSTR)// buffer is a zero terminated string// e.g. int strlen( _Pre_z_ const char* sz );// describing conditions that must be met before the call of the function// Pointer null-ness properties// Expressing buffer size as pre or post condition// Expressing buffer sizes without specifying pre or post condition// Buffer size properties// Validity property// Raw Pre/Post for declaring custom pre/post conditions//   _Pre_/_Post_ Layer:// Annotations to express struct, class and field invariants// or postcondition (respectively).// 'cond' may be any valid SAL expression that is considered to be true as a precondition// Annotations to allow expressing generalized pre and post conditions.// is not changed by a function call// annotation to express that a value (usually a field of a mutable class)// annotations to express value of integral or pointer parameter// e.g. MyPrintF( _Printf_format_string_ const wchar_t* wzFormat, ... );// Check the return value of a function e.g. _Check_return_ ErrorCode Foo();// Annotations for strict type checking//    returns pointer to partially initialized buffer, with total size 'size' and initialized size 'count'//    returns pointer to initialized buffer of specified size//    returns single valid object// used with allocated and initialized objects// e.g. _Ret_z_ CString::operator const wchar_t*() const noexcept;// describing conditions that hold for return values after the call// _Ret_ annotations// return values -------------------------------// Generic annotations to set output value of a by-pointer or by-reference parameter to null/zero on failure.// that the pointer is set to NULL on failure.// Annotations for output reference to pointer parameters that guarantee// Annotations for output reference to pointer parameters.// Annotations for _Outptr_ parameters returning a pointer to buffer with a specified number of elements/bytes// For pointers to types that are not COM objects, _Outptr_result_nullonfailure_ is preferred.// The current implementation is identical to _Outptr_result_nullonfailure_.// following the COM convention of setting the output to NULL on failure.// Annotations for _Outptr_ parameters which return a pointer to a ref-counted COM object,// Annotations for _Outptr_ parameters where the output pointer is set to NULL if the function fails.// Annotations for _Outptr_ parameters returning pointers to null terminated strings.//       if (*pData1 == *pData2) ...   // error: pData2 might be NULL after call//       MyFunc(&pData1, &pData2);     // ok: both non-NULL//       MyFunc(NULL, NULL);           // error: parameter 2, ppData2, should not be NULL//    Callers://       void MyFunc(_Outptr_opt_ int **ppData1, _Outptr_result_maybenull_ int **ppData2);//    Example://    _Outptr_*_result_maybenull_ - describes parameters where the called function might return NULL to the caller.//    _Outptr_opt_ - describes parameters that are allowed to be NULL.//      and initializes memory and returns the pointer to the new LPWSTR in *ppwsz.//      The caller passes the address of an LPWSTR variable as ppwsz, and SHStrDupW allocates//        HRESULT SHStrDupW(_In_ LPCWSTR psz, _Outptr_ LPWSTR *ppwsz);//      These describe parameters where the called function provides the buffer://   _Outptr_ - Annotations for output params returning pointers// Pointer to pointer parameters -------------------------// For modifying buffers with explicit byte size// For modifying buffers with explicit element size//   void toupper( _Inout_z_ char* sz );// For modifying string buffers//          void ModifyPointByRef( _Inout_ POINT& pPT );//          void ModifyPoint( _Inout_ POINT* pPT );//        potentially modified.//   _Inout_ - Annotations for pointer or reference parameters where data is passed in and// Inout parameters ----------------------------// e.g. void GetPoint( _Out_ POINT* pPT );//           _Outptr_/_Outref) (see below) are typically used to return pointers via parameters.//           These are mostly used where the pointer/reference is to a non-pointer type.//   _Out_ - Annotations for pointer or reference parameters where data passed back to the caller.// Output parameters --------------------------// 'input' buffers valid to the given end pointer// 'input' buffers with given size// nullterminated 'in' parameters.// e.g. void SetPoint( _In_ const POINT* pPT );//          _In_ by itself can be used with non-pointer types (although it is redundant).//   _In_ - Annotations for parameters where data is passed into the function, but not modified.// Input parameters --------------------------// readonly for a given call.// _Const_ allows specification that any namable memory location is considered// Reserved pointer parameters, must always be NULL.//   _In_/_Out_ Layer:// Annotations for defensive programming styles.// net deref on a "real" annotation is negative, it is simply discarded.// level of dereference if the parameter is a C++ reference (&).  If the// _Notref_ may precede a _Deref_ or "real" annotation, and removes one// allowed on the function definition.// in scope, and its annotations are to be used. There are no other annotations// Usable on a function defintion. Asserts that a function declaration is// Only applicable with functions that have  _Success_ or _Return_type_succss_.// Establish postconditions that apply in both success and failure cases.// Establish postconditions that apply only if the function does not succeed// the type that this annotation is applied to// <expr> indicates whether post conditions apply to a function returning// <expr> indicates whether normal post conditions apply to a function// apply when 'expr' evaluates to non-zero.// _When_(expr, annos) specifies that the annotations listed in 'annos' only// by the annotations to refer to relevant offsets within target.// element of target up to bound, with the variable named in iter usable// target names a buffer, and each annotation in annos is applied to each// _At_buffer_(target, iter, bound, annos) is similar to _At_, except that// lexical target.// be applied to 'target' rather than to the identifier which is the current// _At_(target, annos) specifies that the annotations listed in 'annos' is to//     applies to) or the condition under which the annotation is applicable.//     express the annotation target (i.e. what parameter/field the annotation//     These annotations modify the use of other annotations.  They may//   Structural SAL:// Some annotations aren't officially SAL2 yet.// Special enum type for Y/N/M// safeguard for MIDL and RC builds// improve compiler throughput.// Disable expansion of SAL macros in non-Prefast mode to// choose attribute or __declspec implementation/*==========================================================================

   The comments in this file are intended to give basic understanding of
   the usage of SAL, the Microsoft Source Code Annotation Language.
   For more details, please see https://go.microsoft.com/fwlink/?LinkID=242134

   The macros are defined in 3 layers, plus the structural set:

   _In_/_Out_/_Ret_ Layer:
   ----------------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. These macros typically start with:
      _In_     : input parameter to a function, unmodified by called function
      _Out_    : output parameter, written to by called function, pointed-to
                 location not expected to be initialized prior to call
      _Outptr_ : like _Out_ when returned variable is a pointer type
                 (so param is pointer-to-pointer type). Called function
                 provides/allocated space.
      _Outref_ : like _Outptr_, except param is reference-to-pointer type.
      _Inout_  : inout parameter, read from and potentially modified by
                 called function.
      _Ret_    : for return values
      _Field_  : class/struct field invariants
   For common usage, this class of SAL provides the most concise annotations.
   Note that _In_/_Out_/_Inout_/_Outptr_ annotations are designed to be used
   with a parameter target. Using them with _At_ to specify non-parameter
   targets may yield unexpected results.

   This layer also includes a number of other properties that can be specified
   to extend the ability of code analysis, most notably:
      -- Designating parameters as format strings for printf/scanf/scanf_s
      -- Requesting stricter type checking for C enum parameters

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_ or _Post_.
   This layer provides the most flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.

   Structural Layer:
   ----------------
   These annotations, like _At_ and _When_, are used with annotations from
   any of the other layers as modifiers, indicating exactly when and where
   the annotations apply.


   Common syntactic conventions:
   ----------------------------

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, are for formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the parameter can be NULL as a precondition to the function, the
   annotation contains _opt. If the macro does not contain '_opt' the
   parameter cannot be NULL.

   If an out/inout parameter returns a null pointer as a postcondition, this is
   indicated by _Ret_maybenull_ or _result_maybenull_. If the macro is not
   of this form, then the result will not be NULL as a postcondition.
     _Outptr_ - output value is not NULL
     _Outptr_result_maybenull_ - output value might be NULL

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   -------------
   Buffer sizes are expressed as element counts, unless the macro explicitly
   contains _byte_ or _bytes_. Some annotations specify two buffer sizes, in
   which case the second is used to indicate how much of the buffer is valid
   as a postcondition. This table outlines the precondition buffer allocation
   size, precondition number of valid elements, postcondition allocation size,
   and postcondition number of valid elements for representative buffer size
   annotations:
                                     Pre    |  Pre    |  Post   |  Post
                                     alloc  |  valid  |  alloc  |  valid
      Annotation                     elems  |  elems  |  elems  |  elems
      ----------                     ------------------------------------
      _In_reads_(s)                    s    |   s     |   s     |   s
      _Inout_updates_(s)               s    |   s     |   s     |   s
      _Inout_updates_to_(s,c)          s    |   s     |   s     |   c
      _Out_writes_(s)                  s    |   0     |   s     |   s
      _Out_writes_to_(s,c)             s    |   0     |   s     |   c
      _Outptr_result_buffer_(s)        ?    |   ?     |   s     |   s
      _Outptr_result_buffer_to_(s,c)   ?    |   ?     |   s     |   c

   For the _Outptr_ annotations, the buffer in question is at one level of
   dereference. The called function is responsible for supplying the buffer.

   Success and failure:
   -------------------
   The SAL concept of success allows functions to define expressions that can
   be tested by the caller, which if it evaluates to non-zero, indicates the
   function succeeded, which means that its postconditions are guaranteed to
   hold.  Otherwise, if the expression evaluates to zero, the function is
   considered to have failed, and the postconditions are not guaranteed.

   The success criteria can be specified with the _Success_(expr) annotation:
     _Success_(return != FALSE) BOOL
     PathCanonicalizeA(_Out_writes_(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
        pszBuf is only guaranteed to be NULL-terminated when TRUE is returned,
        and FALSE indicates failure. In common practice, callers check for zero
        vs. non-zero returns, so it is preferable to express the success
        criteria in terms of zero/non-zero, not checked for exactly TRUE.

   Functions can specify that some postconditions will still hold, even when
   the function fails, using _On_failure_(anno-list), or postconditions that
   hold regardless of success or failure using _Always_(anno-list).

   The annotation _Return_type_success_(expr) may be used with a typedef to
   give a default _Success_ criteria to all functions returning that type.
   This is the case for common Windows API status types, including
   HRESULT and NTSTATUS.  This may be overridden on a per-function basis by
   specifying a _Success_ annotation locally.

============================================================================*//***
*sal.h - markers for documenting the semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       sal.h provides a set of annotations to describe how a function uses its
*       parameters - the assumptions it makes about them, and the guarantees it makes
*       upon finishing.
*
*       [Public]
*
****/<vadefs.h><sal.h>__report_gsfailure__security_check_cookie__security_init_cookie__vcrt_boolintptr_tptrdiff_t__security_cookie__vcrt_free_normal(_Memory)free(_Memory)__vcrt_calloc_normal(_Count,_Size)calloc(_Count, _Size)__vcrt_malloc_normal(_Size)malloc(_Size)_CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)_CRT_INSECURE_DEPRECATE(_Replacement)_CRT_SECURE_NO_WARNINGS_CRT_DEPRECATE_TEXT(_Text)__declspec(deprecated(_Text))_VCRT_EXPORT_STD_MSVC_CONSTEXPRconstexprmsvc_NODISCARD_HAS_NODISCARD_STL_LANG_HAS_CXX26_HAS_CXX23_HAS_CXX20_HAS_CXX170L__crt_countof(_Array)(sizeof(_Array) / sizeof(_Array[0]))_UNALIGNED__unaligned((void *)0)_WCHAR_T_DEFINED_INTPTR_T_DEFINED_PTRDIFF_T_DEFINED_SIZE_T_DEFINED_WConst_return_CONST_RETURN_VCRT_ALIGN(x)__declspec(align(x))_VCRT_JIT_INTRINSIC_VCRT_ALLOCATOR__declspec(allocator)_VCRT_RESTRICT_VCRT_NOALIAS__declspec(noalias)__CLRCALL_PURE_OR_CDECL__CLR_OR_THIS_CALL__CLRCALL_OR_CDECL_MRTIMP_VCRTIMP_CRT_UNPARENTHESIZE(...)_CRT_UNPARENTHESIZE_ __VA_ARGS___CRT_UNPARENTHESIZE_(...)__VA_ARGS___CRT_CONCATENATE(a,b)_CRT_CONCATENATE_(a, b)_CRT_CONCATENATE_(a,b)a ## b_CRT_WIDE(s)_CRT_WIDE_(s)L ## s_CRT_STRINGIZE(x)_CRT_STRINGIZE_(x)#x_HAS_EXCEPTIONS_CRT_END_C_HEADER__pragma(pack(pop))_CRT_BEGIN_C_HEADER__pragma(pack(push, _CRT_PACKING))_CRTIMP_VCRT_DEFINED_CRTIMP_UCRT_VCRT_COMPILER_PREPROCESSOR_VCRUNTIME_Hdefined(RC_INVOKED) || defined(Q_MOC_RUN)defined CRTDLL && defined _CRTBLDdefined __cplusplusdefined __midl_KERNEL_MODEdefined _CRTIMP && !defined _VCRT_DEFINED_CRTIMPdefined _VCRT_BUILD && defined CRTDLL && !defined _VCRT_SAT_1defined MRTDLL && defined _CRTBLD && !defined _M_CEE_PUREdefined _M_CEE_PURE || defined MRTDLLdefined _M_CEE && defined _M_X64__midldefined _M_X64 || defined _M_ARM || defined _M_ARM64defined(_M_IX86) && defined(_CRT_LEGACY_X86_FLT_EXCEPTIONS) && !defined(_M_CEE_PURE)defined(_MSVC_LANG) && _MSVC_LANG > __cplusplus_STL_LANG > 201402L_HAS_CXX17 && _STL_LANG > 201703L_HAS_CXX20 && _STL_LANG > 202002L_HAS_CXX23 && _STL_LANG > 202302L_HAS_CXX20 && !_HAS_CXX17_HAS_CXX23 && !_HAS_CXX20_HAS_CXX26 && !_HAS_CXX23__has_cpp_attribute__has_cpp_attribute(nodiscard) >= 201603Lpush_macro("msvc")push_macro("constexpr")_MSVC_CONSTEXPR_ATTRIBUTEpop_macro("constexpr")pop_macro("msvc")_BUILD_STD_MODULEdefined _CRT_SECURE_NO_DEPRECATE && !defined _CRT_SECURE_NO_WARNINGS_CRT_INSECURE_DEPRECATEdefined _CRT_SECURE_DEPRECATE_MEMORY && !defined _CRT_SECURE_WARNINGS_MEMORY_CRT_INSECURE_DEPRECATE_MEMORY_CRT_SECURE_WARNINGS_MEMORY!defined _M_CEE && !defined __midl_VCRT_BUILD_CRT_SECURE_NO_DEPRECATE// _VCRUNTIME_H// See note on use of "deprecate" at the top of this file// ^^^ !defined(_BUILD_STD_MODULE) ^^^// ^^^ defined(_BUILD_STD_MODULE) / !defined(_BUILD_STD_MODULE) vvv// in Visual C++.// Determine if we should use [[msvc::constexpr]] to allow for "extended constexpr"// _HAS_NODISCARD// ^^^ CAN HAZ [[nodiscard]] / NO CAN HAZ [[nodiscard]] vvv// TRANSITION, VSO#939899 (need toolset update)// [[nodiscard]] attributes on STL functions// _HAS_CXX26// _HAS_CXX23// _HAS_CXX20// _HAS_CXX17// ^^^ no C++ support ^^^// ^^^ determine compiler's C++ mode / no C++ support vvv// ^^^ language mode is larger of _MSVC_LANG and __cplusplus ^^^// ^^^ language mode is _MSVC_LANG / language mode is __cplusplus vvv// Provide a typedef for wchar_t for use under /Zc:wchar_t-// Indicate that these common types are defined// replacement (the differences won't matter in practice).// MIDL understands neither bool nor _Bool.  Use char as a best-fit// Definitions of common types// For backwards compatibility// Definitions of common __declspecs// Definitions of calling conventions used code sometimes compiled as managed/* _HAS_EXCEPTIONS *//* _KERNEL_MODE */// Predefine as 0 to disable exceptions// unit and to push/pop the packing.// an extern "C" declaration when the header is #included in a C++ translation// All C headers have a common prologue and epilogue, to enclose the header in// defined here only for compatibility.// and if we remove its definition, we break that existing code.  It is thus// there is a lot of existing code that declares CRT functions using this macro,// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but// _VCRT_COMPILER_PREPROCESSOR// the Windows resource compiler and Qt's meta-object compiler (moc).// Many VCRuntime headers avoid exposing their contents to non-compilers like// "Security Enhancements in the CRT".// Full details can be found in our documentation by searching for// the standard.// relevant standards.  In fact, these functions are NOT deprecated from// that any standard committee has deprecated these functions from the// about these items. The use of "deprecate" should NOT be taken to imply// We use "deprecate" here ONLY to signal the compiler to emit a warning// __declspec(deprecate) or macros that have the term DEPRECATE in them.// Various places in this header and other headers use// Note on use of "deprecate":// Declarations used throughout the VCRuntime library.// vcruntime.h_StackCookie<vcruntime.h>_invoke_watson_invalid_parameter_noinfo_noreturn_invalid_parameter_noinfo_invalid_parameterrsize_ttime_tmbstate_t_Mbstatet__crt_locale_pointers__crt_multibyte_data__crt_locale_data__crt_locale_data_public__time64_t__time32_twctype_twint_terrno_t__crt_bool_State_Byte_Wchar__crt_multibyte_data *mbcinfo__crt_locale_data *locinfo_locale_lc_codepage_locale_mb_cur_max_locale_pctype__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)_CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)_CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1)__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1)_CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)__DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst)__DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst)_CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst)__DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)__DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)__DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1)__DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst)__DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)_CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)_CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_CC,_FuncName,_VFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)_CRT_INSECURE_DEPRECATE(_FuncName ## _s) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_VFuncName ## _s) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)_CRT_INSECURE_DEPRECATE(_FuncName ## _s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_VFuncName ## _s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_CC,_FuncName,_SecureFuncName,_VFuncName,_SecureVFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1)_CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst)_CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1)_CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4)_CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)_CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)_CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1)_CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_DstType,_Dst)_CRT_INSECURE_DEPRECATE(_FuncName ## _s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst)_CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_CC,_FuncName,_VFuncName,_SecureVFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)_CRT_INSECURE_DEPRECATE(_FuncName ## _s) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_CC,_FuncName,_SecureFuncName,_VFuncName,_SecureVFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst)_CRT_INSECURE_DEPRECATE(_FuncName ## _s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst)__RETURN_POLICY_VOID(_FunctionCall)__RETURN_POLICY_DST(_FunctionCall)__RETURN_POLICY_SAME(_FunctionCall)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName ## _s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName ## _s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, __cdecl, _FuncName, _FuncName ## _s, _VFuncName, _VFuncName ## _s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _SalAttributeDst, _DstType, _DstType, _Dst, _TType1, _TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst)__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _SalAttributeDst, _DstType, _Dst)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName ## _s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName ## _s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_CC,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _VFuncName ## _s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_CC,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _FuncName ## _s, _VFuncName, _VFuncName ## _s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst)__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ## _s, _SalAttributeDst, _DstType, _Dst)__DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(_ReturnType,_FuncName,_DstType,_Src)__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(_ReturnType,_FuncName,_VFuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(_ReturnType,_FuncName,_VFuncName,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(_ReturnType,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_DstType,_Dst)__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(_ReturnType,_FuncName,_HType1,_HArg1,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(_ReturnType,_FuncName,_HType1,_HArg1,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(_ReturnType,_FuncName,_HType1,_HArg1,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4)__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3)__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2)__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1)__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(_ReturnType,_FuncName,_DstType,_Dst)_TIME_T_DEFINED_CRT_SECURE_CPP_NOTHROWthrow()_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_CRT_OBSOLETE(_NewItem)_CRT_DEPRECATE_TEXT( "This function or variable has been superceded by newer library " "or operating system functionality. Consider using " #_NewItem " " "instead. See online help for details.")_SECURECRT_FILL_BUFFER_PATTERN0xFE_CRT_INSECURE_DEPRECATE_GLOBALS(replacement)_CRT_INSECURE_DEPRECATE(replacement)__GOT_SECURE_LIB____STDC_SECURE_LIB__200411L_AGLOBAL_PGLOBAL_CRT_NONSTDC_DEPRECATE(_NewName)_CRT_NONSTDC_NO_WARNINGS_CRT_INTERNAL_NONSTDC_NAMES_CRT_WARNING_MESSAGE(NUMBER,MESSAGE)__FILE__ "(" _CRT_STRINGIZE(__LINE__) "): warning " NUMBER ": " MESSAGE_CRT_SECURE_INVALID_PARAMETER(expr)::_invalid_parameter(_CRT_WIDE(#expr), __FUNCTIONW__, __FILEW__, __LINE__, 0)_CRT_HAS_C11_CRT_HAS_CXX17_CRT_UNUSED(x)(void)x_STATIC_ASSERT(expr)typedef char __static_assert_t[(expr) != 0]__FUNCTIONW___CRT_WIDE(__FUNCTION__)__FILEW___CRT_WIDE(__FILE__)_CRT_SIZE_MAX((size_t)-1)_TRUNCATE_ARGMAX_CRT_NOEXCEPT__crt_typefix(ctype)_Check_return_wat__Check_return_opt__CRT_ALIGN(x)_CRT_INLINE_PURE_SECURITYCRITICAL_ATTRIBUTE_CRT_HYBRIDPATCHABLE_CRT_GUARDOVERFLOW_CRT_JIT_INTRINSIC_CRTALLOCATOR_CRTRESTRICT_DCRTIMP_ACRTIMP_ALT_UCRT_RESTORE_CLANG_WARNINGS_UCRT_DISABLE_CLANG_WARNINGS_UCRT_DISABLED_WARNINGS4324 _UCRT_DISABLED_WARNING_4412 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 _UCRT_EXTRA_DISABLED_WARNINGS_UCRT_EXTRA_DISABLED_WARNINGS_UCRT_DISABLED_WARNING_4412_CRT_BUILD_DESKTOP_APP_ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLEWINAPI_FAMILYWINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_SYSTEM)WINAPI_FAMILY_PHONE_APPWINAPI_FAMILY == WINAPI_FAMILY_PHONE_APPWINAPI_FAMILY_GAMESWINAPI_FAMILY == WINAPI_FAMILY_GAMES_M_ARM_CRT_BUILD_DESKTOP_APP && !_ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE__clang__!defined _CORECRT_BUILD && defined _DLLdefined _CRT_SUPPRESS_RESTRICT || defined _CORECRT_BUILDdefined _MSC_VER && _MSC_VER >= 1900 && !defined _CORECRT_BUILD_GUARDOVERFLOW_CRT_ALLOCATORSdefined _DLL && (defined _M_HYBRID || defined _M_ARM64EC) && (defined _CORECRT_BUILD || defined _VCRT_BUILD)_CRT_ALIGNdefined _PREFAST_ && defined _CA_SHOULD_CHECK_RETURNdefined _PREFAST_ && defined _CA_SHOULD_CHECK_RETURN_WER!defined __midl && !defined MIDL_PASS && defined _PREFAST__STATIC_ASSERT!defined _CRT_FUNCTIONS_REQUIREDdefined __assembler || defined __midl || defined RC_INVOKED!defined _NO_INLINING && !_CRT_FUNCTIONS_REQUIRED_CRT_UNUSED_MSVC_LANG_MSVC_LANG > 201402defined __cplusplus && __cplusplus > 201402defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L_CRT_SECURE_INVALID_PARAMETER( defined _CRT_DECLARE_NONSTDC_NAMES && _CRT_DECLARE_NONSTDC_NAMES) || (!defined _CRT_DECLARE_NONSTDC_NAMES && !__STDC__ )defined _CRT_NONSTDC_NO_DEPRECATE && !defined _CRT_NONSTDC_NO_WARNINGS_CRT_NONSTDC_DEPRECATE_M_CEE__cplusplus_clidefined _M_CEE && !defined _M_CEE_PUREdefined _CRTBLD || defined _CORECRT_BUILD || defined _VCRT_BUILD!_CRT_FUNCTIONS_REQUIRED!__STDC_WANT_SECURE_LIB__ && !defined _CRT_SECURE_NO_WARNINGSRC_INVOKEDdefined _CRT_SECURE_NO_DEPRECATE_GLOBALS && !defined _CRT_SECURE_NO_WARNINGS_GLOBALS_CRT_INSECURE_DEPRECATE_GLOBALS_CRT_SECURE_NO_WARNINGS_GLOBALSdefined _CRT_MANAGED_HEAP_NO_DEPRECATE && !defined _CRT_MANAGED_HEAP_NO_WARNINGSdefined _CRT_OBSOLETE_NO_DEPRECATE && !defined _CRT_OBSOLETE_NO_WARNINGS_CRT_OBSOLETE_CRT_OBSOLETE_NO_WARNINGS!__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES!__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT!__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES!__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY!__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORYdefined _USE_32BIT_TIME_T && defined _WIN64defined _VCRT_BUILD || defined _CORECRT_BUILD_CRT_NO_TIME_T_USE_32BIT_TIME_Tdefined __cplusplus && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMESdefined __cplusplus && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_Field_range_(1,2)_Field_range_impl_(1,2)"_Field_range_"_CRT_NONSTDC_NO_DEPRECATE// !_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES// !_CRT_FUNCTIONS_REQUIRED// ^^^ _CRT_FUNCTIONS_REQUIRED ^^^ // vvv !_CRT_FUNCTIONS_REQUIRED vvv //// ^^^ _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES ^^^ // vvv !_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES vvv //// !_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT// ^^^ _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT ^^^ // vvv _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT vvv //// C++ Standard Overload Generation Macros// !_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES// ^^^ _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES ^^^ // vvv !_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES vvv //// C++ Secure Overload Generation Macros// state of a multibyte translation// Basic Types// _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES is set to 0// _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT is ignored if// overloads (MIDL and RC do not need the C++ overloads).// If we don't require function declarations at all, we need not define the// Disable C++ overloads internally:// SecureCRT Configuration// Managed CRT Support// Deprecation and Warnings// and the SafeInt library.// _CRT_SECURE_INVALID_PARAMETER is used in the Standard C++ Libraries// _CRT_SECURE_INVALID_PARAMETER if you need.// and invoke Watson. You can overwrite the definition of// _invalid_parameter_noinfo_noreturn() will terminate the application// parameter handler which does return control to the application,// Even if _set_invalid_parameter_handler() is used to set a new invalid// __declspec(noreturn) and does not return control to the application.// _invalid_parameter_noinfo_noreturn(), which is marked// By default, _CRT_SECURE_INVALID_PARAMETER in retail invokes// Invalid Parameter Handler/* _CRT_HAS_C11 *//* defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L *//* _CRT_HAS_CXX17 *//* _MSVC_LANG *//* __cplusplus > 201402 *//* _MSVC_LANG > 201402 */// Suppress <tchar.h> inlines// that are not compilable with the aforementioned tools.// file that does not.  This allows us to suppress declarations and definitions// be declared (and defined, where applicable), and to 0 when we are compiling a// is defined to 1 when we are compiling a file that actually needs functions to// limited ability to process C and C++ code.  The _CRT_FUNCTIONS_REQUIRED macro// files, and resource files.  The tools that process these files often have a// inline function definitions are not.  These files include assembly files, IDL// definitions and macro definitions are required but function declarations and// CRT headers are included into some kinds of source files where only data type// Miscellaneous Stuff// This is clr:pure-only because for mixed mode we compile inline functions as native.// _CRT_INLINE_PURE_SECURITYCRITICAL_ATTRIBUTE is for inline pure functions defined in the header.// _CRT_SECURITYCRITICAL_ATTRIBUTE covers this for internal function definitions.// to be marked as SecurityCritical.// The CLR requires code calling other SecurityCritical code or using SecurityCritical types// __declspec(guard(overflow)) enabled by /sdl compiler switch for CRT allocators// targeting the 64-bit runtime.// This is only needed when managed code is calling the native APIs,// declare the API using _ACRTIMP_ALT instead of _ACRTIMP.// If you need the ability to remove __declspec(import) from an API, to support static replacement,// Annotation Macros// _UCRT_RESTORE_CLANG_WARNINGS// __clang__// _UCRT_DISABLE_CLANG_WARNINGS// warning: unknown pragma ignored [-Wunknown-pragmas]// warning: '#pragma optimize' is not supported [-Wignored-pragma-optimize]// warning: __declspec attribute 'allocator' is not supported [-Wignored-attributes]// warning: declspec(deprecated) [-Wdeprecated-declarations]// C28727: Banned API.// C28726: Banned or deprecated API, use a more robust and secure replacement.// C28719: Banned API, use a more robust and secure replacement.// C4996: __declspec(deprecated)// C4995: name was marked #pragma deprecated// C4820: padding after data member (/Wall)// C4793: 'function' is compiled as native code (/Wall and /W1 under /clr:pure)// C4710: function not inlined (/Wall)// C4668: '__cplusplus' is not defined as a preprocessor macro (/Wall)// C4574: 'MACRO' is defined to be '0': did you mean to use '#if MACRO'? (/Wall)// C4324: structure was padded due to __declspec(align()) (/W4)// Use _UCRT_EXTRA_DISABLED_WARNINGS to add additional warning suppressions to UCRT headers.// C4412: function signature contains type '_locale_t';// Warning Suppression// Verify that the ARM Desktop SDK is available when building an ARM Desktop app// Windows API Partitioning and ARM Desktop Support// Declarations used throughout the CoreCRT library.// corecrt.h_Expression_FunctionName_LineNo_Reserved__local_stdio_scanf_options_OptionsStorage__local_stdio_printf_options_CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY(1ULL << 2)_CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS(1ULL << 1)(1ULL << 0)_CRT_INTERNAL_PRINTF_STANDARD_ROUNDING(1ULL << 5)_CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS(1ULL << 4)_CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY(1ULL << 3)_CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS_CRT_INTERNAL_LOCAL_SCANF_OPTIONS(*__local_stdio_scanf_options ())_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS(*__local_stdio_printf_options())_CRT_INTERNAL_STDIO_SYMBOL_PREFIX!defined _NO_CRT_STDIO_INLINE && !_CRT_FUNCTIONS_REQUIRED!defined _CRT_STDIO_INLINE!defined RC_INVOKEDdefined _M_IX86defined _CRT_STDIO_ISO_WIDE_SPECIFIERSdefined _CRT_STDIO_LEGACY_WIDE_SPECIFIERS!defined _M_CEE_PUREdefined __cplusplus && !defined _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS_CRT_STDIO_ISO_WIDE_SPECIFIERS_Ret1_impl_(__notnull_impl)"_Ret_notnull_"__notnull_impl// static local variable has different names in C and in C++ translation units.// This function must not be inlined into callers to avoid ODR violations.  The// function-local static variables.// compiled as native to ensure that there is only one instance of each of the// If we're compiling mixed managed code, make sure these inline functions are// _CRT_STDIO_LEGACY_WIDE_SPECIFIERS et al. are too long for rc// is intended for use by static libraries).// used with either the legacy (default) or the conforming mode.  (This option// not use these format specifiers without a length modifier and thus can be// Predefine _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS when building code that does// the wide string printf and scanf functions (%s, %c, and %[] specifiers).// Predefine _CRT_STDIO_LEGACY_WIDE_SPECIFIERS to use VC++ 2013 and earlier behavior for// Predefine _CRT_STDIO_ISO_WIDE_SPECIFIERS to use ISO-conforming behavior for// RC has no target architecture// Per-module <stdio.h> configuration.// corecrt_stdio_config.h__threadhandle__threadid_get_errno_set_errno_errno_threadid(__threadid())offsetof(s,m)((size_t)&(((s*)0)->m))errno(*_errno())_INC_STDDEFdefined _MSC_VER && !defined _CRT_USE_BUILTIN_OFFSETOF// _INC_STDDEF// The C <stddef.h> Standard Library header.// stddef.hRSIZE_MAX(SIZE_MAX >> 1)SIZE_MAX0xffffffffffffffffui64_UI64_MAX_I64_MAX9223372036854775807i64_I64_MIN(-9223372036854775807i64 - 1)_UI32_MAX0xffffffffui32_I32_MAX2147483647i32_I32_MIN(-2147483647i32 - 1)_UI16_MAX0xffffui16_I16_MAX32767i16_I16_MIN(-32767i16 - 1)_UI8_MAX0xffui8_I8_MAX127i8_I8_MIN(-127i8 - 1)ULLONG_MAXLLONG_MINLLONG_MAXULONG_MAX0xffffffffULLONG_MAX2147483647LLONG_MIN(-2147483647L - 1)UINT_MAXINT_MAXINT_MIN(-2147483647 - 1)USHRT_MAXSHRT_MAX32767SHRT_MIN(-32768)MB_LEN_MAXCHAR_MAXSCHAR_MAXCHAR_MINSCHAR_MINUCHAR_MAX(-128)CHAR_BIT_INC_LIMITS_CHAR_UNSIGNED// SIZE_MAX definition must match exactly with stdint.h for modules support.// The C Standard Library <limits.h> header.// limits.hoff_t_off_tdev_t_dev_tino_t_ino_t_OFF_T_DEFINED_DEV_T_DEFINED_INO_T_DEFINED(defined _CRT_DECLARE_NONSTDC_NAMES && _CRT_DECLARE_NONSTDC_NAMES) || (!defined _CRT_DECLARE_NONSTDC_NAMES && !__STDC__)// file offset value// device code// inode number (unused on Windows)// Types used for returning file status and time information.// sys/types.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/ucrt/sys<sys/types.h><limits.h>z_crc_tvoidpvoidpfvoidpcuLongfuIntfintfcharfBytefuLonguIntBytez_size_tz_off64_t__int64z_off_tZ_U4unsignedFARZEXPORTVAZEXPORTZEXTERNextern __declspec(dllimport)OF(args)argsMAX_WBITSMAX_MEM_LEVELz_longlongz_constSTDCWINDOWSZCONF_HZ_PREFIXZ_SOLOdefined(__MSDOS__) && !defined(MSDOS)(defined(OS_2) || defined(__OS2__)) && !defined(OS2)defined(_WINDOWS) && !defined(WINDOWS)defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)WIN32(defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)!defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)SYS16BITMSDOS__STDC_VERSION__ >= 199901LSTDC99!defined(STDC) && (defined(__STDC__) || defined(__cplusplus))!defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))!defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))!defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))defined(__OS400__) && !defined(STDC)defined(ZLIB_CONST) && !defined(z_const)defined(NO_SIZE_T)defined(STDC)MAXSEG_64KOFdefined(M_I86SM) || defined(M_I86MM)(defined(__SMALL__) || defined(__MEDIUM__))__BORLANDC__defined(WINDOWS) || defined(WIN32)defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))ZLIB_INTERNALZLIB_WINAPIWIN32_LEAN_AND_MEANdefined (__BEOS__)!defined(__MACTYPES__)SMALL_MEDIUM!defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)(UINT_MAX == 0xffffffffUL)(ULONG_MAX == 0xffffffffUL)(USHRT_MAX == 0xffffffffUL)HAVE_UNISTD_H~(~HAVE_UNISTD_H + 0) == 0 && ~(~HAVE_UNISTD_H + 1) == 1HAVE_UNISTD_H != 0HAVE_STDARG_H~(~HAVE_STDARG_H + 0) == 0 && ~(~HAVE_STDARG_H + 1) == 1HAVE_STDARG_H != 0defined(STDC) || defined(Z_HAVE_STDARG_H)defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1Z_HAVE_UNISTD_H__WATCOMC__defined(_LARGEFILE64_SOURCE) && !defined(_WIN32)defined(Z_HAVE_UNISTD_H)VMSdefined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)!defined(SEEK_SET) && !defined(Z_SOLO)!defined(_WIN32) && defined(Z_LARGE64)defined(_WIN32) && !defined(__GNUC__)defined(__MVS__)_WINDOWS/* ZCONF_H *//* MVS linker does not support external names larger than 8 bytes *//* Set file pointer to EOF plus "offset" *//* Seek from current position.  *//* Seek from beginning of file.  *//* for off_t *//* for SEEK_*, off_t, and _LFS64_LARGEFILE *//* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
 * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
 * though the former does not conform to the LFS document), but considering
 * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
 * equivalently requesting no 64-bit operations
 *//* for wchar_t *//* for va_list *//* may be set to #if 1 by ./configure *//* Borland C/C++ and some old MSC versions ignore FAR inside typedef *//* 32 bits or more *//* 16 bits or more *//* 8 bits *//* For complete Windows compatibility, use WINAPI, not __stdcall. *//* No need for _export, use ZLIB.DEF instead. *//* If building or using zlib with the WINAPI/WINAPIV calling convention,
    * define ZLIB_WINAPI.
    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
    *//* ZLIB_DLL *//* If building or using zlib as a DLL, define ZLIB_DLL.
    * This is not mandatory, but it offers a little performance increase.
    *//* Turbo C small or medium model *//* MSC small or medium model *//* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 *//* function prototypes *//* Type declarations *//* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
 for small objects.
*//* 32K LZ77 window *//* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 *//* Maximum value for memLevel in deflateInit2 *//* note: need a more gentle solution here *//* cannot use !defined(STDC) && !defined(const) on Mac *//* iSeries (formerly AS/400). *//*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 *//* all zlib structs in zlib.h and zconf.h *//* all zlib typedefs in zlib.h and zconf.h *//* all linked symbols and init macros *//*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 * Even better than compiling with -DZ_PREFIX would be to use configure to set
 * this permanently in zconf.h using "./configure --zprefix".
 *//* #undef Z_HAVE_UNISTD_H *//* #undef Z_PREFIX *//* @(#) $Id$ *//* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */D:/Applications/VCPKG/vcpkg/installed/x64-windows/includeD:/Applications/VCPKG/vcpkg/installed/x64-windowsD:/Applications/VCPKG/vcpkg/installedD:/Applications/VCPKG/vcpkgD:/Applications/VCPKGD:/Applications"zconf.h"gzvprintfgzopen_wdeflateResetKeepinflateResetKeepinflateCodesUsedinflateValidateinflateUndermineconst z_crc_tconst z_crc_t *get_crc_tableinflateSyncPointzErrorcrc32_combine_gencrc32_combineadler32_combinegzoffsetgztellgzseekgzopengzgetc_inflateBackInit_inflateInit2_deflateInit2_inflateInit_deflateInit_crc32_combine_opcrc32_zcrc32adler32_zadler32gzclearerrgzerrorgzclose_wgzclose_rgzclosegzdirectgzeofgzrewindgzflushgzungetcgzgetcgzputcgzgetsgzputsgzprintfgzfwritegzwritegzfreadgzreadgzsetparamsgzbuffergzdopenuncompress2Bytef *uLongf *unsigned long *uLong *uncompresscompressBoundcompress2compresszlibCompileFlagsinflateBackEndinflateBackinflateGetHeaderinflateMarkinflatePrimeinflateReset2inflateResetinflateCopyinflateSyncinflateGetDictionaryuInt *inflateSetDictionarydeflateSetHeaderdeflatePrimedeflatePendingdeflateBounddeflateTunedeflateParamsdeflateResetdeflateCopydeflateGetDictionarydeflateSetDictionaryinflateEndinflatedeflateEnddeflatezlibVersiongzFile_s *gzFilegzFile_sout_funcin_funcgz_header *gz_header_s *gz_headerpgz_headergz_header_sz_stream *z_stream_s *z_streampz_streamz_stream_sinternal_statefree_funcalloc_funchavedonehcrccomm_maxname_maxextra_maxextra_lenextraosxflagstimereservedadlerdata_typezfreezallocinternal_state *total_outavail_outnext_outtotal_inavail_innext_ingzgetc(g)((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))inflateBackInit(strm,windowBits,window)inflateBackInit_((strm), (windowBits), (window), ZLIB_VERSION, (int)sizeof(z_stream))inflateInit2(strm,windowBits)inflateInit2_((strm), (windowBits), ZLIB_VERSION, (int)sizeof(z_stream))deflateInit2(strm,level,method,windowBits,memLevel,strategy)deflateInit2_((strm),(level),(method),(windowBits),(memLevel), (strategy), ZLIB_VERSION, (int)sizeof(z_stream))inflateInit(strm)inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))deflateInit(strm,level)deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))zlib_versionzlibVersion()Z_NULLZ_DEFLATEDZ_UNKNOWNZ_ASCIIZ_TEXTZ_BINARYZ_DEFAULT_STRATEGYZ_FIXEDZ_RLEZ_HUFFMAN_ONLYZ_FILTEREDZ_DEFAULT_COMPRESSIONZ_BEST_COMPRESSIONZ_BEST_SPEEDZ_NO_COMPRESSIONZ_VERSION_ERROR(-6)Z_BUF_ERROR(-5)Z_MEM_ERROR(-4)Z_DATA_ERROR(-3)Z_STREAM_ERROR(-2)Z_ERRNOZ_NEED_DICTZ_STREAM_ENDZ_OKZ_TREESZ_BLOCKZ_FINISHZ_FULL_FLUSHZ_SYNC_FLUSHZ_PARTIAL_FLUSHZ_NO_FLUSHZLIB_VER_SUBREVISIONZLIB_VER_REVISIONZLIB_VER_MINORZLIB_VER_MAJORZLIB_VERNUM0x1310ZLIB_VERSION"1.3.1"ZLIB_HZ_PREFIX_SETZ_LARGE64!defined(ZLIB_INTERNAL) && defined(Z_WANT64)defined(_WIN32) && !defined(Z_SOLO)/* ZLIB_H *//* undocumented functions *//* !Z_SOLO *//* Z_SOLO *//* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
 * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
 * both are true, the application gets the *64 functions, and the regular
 * functions are changed to 64 bits) -- in case these are set on systems
 * without large file support, _LFS64_LARGEFILE must also be true
 *//* backward compatibility *//* gzgetc() macro and its supporting function and exposed data structure.  Note
 * that the real internal state is much larger than the exposed structure.
 * This abbreviated structure exposes just enough for the gzgetc() macro.  The
 * user should not mess with these exposed elements, since their names or
 * behavior could change in the future, perhaps even capriciously.  They can
 * only be used by the gzgetc() macro.  You have been warned.
 *//* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 *//* various hacks, don't look :) *//*
     Give the same result as crc32_combine(), using op in place of len2. op is
   is generated from len2 by crc32_combine_gen(). This will be faster than
   crc32_combine() if the generated op is used more than once.
*//*
ZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t len2);

     Return the operator corresponding to length len2, to be used with
   crc32_combine_op(). len2 must be non-negative.
*//*
ZEXTERN uLong ZEXPORT crc32_combine(uLong crc1, uLong crc2, z_off_t len2);

     Combine two CRC-32 check values into one.  For two sequences of bytes,
   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
   len2. len2 must be non-negative.
*//*
     Same as crc32(), but with a size_t length.
*//*
     Update a running CRC-32 with the bytes buf[0..len-1] and return the
   updated CRC-32. A CRC-32 value is in the range of a 32-bit unsigned integer.
   If buf is Z_NULL, this function returns the required initial value for the
   crc. Pre- and post-conditioning (one's complement) is performed within this
   function so it shouldn't be done by the application.

   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*//*
ZEXTERN uLong ZEXPORT adler32_combine(uLong adler1, uLong adler2,
                                      z_off_t len2);

     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
   that the z_off_t type (like off_t) is a signed integer.  If len2 is
   negative, the result has no meaning or utility.
*//*
     Same as adler32(), but with a size_t length.
*//*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. An Adler-32 value is in the range of a 32-bit
   unsigned integer. If buf is Z_NULL, this function returns the required
   initial value for the checksum.

     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed
   much faster.

   Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*//*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the compression
   library.
*//* checksum functions *//*
     Clear the error and end-of-file flags for file.  This is analogous to the
   clearerr() function in stdio.  This is useful for continuing to read a gzip
   file that is being written concurrently.
*//*
     Return the error message for the last error which occurred on file.
   errnum is set to zlib error number.  If an error occurred in the file system
   and not in the compression library, errnum is set to Z_ERRNO and the
   application may consult errno to get the exact error code.

     The application must not modify the returned string.  Future calls to
   this function may invalidate the previously returned string.  If file is
   closed, then the string previously returned by gzerror will no longer be
   available.

     gzerror() should be used to distinguish errors from end-of-file for those
   functions above that do not distinguish those cases in their return values.
*//*
     Same as gzclose(), but gzclose_r() is only for use when reading, and
   gzclose_w() is only for use when writing or appending.  The advantage to
   using these instead of gzclose() is that they avoid linking in zlib
   compression or decompression code that is not used when only reading or only
   writing respectively.  If gzclose() is used, then both compression and
   decompression code will be included the application when linking to a static
   zlib library.
*//*
     Flush all pending output for file, if necessary, close file and
   deallocate the (de)compression state.  Note that once file is closed, you
   cannot call gzerror with file, since its structures have been deallocated.
   gzclose must not be called more than once on the same file, just as free
   must not be called more than once on the same allocation.

     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
   last read ended in the middle of a gzip stream, or Z_OK on success.
*//*
     Return true (1) if file is being copied directly while reading, or false
   (0) if file is a gzip stream being decompressed.

     If the input file is empty, gzdirect() will return true, since the input
   does not contain a gzip stream.

     If gzdirect() is used immediately after gzopen() or gzdopen() it will
   cause buffers to be allocated to allow reading the file to determine if it
   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
   gzdirect().

     When writing, gzdirect() returns true (1) if transparent writing was
   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
   gzdirect() is not needed when writing.  Transparent writing must be
   explicitly requested, so the application already knows the answer.  When
   linking statically, using gzdirect() will include all of the zlib code for
   gzip file reading and decompression, which may not be desired.)
*//*
     Return true (1) if the end-of-file indicator for file has been set while
   reading, false (0) otherwise.  Note that the end-of-file indicator is set
   only if the read tried to go past the end of the input, but came up short.
   Therefore, just like feof(), gzeof() may return false even if there is no
   more data to read, in the event that the last read request was for the exact
   number of bytes remaining in the input file.  This will happen if the input
   file size is an exact multiple of the buffer size.

     If gzeof() returns true, then the read functions will return no more data,
   unless the end-of-file indicator is reset by gzclearerr() and the input file
   has grown since the previous end of file was detected.
*//*
ZEXTERN z_off_t ZEXPORT gzoffset(gzFile file);

     Return the current compressed (actual) read or write offset of file.  This
   offset includes the count of bytes that precede the gzip stream, for example
   when appending or when using gzdopen() for reading.  When reading, the
   offset does not include as yet unused buffered input.  This information can
   be used for a progress indicator.  On error, gzoffset() returns -1.
*//*
ZEXTERN z_off_t ZEXPORT    gztell(gzFile file);

     Return the starting position for the next gzread or gzwrite on file.
   This position represents a number of bytes in the uncompressed data stream,
   and is zero when starting, even if appending or reading a gzip stream from
   the middle of a file using gzdopen().

     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*//*
     Rewind file. This function is supported only for reading.

     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET).
*//*
ZEXTERN z_off_t ZEXPORT gzseek(gzFile file,
                               z_off_t offset, int whence);

     Set the starting position to offset relative to whence for the next gzread
   or gzwrite on file.  The offset represents a number of bytes in the
   uncompressed data stream.  The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.

     If the file is opened for reading, this function is emulated but can be
   extremely slow.  If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

     gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*//*
     Flush all pending output to file.  The parameter flush is as in the
   deflate() function.  The return value is the zlib error number (see function
   gzerror below).  gzflush is only permitted when writing.

     If the flush parameter is Z_FINISH, the remaining data is written and the
   gzip stream is completed in the output.  If gzwrite() is called again, a new
   gzip stream will be started in the output.  gzread() is able to read such
   concatenated gzip streams.

     gzflush should be called only when strictly necessary because it will
   degrade compression if called too often.
*//*
     Push c back onto the stream for file to be read as the first character on
   the next read.  At least one character of push-back is always allowed.
   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
   fail if c is -1, and may fail if a character has been pushed but not read
   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
   The pushed character will be discarded if the stream is repositioned with
   gzseek() or gzrewind().
*//*
     Read and decompress one byte from file.  gzgetc returns this byte or -1
   in case of end of file or error.  This is implemented as a macro for speed.
   As such, it does not do all of the checking the other functions do.  I.e.
   it does not check to see if file is NULL, nor whether the structure file
   points to has been clobbered or not.
*//*
     Compress and write c, converted to an unsigned char, into file.  gzputc
   returns the value that was written, or -1 in case of error.
*//*
     Read and decompress bytes from file into buf, until len-1 characters are
   read, or until a newline character is read and transferred to buf, or an
   end-of-file condition is encountered.  If any characters are read or if len
   is one, the string is terminated with a null character.  If no characters
   are read due to an end-of-file or len is less than one, then the buffer is
   left untouched.

     gzgets returns buf which is a null-terminated string, or it returns NULL
   for end-of-file or in case of error.  If there was an error, the contents at
   buf are indeterminate.
*//*
     Compress and write the given null-terminated string s to file, excluding
   the terminating null character.

     gzputs returns the number of characters written, or -1 in case of error.
*//*
     Convert, format, compress, and write the arguments (...) to file under
   control of the string format, as in fprintf.  gzprintf returns the number of
   uncompressed bytes actually written, or a negative zlib error code in case
   of error.  The number of uncompressed bytes written is limited to 8191, or
   one less than the buffer size given to gzbuffer().  The caller should assure
   that this limit is not exceeded.  If it is exceeded, then gzprintf() will
   return an error (0) with nothing written.  In this case, there may also be a
   buffer overflow with unpredictable consequences, which is possible only if
   zlib was compiled with the insecure functions sprintf() or vsprintf(),
   because the secure snprintf() or vsnprintf() functions were not available.
   This can be determined using zlibCompileFlags().
*//*
     Compress and write nitems items of size size from buf to file, duplicating
   the interface of stdio's fwrite(), with size_t request and return types.  If
   the library defines size_t, then z_size_t is identical to size_t.  If not,
   then z_size_t is an unsigned integer type that can contain a pointer.

     gzfwrite() returns the number of full items written of size size, or zero
   if there was an error.  If the multiplication of size and nitems overflows,
   i.e. the product does not fit in a z_size_t, then nothing is written, zero
   is returned, and the error state is set to Z_STREAM_ERROR.
*//*
     Compress and write the len uncompressed bytes at buf to file. gzwrite
   returns the number of uncompressed bytes written or 0 in case of error.
*//*
     Read and decompress up to nitems items of size size from file into buf,
   otherwise operating as gzread() does.  This duplicates the interface of
   stdio's fread(), with size_t request and return types.  If the library
   defines size_t, then z_size_t is identical to size_t.  If not, then z_size_t
   is an unsigned integer type that can contain a pointer.

     gzfread() returns the number of full items read of size size, or zero if
   the end of the file was reached and a full item could not be read, or if
   there was an error.  gzerror() must be consulted if zero is returned in
   order to determine if there was an error.  If the multiplication of size and
   nitems overflows, i.e. the product does not fit in a z_size_t, then nothing
   is read, zero is returned, and the error state is set to Z_STREAM_ERROR.

     In the event that the end of file is reached and only a partial item is
   available at the end, i.e. the remaining uncompressed data length is not a
   multiple of size, then the final partial item is nevertheless read into buf
   and the end-of-file flag is set.  The length of the partial item read is not
   provided, but could be inferred from the result of gztell().  This behavior
   is the same as the behavior of fread() implementations in common libraries,
   but it prevents the direct use of gzfread() to read a concurrently written
   file, resetting and retrying on end-of-file, when size is not 1.
*//*
     Read and decompress up to len uncompressed bytes from file into buf.  If
   the input file is not in gzip format, gzread copies the given number of
   bytes into the buffer directly from the file.

     After reaching the end of a gzip stream in the input, gzread will continue
   to read, looking for another gzip stream.  Any number of gzip streams may be
   concatenated in the input file, and will all be decompressed by gzread().
   If something other than a gzip stream is encountered after a gzip stream,
   that remaining trailing garbage is ignored (and no error is returned).

     gzread can be used to read a gzip file that is being concurrently written.
   Upon reaching the end of the input, gzread will return with the available
   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
   gzclearerr can be used to clear the end of file indicator in order to permit
   gzread to be tried again.  Z_OK indicates that a gzip stream was completed
   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
   middle of a gzip stream.  Note that gzread does not return -1 in the event
   of an incomplete gzip stream.  This error is deferred until gzclose(), which
   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
   stream.  Alternatively, gzerror can be used before gzclose to detect this
   case.

     gzread returns the number of uncompressed bytes actually read, less than
   len for end of file, or -1 for error.  If len is too large to fit in an int,
   then nothing is read, -1 is returned, and the error state is set to
   Z_STREAM_ERROR.
*//*
     Dynamically update the compression level and strategy for file.  See the
   description of deflateInit2 for the meaning of these parameters. Previously
   provided data is flushed before applying the parameter changes.

     gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not
   opened for writing, Z_ERRNO if there is an error writing the flushed data,
   or Z_MEM_ERROR if there is a memory allocation error.
*//*
     Set the internal buffer size used by this library's functions for file to
   size.  The default buffer size is 8192 bytes.  This function must be called
   after gzopen() or gzdopen(), and before any other calls that read or write
   the file.  The buffer memory allocation is always deferred to the first read
   or write.  Three times that size in buffer space is allocated.  A larger
   buffer size of, for example, 64K or 128K bytes will noticeably increase the
   speed of decompression (reading).

     The new buffer size also affects the maximum length for gzprintf().

     gzbuffer() returns 0 on success, or -1 on failure, such as being called
   too late.
*//*
     Associate a gzFile with the file descriptor fd.  File descriptors are
   obtained from calls like open, dup, creat, pipe or fileno (if the file has
   been previously opened with fopen).  The mode parameter is as in gzopen.

     The next call of gzclose on the returned gzFile will also close the file
   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
   mode);.  The duplicated descriptor should be saved to avoid a leak, since
   gzdopen does not close fd if it fails.  If you are using fileno() to get the
   file descriptor from a FILE *, then you will have to use dup() to avoid
   double-close()ing the file descriptor.  Both gzclose() and fclose() will
   close the associated file descriptor, so they need to have different file
   descriptors.

     gzdopen returns NULL if there was insufficient memory to allocate the
   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
   used until the next gz* read, write, seek, or close operation, so gzdopen
   will not detect if fd is invalid (unless fd is -1).
*//*
ZEXTERN gzFile ZEXPORT gzopen(const char *path, const char *mode);

     Open the gzip (.gz) file at path for reading and decompressing, or
   compressing and writing.  The mode parameter is as in fopen ("rb" or "wb")
   but can also include a compression level ("wb9") or a strategy: 'f' for
   filtered data as in "wb6f", 'h' for Huffman-only compression as in "wb1h",
   'R' for run-length encoding as in "wb1R", or 'F' for fixed code compression
   as in "wb9F".  (See the description of deflateInit2 for more information
   about the strategy parameter.)  'T' will request transparent writing or
   appending with no compression and not using the gzip format.

     "a" can be used instead of "w" to request that the gzip stream that will
   be written be appended to the file.  "+" will result in an error, since
   reading and writing to the same gzip file is not supported.  The addition of
   "x" when writing will create the file exclusively, which fails if the file
   already exists.  On systems that support it, the addition of "e" when
   reading or writing will set the flag to close the file on an execve() call.

     These functions, as well as gzip, will read and decode a sequence of gzip
   streams in a file.  The append function of gzopen() can be used to create
   such a file.  (Also see gzflush() for another way to do this.)  When
   appending, gzopen does not test whether the file begins with a gzip stream,
   nor does it look for the end of the gzip streams to begin appending.  gzopen
   will simply append a gzip stream to the existing file.

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.  When
   reading, this will be detected automatically by looking for the magic two-
   byte gzip header.

     gzopen returns NULL if the file could not be opened, if there was
   insufficient memory to allocate the gzFile state, or if an invalid mode was
   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
   errno can be checked to determine if the reason gzopen failed was that the
   file could not be opened.
*//* semi-opaque gzip file descriptor *//*
     This library supports reading and writing files in gzip (.gz) format with
   an interface similar to that of stdio, using the functions that start with
   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
   wrapper, documented in RFC 1952, wrapped around a deflate stream.
*//* gzip file access functions *//*
     Same as uncompress, except that sourceLen is a pointer, where the
   length of the source is *sourceLen.  On return, *sourceLen is the number of
   source bytes consumed.
*//*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer.  Upon entry, destLen is the total size
   of the destination buffer, which must be large enough to hold the entire
   uncompressed data.  (The size of the uncompressed data must have been saved
   previously by the compressor and transmitted to the decompressor by some
   mechanism outside the scope of this compression library.) Upon exit, destLen
   is the actual size of the uncompressed data.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
   the case where there is not enough room, uncompress() will fill the output
   buffer with the uncompressed data up to that point.
*//*
     compressBound() returns an upper bound on the compressed size after
   compress() or compress2() on sourceLen bytes.  It would be used before a
   compress() or compress2() call to allocate the destination buffer.
*//*
     Compresses the source buffer into the destination buffer.  The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer.  Upon entry, destLen is the total size of the
   destination buffer, which must be at least the value returned by
   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
   compressed data.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*//*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer.  Upon entry, destLen is the total size
   of the destination buffer, which must be at least the value returned by
   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
   compressed data.  compress() is equivalent to compress2() with a level
   parameter of Z_DEFAULT_COMPRESSION.

     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*//*
     The following utility functions are implemented on top of the basic
   stream-oriented functions.  To simplify the interface, some default options
   are assumed (compression level and memory usage, standard memory allocation
   functions).  The source code of these utility functions can be modified if
   you need special options.
*//* utility functions *//* Return flags indicating compile-time options.

    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
     1.0: size of uInt
     3.2: size of uLong
     5.4: size of voidpf (pointer)
     7.6: size of z_off_t

    Compiler, assembler, and debug options:
     8: ZLIB_DEBUG
     9: ASMV or ASMINF -- use ASM code
     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
     11: 0 (reserved)

    One-time table building (smaller code, but not thread-safe if true):
     12: BUILDFIXED -- build static block decoding tables when needed
     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
     14,15: 0 (reserved)

    Library content (indicates missing functionality):
     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
                          deflate code when not needed)
     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
                    and decode gzip streams (to avoid linking crc code)
     18-19: 0 (reserved)

    Operation variations (changes in library functionality):
     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
     21: FASTEST -- deflate algorithm with only one, lowest compression level
     22,23: 0 (reserved)

    The sprintf variant used by gzprintf (zero is best):
     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
     26: 0 = returns value, 1 = void -- 1 means inferred string length returned

    Remainder:
     27-31: 0 (reserved)
 *//*
     All memory allocated by inflateBackInit() is freed.

     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
   state was inconsistent.
*//*
     inflateBack() does a raw inflate with a single call using a call-back
   interface for input and output.  This is potentially more efficient than
   inflate() for file i/o applications, in that it avoids copying between the
   output and the sliding window by simply making the window itself the output
   buffer.  inflate() can be faster on modern CPUs when used with large
   buffers.  inflateBack() trusts the application to not change the output
   buffer passed by the output function, at least until inflateBack() returns.

     inflateBackInit() must be called first to allocate the internal state
   and to initialize the state with the user-provided window buffer.
   inflateBack() may then be used multiple times to inflate a complete, raw
   deflate stream with each call.  inflateBackEnd() is then called to free the
   allocated state.

     A raw deflate stream is one with no zlib or gzip header or trailer.
   This routine would normally be used in a utility that reads zip or gzip
   files and writes out uncompressed files.  The utility would decode the
   header and process the trailer on its own, hence this routine expects only
   the raw deflate stream to decompress.  This is different from the default
   behavior of inflate(), which expects a zlib header and trailer around the
   deflate stream.

     inflateBack() uses two subroutines supplied by the caller that are then
   called by inflateBack() for input and output.  inflateBack() calls those
   routines until it reads a complete deflate stream and writes out all of the
   uncompressed data, or until it encounters an error.  The function's
   parameters and return types are defined above in the in_func and out_func
   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
   number of bytes of provided input, and a pointer to that input in buf.  If
   there is no input available, in() must return zero -- buf is ignored in that
   case -- and inflateBack() will return a buffer error.  inflateBack() will
   call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].
   out() should return zero on success, or non-zero on failure.  If out()
   returns non-zero, inflateBack() will return with an error.  Neither in() nor
   out() are permitted to change the contents of the window provided to
   inflateBackInit(), which is also the buffer that out() uses to write from.
   The length written by out() will be at most the window size.  Any non-zero
   amount of input may be provided by in().

     For convenience, inflateBack() can be provided input on the first call by
   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
   in() will be called.  Therefore strm->next_in must be initialized before
   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
   must also be initialized, and then if strm->avail_in is not zero, input will
   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].

     The in_desc and out_desc parameters of inflateBack() is passed as the
   first parameter of in() and out() respectively when they are called.  These
   descriptors can be optionally used to pass any information that the caller-
   supplied in() and out() functions need to do their job.

     On return, inflateBack() will set strm->next_in and strm->avail_in to
   pass back any unused input that was provided by the last in() call.  The
   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
   in the deflate stream (in which case strm->msg is set to indicate the nature
   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
   In the case of Z_BUF_ERROR, an input or output error can be distinguished
   using strm->next_in which will be Z_NULL only if in() returned an error.  If
   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
   non-zero.  (in() will always be called before out(), so strm->next_in is
   assured to be defined if out() returns non-zero.)  Note that inflateBack()
   cannot return Z_OK.
*//*
ZEXTERN int ZEXPORT inflateBackInit(z_streamp strm, int windowBits,
                                    unsigned char FAR *window);

     Initialize the internal stream state for decompression using inflateBack()
   calls.  The fields zalloc, zfree and opaque in strm must be initialized
   before the call.  If zalloc and zfree are Z_NULL, then the default library-
   derived memory allocation routines are used.  windowBits is the base two
   logarithm of the window size, in the range 8..15.  window is a caller
   supplied buffer of that size.  Except for special applications where it is
   assured that deflate was used with small window sizes, windowBits must be 15
   and a 32K byte window must be supplied to be able to decompress general
   deflate streams.

     See inflateBack() for the usage of these routines.

     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
   the parameters are invalid, Z_MEM_ERROR if the internal state could not be
   allocated, or Z_VERSION_ERROR if the version of the library does not match
   the version of the header file.
*//*
     inflateGetHeader() requests that gzip header information be stored in the
   provided gz_header structure.  inflateGetHeader() may be called after
   inflateInit2() or inflateReset(), and before the first call of inflate().
   As inflate() processes the gzip stream, head->done is zero until the header
   is completed, at which time head->done is set to one.  If a zlib stream is
   being decoded, then head->done is set to -1 to indicate that there will be
   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
   used to force inflate() to return immediately after header processing is
   complete and before any actual data is decompressed.

     The text, time, xflags, and os fields are filled in with the gzip header
   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
   contains the maximum number of bytes to write to extra.  Once done is true,
   extra_len contains the actual extra field length, and extra contains the
   extra field, or that field truncated if extra_max is less than extra_len.
   If name is not Z_NULL, then up to name_max characters are written there,
   terminated with a zero unless the length is greater than name_max.  If
   comment is not Z_NULL, then up to comm_max characters are written there,
   terminated with a zero unless the length is greater than comm_max.  When any
   of extra, name, or comment are not Z_NULL and the respective field is not
   present in the header, then that field is set to Z_NULL to signal its
   absence.  This allows the use of deflateSetHeader() with the returned
   structure to duplicate the header.  However if those fields are set to
   allocated memory, then the application will need to save those pointers
   elsewhere so that they can be eventually freed.

     If inflateGetHeader is not used, then the header information is simply
   discarded.  The header is always checked for validity, including the header
   CRC if present.  inflateReset() will reset the process to discard the header
   information.  The application would need to call inflateGetHeader() again to
   retrieve the header from the next gzip stream.

     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*//*
     This function returns two values, one in the lower 16 bits of the return
   value, and the other in the remaining upper bits, obtained by shifting the
   return value down 16 bits.  If the upper value is -1 and the lower value is
   zero, then inflate() is currently decoding information outside of a block.
   If the upper value is -1 and the lower value is non-zero, then inflate is in
   the middle of a stored block, with the lower value equaling the number of
   bytes from the input remaining to copy.  If the upper value is not -1, then
   it is the number of bits back from the current bit position in the input of
   the code (literal or length/distance pair) currently being processed.  In
   that case the lower value is the number of bytes already emitted for that
   code.

     A code is being processed if inflate is waiting for more input to complete
   decoding of the code, or if it has completed decoding but is waiting for
   more output space to write the literal or match data.

     inflateMark() is used to mark locations in the input data for random
   access, which may be at bit positions, and to note those cases where the
   output of a code may span boundaries of random access blocks.  The current
   location in the input stream can be determined from avail_in and data_type
   as noted in the description for the Z_BLOCK flush parameter for inflate.

     inflateMark returns the value noted above, or -65536 if the provided
   source stream state was inconsistent.
*//*
     This function inserts bits in the inflate input stream.  The intent is
   that this function is used to start inflating at a bit position in the
   middle of a byte.  The provided bits will be used before any bytes are used
   from next_in.  This function should only be used with raw inflate, and
   should be used before the first inflate() call after inflateInit2() or
   inflateReset().  bits must be less than or equal to 16, and that many of the
   least significant bits of value will be inserted in the input.

     If bits is negative, then the input stream bit buffer is emptied.  Then
   inflatePrime() can be called again to put bits in the buffer.  This is used
   to clear out bits leftover after feeding inflate a block description prior
   to feeding inflate codes.

     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*//*
     This function is the same as inflateReset, but it also permits changing
   the wrap and window size requests.  The windowBits parameter is interpreted
   the same as it is for inflateInit2.  If the window size is changed, then the
   memory allocated for the window is freed, and the window will be reallocated
   by inflate() if needed.

     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
   the windowBits parameter is invalid.
*//*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate the internal decompression state.  The
   stream will keep attributes that may have been set by inflateInit2.
   total_in, total_out, adler, and msg are initialized.

     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL).
*//*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when randomly accessing a large stream.  The
   first pass through the stream can periodically record the inflate state,
   allowing restarting inflate at those points when randomly accessing the
   stream.

     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   destination.
*//*
     Skips invalid compressed data until a possible full flush point (see above
   for the description of deflate with Z_FULL_FLUSH) can be found, or until all
   available input is skipped.  No output is provided.

     inflateSync searches for a 00 00 FF FF pattern in the compressed data.
   All full flush points have this pattern, but not all occurrences of this
   pattern are full flush points.

     inflateSync returns Z_OK if a possible full flush point has been found,
   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
   In the success case, the application may save the current value of total_in
   which indicates where valid compressed data was found.  In the error case,
   the application may repeatedly call inflateSync, providing more input each
   time, until success or end of the input data.
*//*
     Returns the sliding dictionary being maintained by inflate.  dictLength is
   set to the number of bytes in the dictionary, and that many bytes are copied
   to dictionary.  dictionary must have enough space, where 32768 bytes is
   always enough.  If inflateGetDictionary() is called with dictionary equal to
   Z_NULL, then only the dictionary length is returned, and nothing is copied.
   Similarly, if dictLength is Z_NULL, then it is not set.

     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
   stream state is inconsistent.
*//*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence.  This function must be called immediately after a call of inflate,
   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
   can be determined from the Adler-32 value returned by that call of inflate.
   The compressor and decompressor must use exactly the same dictionary (see
   deflateSetDictionary).  For raw inflate, this function can be called at any
   time to set the dictionary.  If the provided dictionary is smaller than the
   window and there is already data in the window, then the provided dictionary
   will amend what's there.  The application must insure that the dictionary
   that was used for compression is provided.

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler-32 value).  inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*//*
ZEXTERN int ZEXPORT inflateInit2(z_streamp strm,
                                 int windowBits);

     This is another version of inflateInit with an extra parameter.  The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library.  The default value is 15 if inflateInit is used
   instead.  windowBits must be greater than or equal to the windowBits value
   provided to deflateInit2() while compressing, or it must be equal to 15 if
   deflateInit2() was not used.  If a compressed stream with a larger window
   size is given as input, inflate() will return with the error code
   Z_DATA_ERROR instead of trying to allocate a larger window.

     windowBits can also be zero to request that inflate use the window size in
   the zlib header of the compressed stream.

     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
   determines the window size.  inflate() will then process raw deflate data,
   not looking for a zlib or gzip header, not generating a check value, and not
   looking for any check values for comparison at the end of the stream.  This
   is for use with other formats that use the deflate compressed data format
   such as zip.  Those formats provide their own check values.  If a custom
   format is developed using the raw deflate format for compressed data, it is
   recommended that a check value such as an Adler-32 or a CRC-32 be applied to
   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
   most applications, the zlib format should be used as is.  Note that comments
   above on the use in deflateInit2() applies to the magnitude of windowBits.

     windowBits can also be greater than 15 for optional gzip decoding.  Add
   32 to windowBits to enable zlib and gzip decoding with automatic header
   detection, or add 16 to decode only the gzip format (the zlib format will
   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see
   below), inflate() will *not* automatically decode concatenated gzip members.
   inflate() will return Z_STREAM_END at the end of the gzip member.  The state
   would need to be reset to continue decoding a subsequent gzip member.  This
   *must* be done if there is more data after a gzip member, in order for the
   decompression to be compliant with the gzip standard (RFC 1952).

     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   invalid, such as a null pointer to the structure.  msg is set to null if
   there is no error message.  inflateInit2 does not perform any decompression
   apart from possibly reading the zlib header if present: actual decompression
   will be done by inflate().  (So next_in and avail_in may be modified, but
   next_out and avail_out are unused and unchanged.) The current implementation
   of inflateInit2() does not process any header information -- that is
   deferred until inflate() is called.
*//*
     deflateSetHeader() provides gzip header information for when a gzip
   stream is requested by deflateInit2().  deflateSetHeader() may be called
   after deflateInit2() or deflateReset() and before the first call of
   deflate().  The text, time, os, extra field, name, and comment information
   in the provided gz_header structure are written to the gzip header (xflag is
   ignored -- the extra flags are set according to the compression level).  The
   caller must assure that, if not Z_NULL, name and comment are terminated with
   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
   available there.  If hcrc is true, a gzip header crc is included.  Note that
   the current versions of the command-line version of gzip (up through version
   1.3.x) do not support header crc's, and will report that it is a "multi-part
   gzip file" and give up.

     If deflateSetHeader is not used, the default gzip header has text false,
   the time set to zero, and os set to the current operating system, with no
   extra, name, or comment fields.  The gzip header is returned to the default
   state by deflateReset().

     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*//*
     deflatePrime() inserts bits in the deflate output stream.  The intent
   is that this function is used to start off the deflate output with the bits
   leftover from a previous deflate stream when appending to it.  As such, this
   function can only be used for raw deflate, and must be used before the first
   deflate() call after a deflateInit2() or deflateReset().  bits must be less
   than or equal to 16, and that many of the least significant bits of value
   will be inserted in the output.

     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
   source stream state was inconsistent.
*//*
     deflatePending() returns the number of bytes and bits of output that have
   been generated, but not yet provided in the available output.  The bytes not
   provided would be due to the available output space having being consumed.
   The number of bits of output not provided are between 0 and 7, where they
   await more bits to join them in order to fill out a full byte.  If pending
   or bits are Z_NULL, then those values are not set.

     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
 *//*
     deflateBound() returns an upper bound on the compressed size after
   deflation of sourceLen bytes.  It must be called after deflateInit() or
   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
   to allocate an output buffer for deflation in a single pass, and so would be
   called before deflate().  If that first deflate() call is provided the
   sourceLen input bytes, an output buffer allocated to the size returned by
   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
   to return Z_STREAM_END.  Note that it is possible for the compressed size to
   be larger than the value returned by deflateBound() if flush options other
   than Z_FINISH or Z_NO_FLUSH are used.
*//*
     Fine tune deflate's internal compression parameters.  This should only be
   used by someone who understands the algorithm used by zlib's deflate for
   searching for the best matching string, and even then only by the most
   fanatic optimizer trying to squeeze out the last compressed bit for their
   specific input data.  Read the deflate.c source code for the meaning of the
   max_lazy, good_length, nice_length, and max_chain parameters.

     deflateTune() can be called after deflateInit() or deflateInit2(), and
   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
 *//*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2().  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different strategy.
   If the compression approach (which is a function of the level) or the
   strategy is changed, and if there have been any deflate() calls since the
   state was initialized or reset, then the input available so far is
   compressed with the old level and strategy using deflate(strm, Z_BLOCK).
   There are three approaches for the compression levels 0, 1..3, and 4..9
   respectively.  The new level and strategy will take effect at the next call
   of deflate().

     If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does
   not have enough output space to complete, then the parameter change will not
   take effect.  In this case, deflateParams() can be called again with the
   same parameters and more output space to try again.

     In order to assure a change in the parameters on the first try, the
   deflate stream should be flushed using deflate() with Z_BLOCK or other flush
   request until strm.avail_out is not zero, before calling deflateParams().
   Then no more input data should be provided before the deflateParams() call.
   If this is done, the old level and strategy will be applied to the data
   compressed before deflateParams(), and the new level and strategy will be
   applied to the data compressed after deflateParams().

     deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream
   state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if
   there was not enough output space to complete the compression of the
   available input data before a change in the strategy or approach.  Note that
   in the case of a Z_BUF_ERROR, the parameters are not changed.  A return
   value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be
   retried with more output space.
*//*
     This function is equivalent to deflateEnd followed by deflateInit, but
   does not free and reallocate the internal compression state.  The stream
   will leave the compression level and any other attributes that may have been
   set unchanged.  total_in, total_out, adler, and msg are initialized.

     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL).
*//*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter.  The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and can
   consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   destination.
*//*
     Returns the sliding dictionary being maintained by deflate.  dictLength is
   set to the number of bytes in the dictionary, and that many bytes are copied
   to dictionary.  dictionary must have enough space, where 32768 bytes is
   always enough.  If deflateGetDictionary() is called with dictionary equal to
   Z_NULL, then only the dictionary length is returned, and nothing is copied.
   Similarly, if dictLength is Z_NULL, then it is not set.

     deflateGetDictionary() may return a length less than the window size, even
   when more than the window size in input has been provided. It may return up
   to 258 bytes less in that case, due to how zlib's implementation of deflate
   manages the sliding window and lookahead for matches, where matches can be
   up to 258 bytes long. If the application needs the last window-size bytes of
   input, then that would need to be saved by the application outside of zlib.

     deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
   stream state is inconsistent.
*//*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output.  When using the zlib format, this
   function must be called immediately after deflateInit, deflateInit2 or
   deflateReset, and before any call of deflate.  When doing raw deflate, this
   function must be called either before any call of deflate, or immediately
   after the completion of a deflate block, i.e. after all input has been
   consumed and all output has been delivered when using any of the flush
   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
   compressor and decompressor must use exactly the same dictionary (see
   inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary.  Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size
   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
   useful should be put at the end of the dictionary, not at the front.  In
   addition, the current implementation of deflate will use at most the window
   size minus 262 bytes of the provided dictionary.

     Upon return of this function, strm->adler is set to the Adler-32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor.  (The Adler-32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.) If a raw deflate was requested, then the
   Adler-32 value is not computed and strm->adler is not set.

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if not at a block boundary for raw deflate).  deflateSetDictionary does
   not perform any compression: this will be done by deflate().
*//*
ZEXTERN int ZEXPORT deflateInit2(z_streamp strm,
                                 int level,
                                 int method,
                                 int windowBits,
                                 int memLevel,
                                 int strategy);

     This is another version of deflateInit with more compression options.  The
   fields zalloc, zfree and opaque must be initialized before by the caller.

     The method parameter is the compression method.  It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library.  Larger values of this parameter result in better
   compression at the expense of memory usage.  The default value is 15 if
   deflateInit is used instead.

     For the current implementation of deflate(), a windowBits value of 8 (a
   window size of 256 bytes) is not supported.  As a result, a request for 8
   will result in 9 (a 512-byte window).  In that case, providing 8 to
   inflateInit2() will result in an error when the zlib header with 9 is
   checked against the initialization of inflate().  The remedy is to not use 8
   with deflateInit2() with this initialization, or at least in that case use 9
   with inflateInit2().

     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
   determines the window size.  deflate() will then generate raw deflate data
   with no zlib header or trailer, and will not compute a check value.

     windowBits can also be greater than 15 for optional gzip encoding.  Add
   16 to windowBits to write a simple gzip header and trailer around the
   compressed data instead of a zlib wrapper.  The gzip header will have no
   file name, no extra data, no comment, no modification time (set to zero), no
   header crc, and the operating system will be set to the appropriate value,
   if the operating system was determined at compile time.  If a gzip stream is
   being written, strm->adler is a CRC-32 instead of an Adler-32.

     For raw deflate or gzip encoding, a request for a 256-byte window is
   rejected as invalid, since only the zlib header provides a means of
   transmitting the window size to the decompressor.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state.  memLevel=1 uses minimum memory but is
   slow and reduces compression ratio; memLevel=9 uses maximum memory for
   optimal speed.  The default value is 8.  See zconf.h for total memory usage
   as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm.  Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match), or Z_RLE to limit match distances to one (run-length
   encoding).  Filtered data consists mostly of small values with a somewhat
   random distribution.  In this case, the compression algorithm is tuned to
   compress them better.  The effect of Z_FILTERED is to force more Huffman
   coding and less string matching; it is somewhat intermediate between
   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
   strategy parameter only affects the compression ratio but not the
   correctness of the compressed output even if it is not set appropriately.
   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
   decoder for special applications.

     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
   set to null if there is no error message.  deflateInit2 does not perform any
   compression: this will be done by deflate().
*//*
    The following functions are needed only in some special applications.
*//* Advanced functions *//*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any pending
   output.

     inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state
   was inconsistent.
*//*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full.  It may introduce
  some output latency (reading input without producing any output) except when
  forced to flush.

  The detailed semantics are as follows.  inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly.  If not all input can be processed (because there is not
    enough room in the output buffer), then next_in and avail_in are updated
    accordingly, and processing will resume at this point for the next call of
    inflate().

  - Generate more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there is
    no more input data or no more space in the output buffer (see below about
    the flush parameter).

    Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming more
  output, and updating the next_* and avail_* values accordingly.  If the
  caller of inflate() does not provide both available input and available
  output space, it is possible that there will be no progress made.  The
  application can consume the uncompressed output when it wants, for example
  when the output buffer is full (avail_out == 0), or after each call of
  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
  called again after making room in the output buffer because there might be
  more output pending.

    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
  output as possible to the output buffer.  Z_BLOCK requests that inflate()
  stop if and when it gets to the next deflate block boundary.  When decoding
  the zlib or gzip format, this will cause inflate() to return immediately
  after the header and before the first block.  When doing a raw inflate,
  inflate() will go ahead and process the first block, and will return when it
  gets to the end of that block, or when it runs out of data.

    The Z_BLOCK option assists in appending to or combining deflate streams.
  To assist in this, on return inflate() always sets strm->data_type to the
  number of unused bits in the last byte taken from strm->next_in, plus 64 if
  inflate() is currently decoding the last block in the deflate stream, plus
  128 if inflate() returned immediately after decoding an end-of-block code or
  decoding the complete header up to just before the first byte of the deflate
  stream.  The end-of-block will not be indicated until all of the uncompressed
  data from that block has been written to strm->next_out.  The number of
  unused bits may in general be greater than seven, except when bit 7 of
  data_type is set, in which case the number of unused bits will be less than
  eight.  data_type is set as noted here every time inflate() returns for all
  flush options, and so can be used to determine the amount of currently
  consumed input in bits.

    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
  end of each deflate block header is reached, before any actual data in that
  block is decoded.  This allows the caller to determine the length of the
  deflate block header for later use in random access within a deflate block.
  256 is added to the value of strm->data_type when inflate() returns
  immediately after reaching the end of the deflate block header.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error.  However if all decompression is to be performed in a single step (a
  single call of inflate), the parameter flush should be set to Z_FINISH.  In
  this case all pending input is processed and all pending output is flushed;
  avail_out must be large enough to hold all of the uncompressed data for the
  operation to complete.  (The size of the uncompressed data may have been
  saved by the compressor for this purpose.)  The use of Z_FINISH is not
  required to perform an inflation in one step.  However it may be used to
  inform inflate that a faster approach can be used for the single inflate()
  call.  Z_FINISH also informs inflate to not maintain a sliding window if the
  stream completes, which reduces inflate's memory footprint.  If the stream
  does not complete, either because not all of the stream is provided or not
  enough output space is provided, then a sliding window will be allocated and
  inflate() can be called again to continue the operation as if Z_NO_FLUSH had
  been used.

     In this implementation, inflate() always flushes as much output as
  possible to the output buffer, and always uses the faster approach on the
  first call.  So the effects of the flush parameter in this implementation are
  on the return value of inflate() as noted below, when inflate() returns early
  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
  memory for a sliding window when Z_FINISH is used.

     If a preset dictionary is needed after this call (see inflateSetDictionary
  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
  strm->adler to the Adler-32 checksum of all output produced so far (that is,
  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
  below.  At the end of the stream, inflate() checks that its computed Adler-32
  checksum is equal to that saved by the compressor and returns Z_STREAM_END
  only if the checksum is correct.

    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
  deflate data.  The header type is detected automatically, if requested when
  initializing with inflateInit2().  Any information contained in the gzip
  header is not retained unless inflateGetHeader() is used.  When processing
  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
  produced so far.  The CRC-32 is checked against the gzip trailer, as is the
  uncompressed length, modulo 2^32.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect check
  value, in which case strm->msg points to a string with a more specific
  error), Z_STREAM_ERROR if the stream structure was inconsistent (for example
  next_in or next_out was Z_NULL, or the state was inadvertently written over
  by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR
  if no progress was possible or if there was not enough room in the output
  buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
  inflate() can be called again with more input and more output space to
  continue decompressing.  If Z_DATA_ERROR is returned, the application may
  then call inflateSync() to look for a good compression block if a partial
  recovery of the data is to be attempted.
*//*
ZEXTERN int ZEXPORT inflateInit(z_streamp strm);

     Initializes the internal stream state for decompression.  The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller.  In the current version of inflate, the provided input is not
   read or consumed.  The allocation of a sliding window will be deferred to
   the first call of inflate (if the decompression does not complete on the
   first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates
   them to use default allocation functions.  total_in, total_out, adler, and
   msg are initialized.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   invalid, such as a null pointer to the structure.  msg is set to null if
   there is no error message.  inflateInit does not perform any decompression.
   Actual decompression will be done by inflate().  So next_in, and avail_in,
   next_out, and avail_out are unused and unchanged.  The current
   implementation of inflateInit() does not process any header information --
   that is deferred until inflate() is called.
*//*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any pending
   output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded).  In the error case, msg
   may be set but then points to a static string (which must not be
   deallocated).
*//*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full.  It may introduce
  some output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows.  deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly.  If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Generate more output starting at next_out and update next_out and avail_out
    accordingly.  This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary.  Some output may be provided even if
    flush is zero.

    Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming more
  output, and updating avail_in or avail_out accordingly; avail_out should
  never be zero before the call.  The application can consume the compressed
  output when it wants, for example when the output buffer is full (avail_out
  == 0), or after each call of deflate().  If deflate returns Z_OK and with
  zero avail_out, it must be called again after making room in the output
  buffer because there might be more output pending. See deflatePending(),
  which can be used if desired to determine whether or not there is more output
  in that case.

    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
  decide how much data to accumulate before producing output, in order to
  maximize compression.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far.  (In
  particular avail_in is zero after the call if enough output space has been
  provided before the call.) Flushing may degrade compression for some
  compression algorithms and so it should be used only when necessary.  This
  completes the current deflate block and follows it with an empty stored block
  that is three bits plus filler bits to the next byte, followed by four bytes
  (00 00 ff ff).

    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
  output buffer, but the output is not aligned to a byte boundary.  All of the
  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
  This completes the current deflate block and follows it with an empty fixed
  codes block that is 10 bits long.  This assures that enough bytes are output
  in order for the decompressor to finish the block before the empty fixed
  codes block.

    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
  seven bits of the current block are held to be written as the next byte after
  the next deflate block is completed.  In this case, the decompressor may not
  be provided enough bits at this point in order to complete decompression of
  the data provided so far to the compressor.  It may need to wait for the next
  block to be emitted.  This is for advanced applications that need to control
  the emission of deflate blocks.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
  compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
  avail_out is greater than six when the flush marker begins, in order to avoid
  repeated flush markers upon calling deflate() again when avail_out == 0.

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there was
  enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this
  function must be called again with Z_FINISH and more output space (updated
  avail_out) but no more input data, until it returns with Z_STREAM_END or an
  error.  After deflate has returned Z_STREAM_END, the only possible operations
  on the stream are deflateReset or deflateEnd.

    Z_FINISH can be used in the first deflate call after deflateInit if all the
  compression is to be done in a single step.  In order to complete in one
  call, avail_out must be at least the value returned by deflateBound (see
  below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough
  output space is provided, deflate will not return Z_STREAM_END, and it must
  be called again as described above.

    deflate() sets strm->adler to the Adler-32 checksum of all input read
  so far (that is, total_in bytes).  If a gzip stream is being generated, then
  strm->adler will be the CRC-32 checksum of the input read so far.  (See
  deflateInit2 below.)

    deflate() may update strm->data_type if it can make a good guess about
  the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is
  considered binary.  This field is only for information purposes and does not
  affect the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was Z_NULL or the state was inadvertently written over
  by the application), or Z_BUF_ERROR if no progress is possible (for example
  avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and
  deflate() can be called again with more input and more output space to
  continue compressing.
*//*
ZEXTERN int ZEXPORT deflateInit(z_streamp strm, int level);

     Initializes the internal stream state for compression.  The fields
   zalloc, zfree and opaque must be initialized before by the caller.  If
   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
   allocation functions.  total_in, total_out, adler, and msg are initialized.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at all
   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
   requests a default compromise between speed and compression (currently
   equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if level is not a valid compression level, or
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
   if there is no error message.  deflateInit does not perform any compression:
   this will be done by deflate().
*//* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is not
   compatible with the zlib.h header file used by the application.  This check
   is automatically made by deflateInit and inflateInit.
 *//* basic functions *//* for compatibility with versions < 1.0.2 *//* for initializing zalloc, zfree, opaque *//* The deflate compression method (the only one supported in this version) *//* Possible values of the data_type field for deflate() *//* for compatibility with 1.2.2 and earlier *//* compression strategy; see deflateInit2() below for details *//* compression levels *//* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 *//* Allowed flush values; see deflate() and inflate() below for details *//* constants *//*
     The application must update next_in and avail_in when avail_in has dropped
   to zero.  It must update next_out and avail_out when avail_out has dropped
   to zero.  The application must initialize zalloc, zfree and opaque before
   calling the init function.  All other fields are set by the compression
   library and must not be updated by the application.

     The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree.  This can be useful for custom
   memory management.  The compression library attaches no meaning to the
   opaque value.

     zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are
   Z_NULL on entry to the initialization function, they are set to internal
   routines that use the standard library functions malloc() and free().

     On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this if
   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
   returned by zalloc for objects of exactly 65536 bytes *must* have their
   offset normalized to zero.  The default allocation function provided by this
   library ensures this (see zutil.c).  To reduce memory requirements and avoid
   any allocation of 64K objects, at the expense of compression ratio, compile
   the library with -DMAX_WBITS=14 (see zconf.h).

     The fields total_in and total_out can be used for statistics or progress
   reports.  After compression, total_in holds the total size of the
   uncompressed data and may be saved for use by the decompressor (particularly
   if the decompressor wants to decompress everything in a single step).
*//* true when done reading gzip header (not used
                           when writing a gzip file) *//* true if there was or will be a header crc *//* space at comment (only when reading header) *//* pointer to zero-terminated comment or Z_NULL *//* space at name (only when reading header) *//* pointer to zero-terminated file name or Z_NULL *//* space at extra (only when reading header) *//* extra field length (valid if extra != Z_NULL) *//* pointer to extra field or Z_NULL if none *//* operating system *//* extra flags (not used when writing a gzip file) *//* modification time *//* true if compressed data believed to be text *//*
     gzip header information passed to and from zlib routines.  See RFC 1952
  for more details on the meanings of these fields.
*//* reserved for future use *//* Adler-32 or CRC-32 value of the uncompressed data *//* best guess about the data type: binary or text
                           for deflate, or the decoding state for inflate *//* private data object passed to zalloc and zfree *//* used to free the internal state *//* used to allocate the internal state *//* not visible by applications *//* last error message, NULL if no error *//* total number of bytes output so far *//* remaining free space at next_out *//* next output byte will go here *//* total number of input bytes read so far *//* number of bytes available at next_in *//* next input byte *//*
    The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed data.
  This version of the library supports only one compression method (deflation)
  but other algorithms will be added later and will have the same stream
  interface.

    Compression can be done in a single step if the buffers are large enough,
  or can be done by repeated calls of the compression function.  In the latter
  case, the application must provide more input and/or consume the output
  (providing more output space) before each call.

    The compressed data format used by default by the in-memory functions is
  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
  around a deflate stream, which is itself documented in RFC 1951.

    The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio using the functions that start
  with "gz".  The gzip format is different from the zlib format.  gzip is a
  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.

    This library can optionally read and write gzip and raw deflate streams in
  memory as well.

    The zlib format was designed to be compact and fast for use in memory
  and on communications channels.  The gzip format was designed for single-
  file compression on file systems, has a larger header than zlib to maintain
  directory information, and uses a different, slower check method than zlib.

    The library does not install any signal handler.  The decoder checks
  the consistency of the compressed data, so the library should never crash
  even in the case of corrupted input.
*//* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.3.1, January 22nd, 2024

  Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
*/vapathstrmwindowBitswindowstream_sizememLevelcrc1crc2operrnumnitemsfddestdestLensourcesourceLenin_descout_descheaddictionarydictLengthpendinggood_lengthmax_lazynice_lengthmax_chainD:/PracticeInCodeQL/libpng/contrib/tools/png-fix-itxt.cunsigned char[500000]500000MAX_LENGTHinchar499988GETBREAKinchar=getchar(); c=(inchar & 0xffU); if (inchar != c) break/* EOF *//* The IEND chunk type expressed as integers is (73, 69, 78, 68) *//* Copy data bytes and CRC *//* Copy bytes that were already read (length and chunk name) *//* Write the fixed iTXt chunk (length, name, data, crc) *//* Update length bytes *//* Update the CRC *//* Check the CRC *//* Calculate the CRC *//* Copy the data bytes *//* Initialize the CRC *//* To do: handle this more gracefully *//* The iTXt chunk type expressed as integers is (105, 84, 88, 116) *//* Read the chunkname *//* must be 32 bits! *//* Read the length *//* !EOF *//* Skip 8-byte signature *//* Read one character (inchar), also return octet (c), break if EOF *//* png-fix-itxt
 *
 * Copyright 2015 Glenn Randers-Pehrson
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * Usage:
 *
 *     png-fix-itxt < bad.png > good.png
 *
 * Fixes a PNG file written with libpng-1.6.0 or 1.6.1 that has one or more
 * uncompressed iTXt chunks.  Assumes that the actual length is greater
 * than or equal to the value in the length byte, and that the CRC is
 * correct for the actual length.  This program hunts for the CRC and
 * adjusts the length byte accordingly.  It is not an error to process a
 * PNG file that has no iTXt chunks or one that has valid iTXt chunks;
 * such files will simply be copied.
 *
 * Requires zlib (for crc32 and Z_NULL); build with
 *
 *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
 *
 * If you need to handle iTXt chunks larger than 500000 kbytes you must
 * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
 * if you know you will never encounter such huge iTXt chunks).
 */is_wctype_isleadbyte_lisleadbyte_iswctype_l_towlower_l_towupper_liswctypetowlowertowupper_iswcsym_l_iswcsymf_l_iswxdigit_l_iswupper_l_iswspace_l_iswpunct_l_iswprint_l_iswlower_l_iswgraph_l_iswdigit_l_iswcntrl_l_iswblank_l_iswalpha_l_iswalnum_l__iswcsym__iswcsymfiswxdigitiswupperiswspaceiswpunctiswprintiswloweriswgraphiswdigitiswcntrliswblankiswasciiiswalphaiswalnumconst wctype_tconst wctype_t *__pwctype_func__pctype_funcisleadbyte(_c)(__PCTYPE_FUNC[(unsigned char)(_c)] & _LEADBYTE)_iswcntrl_l(_c,_p)(iswctype(_c, _CONTROL))_iswgraph_l(_c,_p)(iswctype(_c, _PUNCT | _ALPHA | _DIGIT))_iswprint_l(_c,_p)(iswctype(_c, _BLANK | _PUNCT | _ALPHA | _DIGIT))_iswalnum_l(_c,_p)(iswctype(_c, _ALPHA | _DIGIT))_iswblank_l(_c,_p)(iswctype(_c, _BLANK))_iswpunct_l(_c,_p)(iswctype(_c, _PUNCT))_iswspace_l(_c,_p)(iswctype(_c, _SPACE))_iswxdigit_l(_c,_p)(iswctype(_c, _HEX))_iswdigit_l(_c,_p)(iswctype(_c, _DIGIT))_iswlower_l(_c,_p)(iswctype(_c, _LOWER))_iswupper_l(_c,_p)(iswctype(_c, _UPPER))_iswalpha_l(_c,_p)(iswctype(_c, _ALPHA))iswascii(_c)((unsigned)(_c) < 0x80)iswcntrl(_c)iswgraph(_c)iswprint(_c)iswalnum(_c)iswblank(_c)(((_c) == '\t') ? _BLANK : iswctype(_c,_BLANK) )iswpunct(_c)iswspace(_c)iswxdigit(_c)iswdigit(_c)iswlower(_c)iswupper(_c)iswalpha(_c)_ALPHA(0x0100 | _UPPER | _LOWER)_LEADBYTE_HEX_BLANK_CONTROL_PUNCT_SPACE_DIGIT_LOWER_UPPER_pwctype(__pwctype_func())_pctype(__pctype_func())__PCTYPE_FUNC__pctype_func()_CTYPE_DISABLE_MACROS!defined __cplusplus || defined _M_CEE_PURE || defined MRTDLL || defined _CORECRT_BUILDThis function or variable has been superceded by newer library or operating system functionality. Consider using iswctype instead. See online help for details.char[160]"This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details."_Param_(1) == 0_Post_equal_to_(0)_Post_equal_to__Out_range_(==, 0)"_Post_equal_to_"==_Out_range_(==,0)_Out_range_impl_(==,0)"_Out_range_"//    #endif//        #endif//        }//            return __pctype_func()[(unsigned char)(_C)] & _LEADBYTE;//        {//        inline int __cdecl isleadbyte(_In_ int _C)//        #ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP//        inline int __cdecl _iswcntrl_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _CONTROL); }//        inline int __cdecl _iswgraph_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _PUNCT | _ALPHA | _DIGIT); }//        inline int __cdecl _iswprint_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _BLANK | _PUNCT | _ALPHA | _DIGIT); }//        inline int __cdecl _iswalnum_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _ALPHA | _DIGIT); }//        inline int __cdecl _iswblank_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _BLANK); }//        inline int __cdecl _iswpunct_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _PUNCT); }//        inline int __cdecl _iswspace_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _SPACE); }//        inline int __cdecl _iswxdigit_l(_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _HEX); }//        inline int __cdecl _iswdigit_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _DIGIT); }//        inline int __cdecl _iswlower_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _LOWER); }//        inline int __cdecl _iswupper_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _UPPER); }//        inline int __cdecl _iswalpha_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _ALPHA); }//        inline int __cdecl iswascii (_In_ wint_t _C) { return (unsigned)(_C) < 0x80; }//        inline int __cdecl iswcntrl (_In_ wint_t _C) { return iswctype(_C, _CONTROL); }//        inline int __cdecl iswgraph (_In_ wint_t _C) { return iswctype(_C, _PUNCT | _ALPHA | _DIGIT); }//        inline int __cdecl iswprint (_In_ wint_t _C) { return iswctype(_C, _BLANK | _PUNCT | _ALPHA | _DIGIT); }//        inline int __cdecl iswalnum (_In_ wint_t _C) { return iswctype(_C, _ALPHA | _DIGIT); }//        inline int __cdecl iswblank (_In_ wint_t _C) { return (((_C) == '\t') ? _BLANK : iswctype(_C,_BLANK)); }//        inline int __cdecl iswpunct (_In_ wint_t _C) { return iswctype(_C, _PUNCT); }//        inline int __cdecl iswspace (_In_ wint_t _C) { return iswctype(_C, _SPACE); }//        inline int __cdecl iswxdigit(_In_ wint_t _C) { return iswctype(_C, _HEX); }//        inline int __cdecl iswdigit (_In_ wint_t _C) { return iswctype(_C, _DIGIT); }//        inline int __cdecl iswlower (_In_ wint_t _C) { return iswctype(_C, _LOWER); }//        inline int __cdecl iswupper (_In_ wint_t _C) { return iswctype(_C, _UPPER); }//        inline int __cdecl iswalpha (_In_ wint_t _C) { return iswctype(_C, _ALPHA); }//    #ifndef _CTYPE_DISABLE_MACROS//#else// C968560.  We need to figure out what is wrong.// they break the debugger build.  These were moved here from <wctype.h> in// CRT_REFACTOR TODO I've had to remove the inline function definitions because// _CTYPE_DISABLE_MACROS// Macro and Inline Definitions// Wide Character Classification and Conversion Functions// alphabetic character// multibyte leadbyte// hexadecimal digit// space char (tab is handled separately)// control character// punctuation character// tab, carriage return, newline, vertical tab, or form feed// digit[0-9]// lowercase letter// uppercase letter// Bit masks for the possible character types// array _ctype defined in ctype.obj by simply including ctype.h// This declaration allows the user access to the ctype look-up// shared by <ctype.h>, <wchar.h>, and <wctype.h>.// This file declares the wide character (wchar_t) classification functionality,// corecrt_wctype.h_C_Type<corecrt_wctype.h>_ischartype_l__crt_locale_data_public *const volatile voidconst volatile void *const volatile void *const_chvalidchk_l_chvalidator_l__acrt_get_locale_data_prefix_TypedLocalePointers__ascii_towupper__ascii_towlower__ascii_iswdigit'9'__ascii_iswalpha'A''Z''a'__ascii_toupper'a' - 'A'('a' - 'A')__ascii_tolower-32'A' - 'a'('A' - 'a')_chvalidator__acrt_locale_get_ctype_array_valueconst unsigned short *const__iscsym__iscsymf__toascii__isascii_toupper_l_toupper_tolower_l_tolowertolowertoupper_iscntrl_liscntrl_isgraph_lisgraph_isprint_lisprint_isalnum_lisalnum_isblank_lisblank_ispunct_lispunct_isspace_lisspace_isxdigit_lisxdigit_isdigit_lisdigit_islower_lislower_isupper_lisupper_isalpha_lisalpha_isctype_l_isctypeiscsymiscsymftoasciiisascii_iswcsym_l(c,p)(iswalnum(c) || ((c) == '_'))_iswcsymf_l(c,p)(iswalpha(c) || ((c) == '_'))_iscsym_l(c,p)(_isalnum_l(c, p) || ((c) == '_'))_iscsymf_l(c,p)(_isalpha_l(c, p) || ((c) == '_'))__iswcsym(c)__iswcsymf(c)__iscsym(c)(isalnum(c) || ((c) == '_'))__iscsymf(c)(isalpha(c) || ((c) == '_'))__toascii(c)((c) & 0x7f)__isascii(c)((unsigned)(c) < 0x80)_toupper(c)((c) - 'a' + 'A')_tolower(c)((c) - 'A' + 'a')_iscntrl_l(c,locale)_ischartype_l(c, _CONTROL, locale)_isgraph_l(c,locale)_ischartype_l(c, _PUNCT | _ALPHA | _DIGIT, locale)_isprint_l(c,locale)_ischartype_l(c, _BLANK | _PUNCT | _ALPHA | _DIGIT, locale)_isalnum_l(c,locale)_ischartype_l(c, _ALPHA | _DIGIT, locale)_isblank_l(c,locale)(((c) == '\t') ? _BLANK : _ischartype_l(c, _BLANK, locale))_ispunct_l(c,locale)_ischartype_l(c, _PUNCT, locale)_isspace_l(c,locale)_ischartype_l(c, _SPACE, locale)_isxdigit_l(c,locale)_ischartype_l(c, _HEX, locale)_isdigit_l(c,locale)_ischartype_l(c, _DIGIT, locale)_islower_l(c,locale)_ischartype_l(c, _LOWER, locale)_isupper_l(c,locale)_ischartype_l(c, _UPPER, locale)_isalpha_l(c,locale)_ischartype_l(c, _ALPHA, locale)__ascii_isdigit_l(c,locale)(_chvalidchk_l(c, _DIGIT, locale))__ascii_isalpha_l(c,locale)(_chvalidchk_l(c, _ALPHA, locale))__ascii_isdigit(c)( __chvalidchk(c, _DIGIT))__ascii_isalpha(c)( __chvalidchk(c, _ALPHA))__chvalidchk(a,b)_chvalidator(a, b)_INC_CTYPE!defined __midl && !defined RC_INVOKEDMB_CUR_MAX_CRT_DEFINE_ASCII_CTYPE_MACROSdefined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL && !defined __cplusplus(-1,255)_In_range_impl_(-1,255)_Char_value + 1(_Char_value + 1)_Pre_count_(_Char_value + 1) _Deref_pre_readonly__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_impl(_Char_value + 1)) _Pre_valid_impl___count_impl(_Char_value + 1)// _INC_CTYPE// !defined __midl && !defined RC_INVOKED// Microsoft C version 2.0 extended ctype macros// >0xFF and SBCS locale// invalid integer inputs that yield undefined behavior.// In the debug CRT, we make all calls through the validation function to catch// directly.// MB_LEN_MAX = 5 in limits.h but we do not include that header here so use 5// (also defined in stdlib.h).// Maximum number of bytes in multi-byte character in the current locale// _pctype directly with signed chars.// Note _locale_pctype array does extend to -127 to support accessing// To avoid undefined behavior, we should check this range for all accesses.// The C Standard specifies valid input to a ctype function ranges from -1 to 255.// Character Classification Macro Definitions// Character Classification Function Declarations// This file declares the narrow character (char) classification functionality.// ctype.h_Mask_LocalePointers_Locale_pctype_array_Char_value_wassertassert(expression)(void)( (!!(expression)) || (_wassert(_CRT_WIDE(#expression), _CRT_WIDE(__FILE__), (unsigned)(__LINE__)), 0) )assertdefined _VCRT_BUILD && !defined _ASSERT_OKNDEBUG// _CRT_HAS_C11// Defines the assert macro and related functionality.// assert.h_Message_File_Line<time.h>png_FILE_ppng_charpppdouble **png_doublepppng_fixed_point **png_fixed_point_pppng_charpppng_const_charpppng_int_16 *short *png_int_16 **short **png_int_16pppng_uint_16pppng_int_32 **png_int_32pppng_uint_32 **unsigned int **png_uint_32pppng_byteppconst double *png_const_doubleppng_doublepconst size_t *png_const_size_tppng_size_tpconst png_fixed_pointconst png_fixed_point *png_const_fixed_point_ppng_fixed_point_ppng_const_charppng_charpconst png_int_16const png_int_16 *png_const_int_16ppng_int_16ppng_const_uint_16ppng_uint_16pconst png_int_32const png_int_32 *png_const_int_32ppng_int_32pconst png_uint_32const png_uint_32 *png_const_uint_32ppng_uint_32ppng_const_byteppng_byteppng_const_voidppng_voidppng_ptrdiff_tpng_size_tpng_int_16PNG_FIXED_EXPORT(type,name,args)PNG_EXPORT(type, name, args);PNG_FP_EXPORT(type,name,args)PNG_RESTRICT__restrictPNG_PRIVATEPNG_USE_RESULTPNG_PEDANTIC_WARNINGS_SUPPORTEDPNG_CALLBACK(type,name,args)type (name) argsPNG_REMOVED(type,name,args,attributes)PNG_EXPORT(type,name,args)PNG_EXPORTA(type, name, args, PNG_EMPTY)PNG_EXPORTA(type,name,args,attributes)PNG_FUNCTION(PNG_EXPORT_TYPE(type), (name), args, PNG_LINKAGE_API attributes)PNG_EXPORT_TYPE(type)PNG_IMPEXP typePNG_FUNCTION(type,name,args,attributes)attributes type name argsPNG_IMPEXPPNG_DLL_IMPORTPNG_DLL_EXPORT__declspec(dllexport)PNGAPIPNGCAPIPNGCBAPIPNGARG(arglist)arglistPNG_CONSTPNGCONF_HPNG_BUILDING_SYMBOL_TABLE!defined(PNG_NO_USE_READ_MACROS) && !defined(PNG_USE_READ_MACROS)PNG_DEFAULT_READ_MACROSPNGARGdefined(_WIN32) || defined(__WIN32__) || defined(__NT__) || defined(__CYGWIN__)defined(PNG_USE_DLL) && defined(PNG_DLL_IMPORT)PNG_FUNCTIONPNG_EXPORT_TYPEPNG_EXPORTAPNG_REMOVEDPNG_CALLBACKPNG_NO_PEDANTIC_WARNINGSdefined(__clang__) && defined(__has_attribute)!defined(PNG_USE_RESULT) && __has_attribute(__warn_unused_result__)!defined(PNG_NORETURN) && __has_attribute(__noreturn__)!defined(PNG_ALLOCATED) && __has_attribute(__malloc__)!defined(PNG_DEPRECATED) && __has_attribute(__deprecated__)!defined(PNG_PRIVATE)__has_extension__has_extension(attribute_unavailable_with_message)__GNUC__ >= 3((__GNUC__ > 3) || !defined(__GNUC_MINOR__) || (__GNUC_MINOR__ >= 1))defined(_MSC_VER) && (_MSC_VER >= 1300)(_MSC_VER >= 1400)PNG_FP_EXPORTPNG_FIXED_EXPORTCHAR_BIT == 8 && UCHAR_MAX == 255INT_MIN == -32768 && INT_MAX == 32767SHRT_MIN == -32768 && SHRT_MAX == 32767UINT_MAX == 65535USHRT_MAX == 65535INT_MIN < -2147483646 && INT_MAX > 2147483646LONG_MIN < -2147483646 && LONG_MAX > 2147483646UINT_MAX > 4294967294UULONG_MAX > 4294967294UPNG_SMALL_SIZE_T(defined(__TURBOC__) && !defined(__FLAT__)) || (defined(_MSC_VER) && defined(MAXSEG_64K))/* PNGCONF_H *//* PNG_BUILDING_SYMBOL_TABLE *//* With PNG_STDIO_SUPPORTED it was possible to use I/O streams that were
 * not necessarily stdio FILE streams, to allow building Windows applications
 * before Win32 and Windows CE applications before WinCE 3.0, but that kind
 * of support has long been discontinued.
 *//* Typedef for floating-point numbers that are converted to fixed-point with a
 * multiple of 100,000, e.g., gamma
 *//* Prior to 1.6.0 libpng offered limited support for Microsoft C compiler
 * implementations of Intel CPU specific support of user-mode segmented address
 * spaces, where 16-bit pointers address more than 65536 bytes of memory using
 * separate 'segment' registers.  The implementation requires two different
 * types of pointer (only one of which includes the segment value.)
 *
 * If required this support is available in version 1.2 of libpng and may be
 * available in versions through 1.5, although the correctness of the code has
 * not been verified recently.
 *//* png_alloc_size_t is guaranteed to be no smaller than size_t, and no smaller
 * than png_uint_32.  Casts from size_t or png_uint_32 to png_alloc_size_t are
 * not necessary; in fact, it is recommended not to use them at all, so that
 * the compiler can complain when something turns out to be problematic.
 *
 * Casts in the other direction (from png_alloc_size_t to size_t or
 * png_uint_32) should be explicitly applied; however, we do not expect to
 * encounter practical situations that require such conversions.
 *
 * PNG_SMALL_SIZE_T must be defined if the maximum value of size_t is less than
 * 4294967295 - i.e. less than the maximum value of png_uint_32.
 *//* Compiler specific tests for systems where size_t is known to be less than
    * 32 bits (some of these systems may no longer work because of the lack of
    * 'far' support; see above.)
    *//* libpng needs to know the maximum value of 'size_t' and this controls the
 * definition of png_alloc_size_t, below.  This maximum value of size_t limits
 * but does not control the maximum allocations the library makes - there is
 * direct application control of this through png_set_user_limits().
 *//* Prior to 1.6.0, it was possible to disable the use of size_t and ptrdiff_t.
 * From 1.6.0 onwards, an ISO C90 compiler, as well as a standard-compliant
 * behavior of sizeof and ptrdiff_t are required.
 * The legacy typedefs are provided here for backwards compatibility.
 *//* Some typedefs to get us started.  These should be safe on most of the common
 * platforms.
 *
 * png_uint_32 and png_int_32 may, currently, be larger than required to hold a
 * 32-bit value however this is not normally advisable.
 *
 * png_uint_16 and png_int_16 should always be two bytes in size - this is
 * verified at library build time.
 *
 * png_byte must always be one byte in size.
 *
 * The checks below use constants from limits.h, as defined by the ISOC90
 * standard.
 *//* No fixed point APIs *//* A fixed point API. *//* No floating point APIs *//* A floating point API. *//* The C99 "restrict" feature *//* This is a private libpng function *//* The result of the function is new memory *//* This function does not return *//* The result of this function must be checked *//* Use of this function is deprecated *//* PNG_PEDANTIC_WARNINGS *//* not supported *//* __GNUC__ >= 3 *//* __GNUC__.__GNUC_MINOR__ > 3.0 *//* Doesn't work so we use deprecated instead*//* Clang defines both __clang__ and __GNUC__. Check __clang__ first. *//* Support for compiler specific function attributes.  These are used
   * so that where compiler support is available, incorrect use of API
   * functions in png.h will generate compiler warnings.  Added at libpng
   * version 1.2.41.  Disabling these removes the warnings but may also produce
   * less efficient code.
   *//* Support for compiler specific function attributes.  These are used
 * so that where compiler support is available incorrect use of API
 * functions in png.h will generate compiler warnings.
 *
 * Added at libpng-1.2.41.
 *//* Use PNG_REMOVED to comment out a removed interface. *//*empty list*//* ANSI-C (C90) does not permit a macro to be invoked with an empty argument,
 * so make something non-empty to satisfy the requirement:
 *//* In 1.5.2 the definition of PNG_FUNCTION has been changed to always treat
 * 'attributes' as a storage class - the attributes go at the start of the
 * function definition, and attributes are always appended regardless of the
 * compiler.  This considerably simplifies these macros but may cause problems
 * if any compilers both need function attributes and fail to handle them as
 * a storage class (this is unlikely.)
 *//* This forces use of a DLL, disallowing static linking *//* PNG_IMPEXP may be set on the compilation system command line or (if not set)
 * then in an internal header file when building the library, otherwise (when
 * using the library) it is set here.
 *//* Windows *//* System specific discovery.
 * ==========================
 * This code is used at build time to find PNG_IMPEXP, the API settings
 * and PNG_EXPORT_TYPE(), it may also set a macro to indicate the DLL
 * import processing is possible.
 *//* Symbol export
 * =============
 * When building a shared library it is almost always necessary to tell
 * the compiler which symbols to export.  The png.h macro 'PNG_EXPORT'
 * is used to mark the symbols.  On some systems these symbols can be
 * extracted at link time and need no special processing by the compiler,
 * on other systems the symbols are flagged by the compiler and just
 * the declaration requires a special tag applied (unfortunately) in a
 * compiler dependent way.  Some systems can do either.
 *
 * A small number of older systems also require a symbol from a DLL to
 * be flagged to the program that calls it.  This is a problem because
 * we do not know in the header file included by application code that
 * the symbol will come from a shared library, as opposed to a statically
 * linked one.  For this reason the application must tell us by setting
 * the magic flag PNG_USE_DLL to turn on the special processing before
 * it includes png.h.
 *
 * Four additional macros are used to make this happen:
 *
 * PNG_IMPEXP The magic (if any) to cause a symbol to be exported from
 *            the build or imported if PNG_USE_DLL is set - compiler
 *            and system specific.
 *
 * PNG_EXPORT_TYPE(type) A macro that pre or appends PNG_IMPEXP to
 *                       'type', compiler specific.
 *
 * PNG_DLL_EXPORT Set to the magic to use during a libpng build to
 *                make a symbol exported from the DLL.  Not used in the
 *                public header files; see pngpriv.h for how it is used
 *                in the libpng build.
 *
 * PNG_DLL_IMPORT Set to the magic to force the libpng symbols to come
 *                from a DLL - used to define PNG_IMPEXP when
 *                PNG_USE_DLL is set.
 *//* The PNGAPI, PNGCAPI and PNGCBAPI macros were used in versions of libpng
 * prior to 1.8.0 to allow the use of custom calling conventions on x86 systems
 * like DOS, OS/2 and Windows, for interoperability with non-C compilers like
 * the pre-Delphi Borland Pascal and the pre-.NET Visual Basic.  [Deprecated.]
 *//* The PNGARG macro was used in versions of libpng prior to 1.6.0 to protect
 * against legacy (pre ISOC90) compilers that did not understand function
 * prototypes.  [Deprecated.]
 *//* COMPILER SPECIFIC OPTIONS.
 *
 * These options are provided so that a variety of difficult compilers
 * can be used.  Some are fixed at build time (e.g. PNG_API_RULE
 * below) but still have compiler specific implementations, others
 * may be changed on a per-file basis when compiling against libpng.
 *//* This controls optimization of the reading of 16-bit and 32-bit
 * values from PNG files.  It can be set on a per-app-file basis: it
 * just changes whether a macro is used when the function is called.
 * The library builder sets the default; if read functions are not
 * built into the library the macro implementation is forced on.
 *//* backward compatibility only *//* Prior to 1.6.0, it was possible to turn off 'const' in declarations,
 * using PNG_NO_CONST.  This is no longer supported.
 *//* Required for struct tm: *//* Required for the definition of jmp_buf and the declaration of longjmp: *//* Required for the definition of FILE: *//* Library header files.  These header files are all defined by ISOC90; libpng
 * expects conformant implementations, however, an ISOC90 conformant system need
 * not provide these header files if the functionality cannot be implemented.
 * In this case it will be necessary to disable the relevant parts of libpng in
 * the build of pnglibconf.h.
 *
 * Prior to 1.6.0 string.h was included here; the API changes in 1.6.0 to not
 * include this unnecessary header file.
 *//* From libpng 1.6.0 libpng requires an ANSI X3.159-1989 ("ISOC90") compliant C
 * compiler for correct compilation.  The following header files are required by
 * the standard.  If your compiler doesn't provide these header files, or they
 * do not match the standard, you will need to provide/improve them.
 *//* else includes may cause problems *//* pngconf.h - machine-configurable file for libpng
 *
 * libpng version 1.8.0.git
 *
 * Copyright (c) 2018-2025 Cosmin Truta
 * Copyright (c) 1998-2002,2004,2006-2016,2018 Glenn Randers-Pehrson
 * Copyright (c) 1996-1997 Andreas Dilger
 * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * Any machine specific code is near the front of this file, so if you
 * are configuring libpng for a machine, you may want to read the section
 * starting here down to where it starts to typedef png_color, png_text,
 * and png_info.
 */const unsigned charconst unsigned char *const unsigned char **D:/PracticeInCodeQL/libpng/contrib/tools/pngfix.cchar[261]261temp_nameprogoutfilesuffixglobalglobal *--debug"--debug"--max="--max="SKIP_UNSAFE--optimize"--optimize"-o"-o"--out="--out="--suffix="--suffix="--prefix="--prefix="--strip=none"--strip=none"SKIP_NONE--strip=crc"--strip=crc"SKIP_BAD_CRC--strip=unsafe"--strip=unsafe"--strip=unused"--strip=unused"SKIP_UNUSED--strip=transform"--strip=transform"SKIP_TRANSFORM--strip=color"--strip=color"SKIP_COLOR--strip=all"--strip=all"SKIP_ALL-e"-e"outlen%s: output file name too long: %s%s%s
"%s: output file name too long: %s%s%s\n"WRITE_ERRORprefixlensuffixlen%s: output file name too long: %s%s
"%s: output file name too long: %s%s\n"usage_stringUsage: %s {[options] png-file}
"Usage: %s {[options] png-file}\n"const char *[154]char *[154]1232sizeof usage_string(sizeof usage_string)sizeof usage_string[0](sizeof usage_string[0])154(sizeof usage_string)/(sizeof usage_string[0])  Tests, optimizes and optionally fixes the zlib header in PNG files."  Tests, optimizes and optionally fixes the zlib header in PNG files."char[70]  Optionally, when fixing, strips ancillary chunks from the file."  Optionally, when fixing, strips ancillary chunks from the file."char[66]OPTIONS"OPTIONS"  OPERATION"  OPERATION"      By default files are just checked for readability with a summary of the"      By default files are just checked for readability with a summary of the"char[78]      of zlib issues founds for each compressed chunk and the IDAT stream in"      of zlib issues founds for each compressed chunk and the IDAT stream in"char[77]      the file."      the file."    --optimize (-o):"    --optimize (-o):"      Find the smallest deflate window size for the compressed data."      Find the smallest deflate window size for the compressed data."char[69]    --strip=[none|crc|unsafe|unused|transform|color|all]:"    --strip=[none|crc|unsafe|unused|transform|color|all]:"        none (default):   Retain all chunks."        none (default):   Retain all chunks."        crc:    Remove chunks with a bad CRC."        crc:    Remove chunks with a bad CRC."        unsafe: Remove chunks that may be unsafe to retain if the image data"        unsafe: Remove chunks that may be unsafe to retain if the image data"                is modified.  This is set automatically if --max is given but"                is modified.  This is set automatically if --max is given but"                may be cancelled by a later --strip=none."                may be cancelled by a later --strip=none."        unused: Remove chunks not used by libpng when decoding an image."        unused: Remove chunks not used by libpng when decoding an image."char[73]                This retains any chunks that might be used by libpng image"                This retains any chunks that might be used by libpng image"char[75]                transformations."                transformations."        transform: unused+bKGD."        transform: unused+bKGD."        color:  transform+iCCP and cHRM."        color:  transform+iCCP and cHRM."        all:    color+gAMA and sRGB."        all:    color+gAMA and sRGB."      Only ancillary chunks are ever removed.  In addition the tRNS and sBIT"      Only ancillary chunks are ever removed.  In addition the tRNS and sBIT"      chunks are never removed as they affect exact interpretation of the"      chunks are never removed as they affect exact interpretation of the"char[74]      image pixel values.  The following known chunks are treated specially"      image pixel values.  The following known chunks are treated specially"      by the above options:"      by the above options:"        gAMA, sRGB [all]: These specify the gamma encoding used for the pixel"        gAMA, sRGB [all]: These specify the gamma encoding used for the pixel"            values."            values."        cHRM, iCCP [color]: These specify how colors are encoded.  iCCP also"        cHRM, iCCP [color]: These specify how colors are encoded.  iCCP also"            specifies the exact encoding of a pixel value; however, in"            specifies the exact encoding of a pixel value; however, in"char[71]            practice most programs will ignore it."            practice most programs will ignore it."        bKGD [transform]: This is used by libpng transforms.    --max=<number>:"        bKGD [transform]: This is used by libpng transforms."
"    --max=<number>:"char[80]      Use IDAT chunks sized <number>.  If no number is given the IDAT"      Use IDAT chunks sized <number>.  If no number is given the IDAT"      chunks will be the maximum size permitted; 2^31-1 bytes.  If the option"      chunks will be the maximum size permitted; 2^31-1 bytes.  If the option"      is omitted the original chunk sizes will not be changed.  When the"      is omitted the original chunk sizes will not be changed.  When the"      option is given --strip=unsafe is set automatically. This may be"      option is given --strip=unsafe is set automatically. This may be"      cancelled if you know that all unknown unsafe-to-copy chunks really are"      cancelled if you know that all unknown unsafe-to-copy chunks really are"      safe to copy across an IDAT size change.  This is true of all chunks"      safe to copy across an IDAT size change.  This is true of all chunks"      that have ever been formally proposed as PNG extensions."      that have ever been formally proposed as PNG extensions."  MESSAGES"  MESSAGES"      By default the program only outputs summaries for each file."      By default the program only outputs summaries for each file."char[67]    --quiet (-q):"    --quiet (-q):"      Do not output the summaries except for files that cannot be read. With"      Do not output the summaries except for files that cannot be read. With"      two --quiets these are not output either."      two --quiets these are not output either."    --errors (-e):"    --errors (-e):"      Output errors from libpng and the program (except too-far-back)."      Output errors from libpng and the program (except too-far-back)."    --warnings (-w):"    --warnings (-w):"      Output warnings from libpng."      Output warnings from libpng."  OUTPUT"  OUTPUT"      By default nothing is written."      By default nothing is written."    --out=<file>:"    --out=<file>:"      Write the optimized/corrected version of the next PNG to <file>.  This"      Write the optimized/corrected version of the next PNG to <file>.  This"      overrides the following two options"      overrides the following two options"    --suffix=<suffix>:"    --suffix=<suffix>:"      Set --out=<name><suffix> for all following files unless overridden on"      Set --out=<name><suffix> for all following files unless overridden on"      a per-file basis by explicit --out."      a per-file basis by explicit --out."    --prefix=<prefix>:"    --prefix=<prefix>:"      Set --out=<prefix><name> for all the following files unless overridden"      Set --out=<prefix><name> for all the following files unless overridden"      on a per-file basis by explicit --out."      on a per-file basis by explicit --out."      These two options can be used together to produce a suffix and prefix."      These two options can be used together to produce a suffix and prefix."  INTERNAL OPTIONS"  INTERNAL OPTIONS"EXIT CODES"EXIT CODES"  *** SUBJECT TO CHANGE ***"  *** SUBJECT TO CHANGE ***"  The program exit code is value in the range 0..127 holding a bit mask of"  The program exit code is value in the range 0..127 holding a bit mask of"  the following codes.  Notice that the results for each file are combined"  the following codes.  Notice that the results for each file are combined"  together - check one file at a time to get a meaningful error code!"  together - check one file at a time to get a meaningful error code!"    0x01: The zlib too-far-back error existed in at least one chunk."    0x01: The zlib too-far-back error existed in at least one chunk."    0x02: At least one chunk had a CRC error."    0x02: At least one chunk had a CRC error."    0x04: A chunk length was incorrect."    0x04: A chunk length was incorrect."    0x08: The file was truncated."    0x08: The file was truncated."  Errors less than 16 are potentially recoverable, for a single file if the"  Errors less than 16 are potentially recoverable, for a single file if the"  exit code is less than 16 the file could be read (with corrections if a"  exit code is less than 16 the file could be read (with corrections if a"  non-zero code is returned)."  non-zero code is returned)."    0x10: The file could not be read, even with corrections."    0x10: The file could not be read, even with corrections."    0x20: The output file could not be written."    0x20: The output file could not be written."    0x40: An unexpected, potentially internal, error occurred."    0x40: An unexpected, potentially internal, error occurred."  If the command line arguments are incorrect the program exits with exit"  If the command line arguments are incorrect the program exits with exit"  255.  Some older operating systems only support 7-bit exit codes, on those"  255.  Some older operating systems only support 7-bit exit codes, on those"  systems it is suggested that this program is first tested by supplying"  systems it is suggested that this program is first tested by supplying"  invalid arguments."  invalid arguments."DESCRIPTION"DESCRIPTION"  pngfix:"  " PROGRAM_NAME ":"  checks each PNG file on the command line for errors.  By default errors are"  checks each PNG file on the command line for errors.  By default errors are"  not output and the program just returns an exit code and prints a summary."  not output and the program just returns an exit code and prints a summary."  With the --quiet (-q) option the summaries are suppressed too and the"  With the --quiet (-q) option the summaries are suppressed too and the"char[72]  program only outputs unexpected errors (internal errors and file open"  program only outputs unexpected errors (internal errors and file open"  errors)."  errors)."  Various known problems in PNG files are fixed while the file is being read"  Various known problems in PNG files are fixed while the file is being read"  The exit code says what problems were fixed.  In particular the zlib error:"  The exit code says what problems were fixed.  In particular the zlib error:"        "invalid distance too far back""        \"invalid distance too far back\""  caused by an incorrect optimization of a zlib stream is fixed in any"  caused by an incorrect optimization of a zlib stream is fixed in any"  compressed chunk in which it is encountered.  An integrity problem of the"  compressed chunk in which it is encountered.  An integrity problem of the"  PNG stream caused by a bug in libpng which wrote an incorrect chunk length"  PNG stream caused by a bug in libpng which wrote an incorrect chunk length"  is also fixed.  Chunk CRC errors are automatically fixed up."  is also fixed.  Chunk CRC errors are automatically fixed up."  Setting one of the "OUTPUT" options causes the possibly modified file to"  Setting one of the \"OUTPUT\" options causes the possibly modified file to"  be written to a new file."  be written to a new file."  Notice that some PNG files with the zlib optimization problem can still be"  Notice that some PNG files with the zlib optimization problem can still be"  read by libpng under some circumstances.  This program will still detect"  read by libpng under some circumstances.  This program will still detect"  and, if requested, correct the error."  and, if requested, correct the error."  The program will reliably process all files on the command line unless"  The program will reliably process all files on the command line unless"  either an invalid argument causes the usage message (this message) to be"  either an invalid argument causes the usage message (this message) to be"  produced or the program crashes."  produced or the program crashes."  The summary lines describe issues encountered with the zlib compressed"  The summary lines describe issues encountered with the zlib compressed"  stream of a chunk.  They have the following format, which is SUBJECT TO"  stream of a chunk.  They have the following format, which is SUBJECT TO"  CHANGE in the future:"  CHANGE in the future:"     chunk reason comp-level p1 p2 p3 p4 file"     chunk reason comp-level p1 p2 p3 p4 file"  p1 through p4 vary according to the 'reason'.  There are always 8 space"  p1 through p4 vary according to the 'reason'.  There are always 8 space"  separated fields.  Reasons specific formats are:"  separated fields.  Reasons specific formats are:"     chunk ERR status code read-errno write-errno message file"     chunk ERR status code read-errno write-errno message file"     chunk SKP comp-level file-bits zlib-rc compressed message file"     chunk SKP comp-level file-bits zlib-rc compressed message file"char[68]     chunk ??? comp-level file-bits ok-bits compressed uncompress file"     chunk ??? comp-level file-bits ok-bits compressed uncompress file"  The various fields are"  The various fields are"$1 chunk:      The chunk type of a chunk in the file or 'HEAD' if a problem"$1 chunk:      The chunk type of a chunk in the file or 'HEAD' if a problem"               is reported by libpng at the start of the IDAT stream."               is reported by libpng at the start of the IDAT stream."$2 reason:     One of:"$2 reason:     One of:"          CHK: A zlib header checksum was detected and fixed."          CHK: A zlib header checksum was detected and fixed."char[62]          TFB: The zlib too far back error was detected and fixed."          TFB: The zlib too far back error was detected and fixed."          OK : No errors were detected in the zlib stream and optimization"          OK : No errors were detected in the zlib stream and optimization"               was not requested, or was not possible."               was not requested, or was not possible."          OPT: The zlib stream window bits value could be improved (and was)."          OPT: The zlib stream window bits value could be improved (and was)."          SKP: The chunk was skipped because of a zlib issue (zlib-rc) with"          SKP: The chunk was skipped because of a zlib issue (zlib-rc) with"               explanation 'message'"               explanation 'message'"          ERR: The read of the file was aborted.  The parameters explain why."          ERR: The read of the file was aborted.  The parameters explain why."$3 status:     For 'ERR' the accumulated status code from 'EXIT CODES' above."$3 status:     For 'ERR' the accumulated status code from 'EXIT CODES' above."               This is printed as a 2 digit hexadecimal value"               This is printed as a 2 digit hexadecimal value"   comp-level: The recorded compression level (FLEVEL) of a zlib stream"   comp-level: The recorded compression level (FLEVEL) of a zlib stream"               expressed as a string {supfast,stdfast,default,maximum}"               expressed as a string {supfast,stdfast,default,maximum}"$4 code:       The file exit code; where stop was called, as a fairly terse"$4 code:       The file exit code; where stop was called, as a fairly terse"               string {warning,libpng,zlib,invalid,read,write,unexpected}."               string {warning,libpng,zlib,invalid,read,write,unexpected}."   file-bits:  The zlib window bits recorded in the file."   file-bits:  The zlib window bits recorded in the file."$5 read-errno: A system errno value from a read translated by strerror(3)."$5 read-errno: A system errno value from a read translated by strerror(3)."   zlib-rc:    A zlib return code as a string (see zlib.h)."   zlib-rc:    A zlib return code as a string (see zlib.h)."   ok-bits:    The smallest zlib window bits value that works."   ok-bits:    The smallest zlib window bits value that works."$6 write-errno:A system errno value from a write translated by strerror(3)."$6 write-errno:A system errno value from a write translated by strerror(3)."   compressed: The count of compressed bytes in the zlib stream, when the"   compressed: The count of compressed bytes in the zlib stream, when the"               reason is 'SKP'; this is a count of the bytes read from the"               reason is 'SKP'; this is a count of the bytes read from the"               stream when the fatal error was encountered."               stream when the fatal error was encountered."$7 message:    An error message (spaces replaced by _, as in all parameters),"$7 message:    An error message (spaces replaced by _, as in all parameters),"   uncompress: The count of bytes from uncompressing the zlib stream; this"   uncompress: The count of bytes from uncompressing the zlib stream; this"               may not be the same as the number of bytes in the image."               may not be the same as the number of bytes in the image."$8 file:       The name of the file (this may contain spaces)."$8 file:       The name of the file (this may contain spaces)."one_filerccontrolFILE %s -> %s
"FILE %s -> %s\n"<none>"<none>"control *volatile intfile *LIBPNG_ERROR_CODEOOM allocating png_struct"OOM allocating png_struct"OOM allocating info structure"OOM allocating info structure" INFO
" INFO\n"passes END
" END\n"control_initallocatestruct control*file->alloc_ptrfile->idat == NULLfile->idat == ((void *)0)"file->idat == NULL""D:\\PracticeInCodeQL\\libpng\\contrib\\tools\\pngfix.c"file->chunk == NULLfile->chunk == ((void *)0)"file->chunk == NULL"IDAT *unsigned short[19]D:\PracticeInCodeQL\libpng\contrib\tools\pngfix.cunsigned short[50]3523chunk *unsigned short[20]3529get_controlpng_get_error_ptr(png_ptr)control_endUNEXPECTED_ERROR_CODEread callback for 0 bytes"read callback for 0 bytes"file->read_count == 0"file->read_count == 0"(file->status_code & TRUNCATED) == 0(file->status_code & 0x08) == 0"(file->status_code & TRUNCATED) == 0"(file->status_code & TRUNCATED) != 0(file->status_code & 0x08) != 0"(file->status_code & TRUNCATED) != 0"file->state == STATE_CHUNKSfile->state == 1"file->state == STATE_CHUNKS"3174unsigned short[37]3175out_nameallocate_idat3184READ_ERROR_CODEnot a PNG (too short)"not a PNG (too short)"STATE_SIGNATURE229847859252428802303721472230374144023037415112181038086553602187591686656218765824218765834not a PNG (signature)"not a PNG (signature)"unsigned short[28]3201not a PNG (IHDR)"not a PNG (IHDR)"file->read_count == 8"file->read_count == 8"chunk != NULLchunk != ((void *)0)"chunk != NULL"length == sig1 && type == sig2length == (((png_uint_32)(137) << (24)) | ((png_uint_32)(80) << (16)) | ((png_uint_32)(78) << (8)) | ((png_uint_32)(71) << (0))) && type == (((png_uint_32)(13) << (24)) | ((png_uint_32)(10) << (16)) | ((png_uint_32)(26) << (8)) | ((png_uint_32)(10) << (0)))"length == sig1 && type == sig2"idat != NULLidat != ((void *)0)"idat != NULL"idat->idat_index == idat->idat_length"idat->idat_index == idat->idat_length"cur != NULL && cur->count > 0cur != ((void *)0) && cur->count > 0"cur != NULL && cur->count > 0"idat->idat_count == cur->count"idat->idat_count == cur->count"type == png_IDATtype == (((png_uint_32)(73) << (24)) | ((png_uint_32)(68) << (16)) | ((png_uint_32)(65) << (8)) | ((png_uint_32)(84) << (0)))"type == png_IDAT"32503251unsigned short[14]3254unsigned short[31]3291STATE_CHUNKS3300STATE_IDAT3315idatunsigned short[13]3333IDAT_list *curunsigned short[38]3346unsigned short[30]33473352read beyond end of IDAT"read beyond end of IDAT"png_uint_32[16]unsigned int[16]IDAT_INIT_LENGTHpng_byte[2]sizeof chunk->rewrite_buffer(sizeof chunk->rewrite_buffer)sizeof chunk->rewrite_buffer[0](sizeof chunk->rewrite_buffer[0])(sizeof chunk->rewrite_buffer)-
                              (sizeof chunk->rewrite_buffer[0])   "   " %lu 0x%.8x
" %lu 0x%.8x\n"unsigned short[17]3446pending rewrite"pending rewrite"chunk **IDAT **write_crcwarning_handlerLIBPNG_WARNING_CODEerror_handlerread_chunkread beyond IEND"read beyond IEND" %lu
" %lu\n"file_crcnreadnext_lengthnext_typesync_streamSTREAM_ERROR SYNC " SYNC "nused-8~7truncateddamaged PNG stream"damaged PNG stream"get32offsetprocess_chunk  "  " %lu 0x%.8x 0x%.8x
" %lu 0x%.8x 0x%.8x\n"CRC_ERRORbad CRC"bad CRC"bad CRC in critical chunk"bad CRC in critical chunk"skipped: bad CRC"skipped: bad CRC"const globalconst global *file->chunk != NULLfile->chunk != ((void *)0)"file->chunk != NULL"file->chunk->chunk_type == png_IDATfile->chunk->chunk_type == (((png_uint_32)(73) << (24)) | ((png_uint_32)(68) << (16)) | ((png_uint_32)(65) << (8)) | ((png_uint_32)(84) << (0)))"file->chunk->chunk_type == png_IDAT"2824unsigned short[36]2825next_type == png_IDATnext_type == (((png_uint_32)(73) << (24)) | ((png_uint_32)(68) << (16)) | ((png_uint_32)(65) << (8)) | ((png_uint_32)(84) << (0)))"next_type == png_IDAT"IHDR length"IHDR length"204682035255050242052325376225282052347904205234802017616076804390912176599859217152176601574417660158241767112704176713523217671353482896skip_chunkzlib_checkstart_poszlibtest_bits == 15"test_bits == 15"zlib.ok_bits == max_bits"zlib.ok_bits == max_bits"zlib *min_bitsmax_bitsZLIB_TOO_FAR_BACKTOO_FAR_BACKZLIB_STREAM_ENDudigit[5]unsigned short[5]udigit *zlib checksum"zlib checksum"ZLIB_OK[truncated]"[truncated]"test_bits2678invalid distance too far back"invalid distance too far back"unsigned short[25]2711zlib_runzlib->rewrite_offset == 0"zlib->rewrite_offset == 0"zlib->rewrite_offset < chunk->chunk_length"zlib->rewrite_offset < chunk->chunk_length"skipunsigned short[26]2480jcountextra compressed data"extra compressed data"end_checkunsigned short[43]2562zlib_advanceendrc ZLIB_OKin_bytesstate >= 0"state >= 0"unsigned short[11]2257zlib->z.avail_out == 0 || zlib->z.avail_in == 0"zlib->z.avail_out == 0 || zlib->z.avail_in == 0"zlib->z.avail_in == 0 || endrc != ZLIB_OKzlib->z.avail_in == 0 || endrc != 0"zlib->z.avail_in == 0 || endrc != ZLIB_OK"out_bytesbInbOutfile_bitsnew_bits2240xe00x1fZLIB_FATALunsigned short[48]unsigned short[42]2410in_bytes == nbytes || endrc != ZLIB_OKin_bytes == nbytes || endrc != 0"in_bytes == nbytes || endrc != ZLIB_OK"unsigned short[39]2415max_window_bitszlib_init*zlib192&zlib->z1.3.1zlib_resetzlib->state >= 0"zlib->state >= 0"2142zlib_endCHK"CHK"TFB"TFB"OK "OK "OPT"OPT" %s %s %d %d " %s %s %d %d "' ' SKP %s %d %s " SKP %s %d %s "[no_message]"[no_message]"zlib_message[no message]"[no message]": %szlib error: %d (%s) (%s)
": %szlib error: %d (%s) (%s)\n"unexpected "unexpected "zlib_rc"Z_OK""Z_STREAM_END""Z_NEED_DICT""Z_ERRNO""Z_STREAM_ERROR""Z_DATA_ERROR"-4"Z_MEM_ERROR""Z_BUF_ERROR"-6"Z_VERSION_ERROR"Z_*INVALID_RC*"Z_*INVALID_RC*"zlib_flevelUNREACHED"UNREACHED"supfast"supfast"stdfast"stdfast"maximum"maximum"unsigned short[10]2018COMPILER BUG"COMPILER BUG"process_IDATfile->idat != NULL && file->chunk != NULLfile->idat != ((void *)0) && file->chunk != ((void *)0)"file->idat != NULL && file->chunk != NULL"1896cmpextra uncompressed data"extra uncompressed data"IDAT: uncompressed data too small"IDAT: uncompressed data too small"nbytesndigitsunexpectedZLIB_ERROR_CODEcould not uncompress IDAT"could not uncompress IDAT"rechunk_lengthidat->idat_index == idat->idat_length && idat->idat_length == cur->lengths[count]"idat->idat_index == idat->idat_length && idat->idat_length == cur->lengths[count]"cur != idat->idat_list_tail"cur != idat->idat_list_tail"cur != NULLcur != ((void *)0)"cur != NULL"const IDAT_listconst IDAT_list *unsigned short[82]181818251827unsigned short[12]1849IDAT_init17691770*idat1787IDAT_end1750process_iTXtchunk != NULL && file->idat == NULLchunk != ((void *)0) && file->idat == ((void *)0)"chunk != NULL && file->idat == NULL"1671INVALID_ERROR_CODEiTXt chunk length"iTXt chunk length"process_zTXt_iCCP1642too short"too short"setposcurrent_typechunk_init1560*chunkchunk_endchunk_messagecalc_image_sizepdIHDR: colour type"IHDR: colour type"invalid_bit_depthIHDR: bit depth"IHDR: bit depth"file->widthfile->heightIHDR: width"IHDR: width"IHDR: height"IHDR: height"IHDR: compression method"IHDR: compression method"IHDR: filter method"IHDR: filter method"image_digitsudigit[2]unsigned short[2]row_widthudigit[3]unsigned short[3]row_bytespwdigitsIHDR: interlace method"IHDR: interlace method"file->image_digits >= 1 && file->image_digits <= 5"file->image_digits >= 1 && file->image_digits <= 5"unsigned short[51]1500crc_read_manyread_4write_byteWRITE_ERROR_CODEwrite byte"write byte"skip_12reskip"reskip"reread_4reread_bytereread"reread"read_bytefile read"file read"EINTREDOMTRUNCATEDgetposfile_setpos"fsetpos"file_getpos"fgetpos"type_messagestop_invalidstopHEAD"HEAD" ERR %.2x %s " ERR %.2x %s "FILE_ERRORtype_septype_nametype_char!abcdefghijklmnopqrstuvwxyz56789"!abcdefghijklmnopqrstuvwxyz56789"96@ABCDEFGHIJKLMNOPQRSTUVWXYZ01234"@ABCDEFGHIJKLMNOPQRSTUVWXYZ01234"log_errorfile_init*fileidat_varcodechunk_varpuwhatalloc_ptrallocfile_name != NULLfile_name != ((void *)0)"file_name != NULL"unsigned short[18]1028wb"wb"file_endoutput write error"output write error"emit_errorlibpng warning:"libpng warning:"libpng error:"libpng error:"zlib error:"zlib error:"read failure:"read failure:"write error"write error"unexpected error:"unexpected error:"INVALID (internal error):"INVALID (internal error):"%s: %s %s [%s]
"%s: %s %s [%s]\n"strcode"warning"libpng"libpng""zlib""unexpected"INVALID"INVALID"emit_string\%.3o"\\%.3o"skip_chunk_type194615705619515310081951550976195155105916441671684915200164908236816491005441649100612171127603217166499841716666624171666672347841281732837376179201732855296173285539917328554121732855416174483046417496145922124817496358401749635924186227097645875201866858496186687641618668765311879048192188343910418834557441883455820188376678422784188378956818837896831933770752193378739219337874681934622720194561934642176193464226019348848641766419349025281934902610195067904019507015681950701684195094118419509608961950960965global_init*globalglobal_endIDAT_list_extendIDAT_list*malloc(IDAT_list_size(NULL, length))malloc(IDAT_list_size(((void *)0), length))*nextIDAT_list_end*IDAT_listIDAT_list_sizesizeof *listsizeof list->lengthssizeof *list - sizeof list->lengthssizeof list->lengths[0]IDAT_list_init*listchunk_type_valid2097152538968064538968096PNG_U32(32,32,0,32)3755999199~PNG_U32(32,32,0,32)5221332790x1f1f1f1f-522133280~0x1f1f1f1f377283401610779525760x404040401090519040109477888010947955201094795585PNG_U32(65,65,65,65)41943040016384004210688006400421075200421075226PNG_U32(25,25,25,26)0xe0e0e0e0crc_init_4png_uint_32[256]unsigned int[256]167772150xffffffcrc_one_byteclearclear_seed25960691040x9abcdef0uarb_printsizeof (udigit)sizeof (unsigned long)%lu"%lu"uarb_printx0x%x"0x%x"%.4x"%.4x"0x0"0x0"uarb_cmpuarb_shiftcarryright_shift >= 1 && right_shift <= 15strtailIDAT_listadigitsbdigitsinoutright_shift"right_shift >= 1 && right_shift <= 15"305tempuarb_mult32a_digits > 0"a_digits > 0"290uarb_mult_digitout_digitsuarb_add32uarb_incuarb_copyodigitsuarb_setuarbcuarbudigitheaderextra_byteszcksumok_bitsuncompressed_digitsuncompressed_bytescompressed_digitscompressed_bytesrewrite_offsetidat_lengthidat_indexidat_countidat_curidat_list_tailidat_list_headrewrite_bufferrewrite_lengthchunk_typechunk_lengthchunk_data_poswrite_countdata_posjmpbufimage_byteswrite_errnoread_errnostatus_codeidat_cacheidat_maxquietoptimize_zlibwarningslengthscrc_tableCRC_INITCLEAR(object)clear(&(object), sizeof (object))UDIGITS(unum)((sizeof unum)/(sizeof (udigit))SAFE_TO_COPY(chunk)(((chunk) & PNG_U32(0,0,0,32)) != 0)CRITICAL(chunk)(((chunk) & PNG_U32(32,0,0,0)) == 0)sig2PNG_U32( 13, 10, 26, 10)sig1PNG_U32(137, 80, 78, 71)(PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))PNG_32b(b,s)((png_uint_32)(b) << (s))aligncast(type,value)((void*)(value))constcast(type,value)((type)(value))ZLIB_CONSTPROGRAM_NAME"pngfix"implies(x,y)assert(!(x) || (y))defined(PNG_READ_SUPPORTED) && defined(PNG_EASY_ACCESS_SUPPORTED) && (defined(PNG_READ_DEINTERLACE_SUPPORTED) || defined(PNG_READ_INTERLACING_SUPPORTED))/* vi: set textwidth=80 shiftwidth=3 softtabstop=-1 expandtab: *//* PNG_SETJMP_SUPPORTED *//* No setjmp support *//* PNG_READ_SUPPORTED && PNG_EASY_ACCESS_SUPPORTED *//* No read support *//* Consider the prefix/suffix options *//* else this takes precedence *//* NYI *//* To help debugging problems: *//* if at least one file is processed *//*NYI*//* ANSI C-90 limits strings to 509 characters, so use a string array: *//* Although control_init can return a failure code the structure is always
    * initialized, so control_end can be used to accumulate any status codes.
    *//* Make sure to read to the end of the file: *//* NOTE: this skips asking libpng to return either version of
            * the image row, but libpng still reads the rows.
            *//* Remove any limits on the size of PNG files that can be read,
          * without this we may reject files based on built-in safety
          * limits.
          *//* This is not really expected. *//* Read a PNG, return 0 on success else an error (status) code; a bit mask as
    * defined for file::status_code as above.
    *//* This wraps file_init(&control::file) and simply returns the result from
    * file_init.
    *//* chunk *//* This just returns the (file*).  The chunk and idat control structures
    * don't always exist.
    *//* Bundle the file and an uninitialized chunk and IDAT control structure
 * together to allow implementation of the chunk/IDAT allocate routine.
 *//* increments chunk_write *//* Write one byte *//* conditioning *//* This is the last byte so reset chunk_read for the next
                      * chunk and move the input file to the position after the
                      * *next* chunk header if required.
                      *//* Entered at the end of a non-IDAT chunk and at the end of
                      * the IDAT stream.  The rewrite should have been cleared.
                      *//* fake out the increment below *//* for the new chunk *//* Write another IDAT chunk.  Call rechunk_length to
                      * calculate the length required.
                      *//* The IDAT stream is written without a call to read_chunk
                   * until the end is reached.  rechunk_length() calculates the
                   * length of the output chunks.  Control gets to this point at
                   * the end of an *output* chunk - the length calculated by
                   * rechunk_length.  If this corresponds to the end of the
                   * input stream stop writing IDAT chunks, otherwise continue.
                   *//* This must happen before the chunk_end below: *//* The CRC is written at:
                *
                *    chunk_write == chunk_length+8..chunk_length+11
                *
                * so 8 to 11.  The CRC is not (yet) conditioned.
                *//* If the byte must be rewritten handle that here *//* Read the byte from the stream. *//* The index is always that of the next byte, the rest of
                      * the information is always the current IDAT chunk and the
                      * current list.
                      *//* And skip 12 bytes to the next chunk data *//* Zero length IDAT chunks are permitted, so the length
                         * here may be 0.
                         *//* This is an internal error - read beyond the end of
                            * the pre-calculated stream.
                            *//* Move on to the next IDAT_list: *//* NOTE: IDAT_list::count here, not IDAT_list::length *//* Advance one chunk *//* Read an IDAT byte from the input stream of IDAT chunks.
                      * Because the IDAT stream can be re-chunked this stream is
                      * held in the struct IDAT members.  The chunk members, in
                      * particular chunk_length (and therefore the length local)
                      * refer to the output chunk.
                      *//* Write the chunk data, normally this just comes from
                * the file.  The only exception is for that part of a
                * chunk which is zlib data and which must be rewritten,
                * and IDAT chunks which can be completely
                * reconstructed.
                *//* NOTE: the arithmetic below overflows and gives a large positive
             * png_uint_32 value until the whole chunk data has been written.
             *//* Set up for write, notice that repositioning the input stream
                * is only necessary if something is to be read from it.  Also
                * notice that for the IDAT stream this must only happen once -
                * on the first IDAT - to get back to the start of the list and
                * this is done inside process_IDAT:
                *//* IHDR: checked above *//* Forces a header read *//* The signature has been written, the tail call to read_callback
                * below (it's just a goto to the start with a decent compiler)
                * will read the IHDR header ahead and validate it.
                *//* The header has been written.  If this is really the signature
             * that's all that is required and we can go to normal chunk
             * processing.
             *//* The chunk_ fields describe a chunk that must be written, or hold the
       * signature.  Write the header first.  In the signature case this
       * rewrites the signature.
       *//* And start writing the new chunk. *//* Do the initialization that was not done before. *//* Complete the read of a chunk; as a side effect this also instantiates
       * a chunk control structure and sets the file length/type/data_pos fields
       * for the *NEXT* chunk header.
       *
       * NOTE: at an IDAT any following IDAT chunks will also be read and the
       * next_ fields will refer to the chunk after the last IDAT.
       *
       * NOTE: read_chunk only returns when it has read a chunk that must now be
       * written.
       *//* This is the signature case; for IDAT and other chunks these values will
       * be overwritten when read_chunk is called below.
       *//* Retrieve previous state (because the read callbacks are made pretty much
    * byte-by-byte in the sequential reader prior to 1.7).
    *//* The position of the data must be stored too *//* The first chunk must be a well formed IHDR (this could be relaxed to
          * use the checks in process_chunk, but that seems unnecessary.)
          *//* Else write it (this is the initialization of write_count, prior to
          * this it contains CLEAR garbage.)
          *//* The callback always reads ahead by 8 bytes - the signature or chunk header
    * - these bytes are stored in chunk_length and chunk_type.  This block is
    * executed once for the signature and once for the first chunk right at the
    * start.
    *//* libpng should always ask for at least one byte *//* For the chunk be *WRITTEN* *//* Return 'count' bytes to libpng in 'buffer' *//* Read callback - this is where the work gets done to check the stream before
 * passing it to libpng
 *//* This returns a file* from a png_struct in an implementation specific way. *//* Control gets to here if the stream seems invalid or damaged in some
    * way.  Either there was a problem reading all the expected data (this
    * chunk's data, its CRC and the length and type of the next chunk) or the
    * next chunk length/type are invalid.  Notice that the cases that end up
    * here all correspond to cases that would otherwise terminate the read of
    * the PNG file.
    *//* IEND *//* Adjust the read count back to the correct value for this
                   * chunk.
                   *//* do not read beyond IEND *//* CRC read from file *//* else it was truncated *//* Start the read_crc calculation with the chunk type, then read to the end
    * of the chunk data (without processing it in any way) to check that it is
    * all there and calculate the CRC.
    *//* After IEND file::type is set to 0, if libpng attempts to read
    * more data at this point this is a bug in libpng.
    *//* On entry file::data_pos must be set to the position of the first byte
    * of the chunk data *and* the input file must be at this position.  This
    * routine (via process_chunk) instantiates a chunk or IDAT control structure
    * based on file::length and file::type and also resets these fields and
    * file::data_pos for the chunk after this one.  For an IDAT chunk the whole
    * stream of IDATs will be read, until something other than an IDAT is
    * encountered, and the file fields will be set for the chunk after the end
    * of the stream of IDATs.
    *
    * For IEND the file::type field will be set to 0, and nothing beyond the end
    * of the IEND chunk will have been read.
    *//* Control gets to here if when 0x7fffffff bytes (plus 8) have been read,
       * ok, treat this as a damaged stream too:
       *//* This catches up with the circular buffer which gets filled above
          * while checking a chunk header.  This code is slightly tricky - if
          * the chunk_type is IEND the buffer will never be used, if it is not
          * the code will always read ahead exactly 8 bytes and pass this on to
          * process_chunk.  So the invariant that IEND leaves the file position
          * after the IEND CRC and other chunk leave it after the *next* chunk
          * header is not broken.
          *//* Not valid, keep going. *//* Examine the 8 bytes for a valid chunk header. *//* or, nused &= 7 ;-) *//* Prevent overflow *//* Need 8 bytes *//* A match on the CRC; for IEND this is sufficient, but for anything
             * else expect a following chunk header.
             *//* Ignore the recorded chunk length, proceed through the data looking for
       * a leading sequence of bytes that match the CRC in the following four
       * bytes.  Each time a match is found check the next 8 bytes for a valid
       * length, chunk-type pair.
       *//* else completely truncated *//* Return to the start of the chunk data *//* The stream seems to be messed up, attempt to resync from the current chunk
    * header.  Executes stop on a fatal error, otherwise calls process_chunk.
    *//* Read a 32-bit value from an 8-byte circular buffer (used only below).
    *//* This is the generic code to skip the current chunk; simply jump to the
    * next one.
    *//* Control reaches this point if the chunk must be skipped.  For chunks other
    * than IDAT this means that the zlib compressed data is fatally damaged and
    * the chunk will not be passed to libpng.  For IDAT it means that the end of
    * the IDAT stream has not yet been reached and we must handle the next
    * (IDAT) chunk.  If the LZ data in an IDAT stream cannot be read 'stop' must
    * be used to halt parsing of the PNG.
    *//* First pass: *//* Ancillary chunks that require further processing: *//* This validates all the fields, and calls stop_invalid if
             * there is a problem.
             *//* Read all the IHDR information and validate it. *//* Read this now and update the control structure with the information
          * it contains.  The header is validated completely to ensure this is a
          * PNG.
          *//* Do per-type processing, note that if this code does not return from the
    * function the chunk will be skipped.  The rewrite is cancelled here so that
    * it can be set in the per-chunk processing.
    *//* Record the 'next' information too, now that the original values for
    * this chunk have been copied.  Notice that the IDAT chunks only make a
    * copy of the position of the first chunk, this is fine - process_IDAT does
    * not need the position of this chunk.
    *//* The chunk length must be updated for process_IDAT *//*chunk*//* The chunk may still be skipped if problems are detected in the LZ data,
    * however the LZ data check requires a chunk.  Handle this by instantiating
    * a chunk unless an IDAT is already instantiated (IDAT control structures
    * instantiate their own chunk.)
    *//* Check for other 'skip' cases and handle these; these only apply to
    * ancillary chunks (and not tRNS, which should probably have been a critical
    * chunk.)
    *//* NOTE: this cannot be reached for IEND because it is critical. *//* This will cause an IEND with a bad CRC to stop *//* Ignore the bad CRC  *//* The behavior is set by the 'skip' setting; if it is anything other
       * than SKIP_BAD_CRC ignore the bad CRC and return the chunk, with a
       * corrected CRC and possibly processed, to libpng.  Otherwise skip the
       * chunk, which will result in a fatal error if the chunk is critical.
       *//* The basic structure seems correct but the CRC may not match, in this
    * case assume that it is simply a bad CRC, either wrongly calculated or
    * because of damaged stream data.
    *//* Called when the chunk data has been read, next_length and next_type
    * will be set for the next chunk (or 0 if this is IEND).
    *
    * When this routine returns, chunk_length and chunk_type will be set for the
    * next chunk to write because if a chunk is skipped this return calls back
    * to read_chunk.
    *//* The three routines read_chunk, process_chunk and sync_stream can only be
 * called via a call to read_chunk and only exit at a return from process_chunk.
 * These routines could have been written as one confusing large routine,
 * instead this code relies on the compiler to do tail call elimination.  The
 * possible calls are as follows:
 *
 * read_chunk
 *    -> sync_stream
 *       -> process_chunk
 *    -> process_chunk
 *       -> read_chunk
 *       returns
 *//* The strategy here is to run a regular libpng PNG file read but examine the
 * input data (from the file) before passing it to libpng so as to be aware of
 * the state we expect libpng to be in.  Warning and error callbacks are also
 * intercepted so that they can be quieted and interpreted.  Interpretation
 * depends on a somewhat risky string match for known error messages; let us
 * hope that this can be fixed in the next version of libpng.
 *
 * The control structure is pointed to by the libpng error pointer.  It contains
 * that set of structures which must persist across multiple read callbacks,
 * which is pretty much everything except the 'zlib' control structure.
 *
 * The file structure is instantiated in the caller of the per-file routine, but
 * the per-file routine contains the chunk and IDAT control structures.
 *//***************************** LIBPNG CALLBACKS *******************************//* zlib initialization failed - skip the chunk *//* The loop guarantees this *//* inflateReset2 failed *//* A fatal error; this happens if a too-far-back error was
                   * hiding a more serious error, zlib_advance has already
                   * output a zlib_message.
                   *//* success *//*stream error*//* Output the error that wasn't output before: *//* This happens when the stream really is damaged and it
                      * contains a distance code that addresses bytes before
                      * the start of the uncompressed data.
                      *//*if 16*//* Optimize window bits or fix a too-far-back error.  min_bits and
       * max_bits have been set appropriately, ok_bits records the bit value
       * known to work.
       *//* Unrecoverable error; skip the chunk; a zlib_message has already
             * been output.
             *//*expected*//* Truncated stream; unrecoverable, gets converted to ZLIB_FATAL *//* cksum is set if there is an error in the zlib header checksum
             * calculation in the original file (and this may be the only reason
             * a rewrite is required).  We can't rely on the file window bits in
             * this case, so do the optimization anyway.
             *//* The trivial case where the stream is ok and optimization was
                * not requested.
                *//* too far back error *//* The first run using the existing window bits. *//*window bits*//* First test the existing (file) window bits: *//* Record the start of the LZ data to allow a re-read. *//* Check the stream of zlib compressed data in either idat (if given) or (if
    * not) chunk.  In fact it is zlib_run that handles the difference in reading
    * a single chunk and a list of IDAT chunks.
    *
    * In either case the input file must be positioned at the first byte of zlib
    * compressed data (the first header byte).
    *
    * The return value is true on success, including the case where the zlib
    * header may need to be rewritten, and false on an unrecoverable error.
    *
    * In the case of IDAT chunks 'offset' should be 0.
    *//* global function; not a member function *//* The extra bytes in the chunk are handled now by adjusting the chunk
       * length to exclude them; the zlib data is always stored at the end of
       * the PNG chunk (although clearly this is not necessary.)  zlib_advance
       * has already output a warning message.
       *//* At the end of the compressed data and Z_STREAM_END was not seen. *//* Terminate the list at the current position, reducing the
                   * length of the last IDAT too if required.
                   *//* There may be extra chunks; if there are and one of them is
                   * not zero length output the 'extra data' message.  Only do
                   * this check if errors are being output.
                   *//* stop *//* for the next time *//* Skip CRC and next IDAT header *//* Process each IDAT_list in turn; the caller has left the stream
       * positioned at the start of the first IDAT chunk data.
       *//* 'rewrite_offset' is the offset of the LZ data within the chunk, for
       * IDAT it should be 0:
       *//* The 'extra_bytes' field is set by zlib_advance if there is extra
    * compressed data in the chunk it handles (if it sees Z_STREAM_END before
    * all the input data has been used.)  This function uses the value to update
    * the correct chunk length, so the problem should only ever be detected once
    * for each chunk.  zlib_advance outputs the error message, though see the
    * IDAT specific check below.
    *//* Like zlib_advance but also handles a stream of IDAT chunks. *//* A rewrite is required *//* At the end of the stream update the chunk with the accumulated
    * information if it is an improvement:
    *//* Update the running total of input bytes consumed *//* while (input bytes) *//* Keep going, the loop will terminate when endrc is no longer set to
       * ZLIB_OK or all the input bytes have been consumed; meanwhile keep
       * adding input bytes.
       *//* Keep a running count of output byte produced: *//* for (output bytes) *//* Control gets here when further output is not possible; endrc may
          * still be ZLIB_OK if more input is required.
          *//* switch (inflate rc) *//* The too far back error can be corrected, others cannot: *//* end of stream *//* This is the successful end. *//* Zlib is supposed to have made progress: *//* stop processing *//*unexpected*//* Both avail_out and avail_in are 1 yet zlib returned a code
                * indicating no progress was possible.  This is unexpected.
                *//* Try another input byte *//* Try another output byte. *//* NOTE: expression 3 is only evaluated on 'continue', because of the
       * 'break' at the end of this loop below.
       *//* Initially use Z_NO_FLUSH in an attempt to persuade zlib to look at this
       * byte without confusing what is going on with output.
       *//* Initially *//* For some streams, perhaps only those compressed with 'superfast
       * compression' (which results in a lot of copying) Z_BUF_ERROR can happen
       * immediately after all output has been flushed on the next input byte.
       * This is handled below when Z_BUF_ERROR is detected by adding an output
       * byte.
       *//* After the header bytes *//* If the first byte wasn't changed this indicates an error in
                   * the checksum calculation; signal this by setting 'cksum'.
                   *//* Update the checksum byte if required: *//* The checksum calculation, on the first 11 bits: *//* top 3 bits *//* second header byte *//* rewrite required *//* no change *//* Check against the existing value - it may not need to be
                * changed.  Note that a bogus file_bits is allowed through once,
                * to see if it works, but the window_bits value is set to 15,
                * the maximum.
                *//* first header byte *//* Read nbytes compressed bytes; the stream will be initialized if required.
    * Bytes are always being reread and errors are fatal.  The return code is as
    * follows:
    *
    *    -1: saw the "too far back" error
    *     0: ok, keep going
    *     1: saw Z_STREAM_END (zlib->extra_bytes indicates too much data)
    *     2: a zlib error that cannot be corrected (error message already
    *        output if required.)
    *//* Return the zlib stream window bits required for data of the given size. *//* initialized *//* '0' means use the header; inflateInit2 should always succeed because it
    * does nothing apart from allocating the internal zstate.
    *//* set when a checksum error is detected *//* unset *//* These values are sticky across reset (in addition to the stuff in the
    * first block, which is actually constant.)
    *//* *_out does not need to be set: *//* never changed for this zlib *//* Initialize a zlib_control; the result is true/false *//* initialized, once *//* initialized by zlib_init *//* Reinitializes a zlib with a different window_bits *//* This is a zlib read error; the chunk will be skipped.  For an IDAT
          * stream this will also cause a fatal read error (via stop()).
          *
          * SUMMARY FORMAT:
          *
          * IDAT SKP flevel file-bits z-rc compressed message file
          *
          * z-rc is the zlib failure code; message is the error message with
          * spaces replaced by '-'.  The compressed byte count indicates where
          * in the zlib stream the error occurred.
          *//* SUMMARY FORMAT (for a successful zlib inflate):
          *
          * IDAT reason flevel file-bits ok-bits compressed uncompressed file
          *//* optimizing window bits *//* fixing a too-far-back error *//* checksum error *//* stream was read ok *//* Output the summary line now; this ensures a summary line always gets
    * output regardless of the manner of exit.
    *//* Output a message given a zlib rc *//* Return a string for the zlib return code *//* 0 if no change *//* Last return code *//* Count of extra compressed bytes *//* PROTECTED ZLIB INFORMATION: USED BY THE ZLIB ROUTINES *//* Set on a checksum error *//* Set <16 on a successful read *//* window bits from the file *//* GLOBAL ZLIB INFORMATION: SET BY THE ZLIB READ CODE *//* GLOBAL ZLIB INFORMATION: SET BY THE CALLER *//* NOTE: May be NULL *//* ANCESTORS *//* ZLIB CONTROL STRUCTURE *//* Failure to decompress the IDAT stream; give up. *//* Change the state to writing IDAT chunks *//*start*//* Update the chunk length to the correct value for the IDAT chunk: *//* Index into chunk data *//* Count of chunks read in current list *//* Return the stream to the start of the first IDAT chunk; the length
       * is set in the write case below but the input chunk variables must be
       * set (once) here:
       *//* The IDAT stream was successfully uncompressed; see whether it
       * contained the correct number of bytes of image data.
       *//* This is the final IDAT chunk, so run the tests to check for the too far
    * back error and possibly optimize the window bits.  This means going back
    * to the start of the first chunk data, which is stored in the original
    * chunk allocation.
    *//* skip this for the moment *//* The type of the next chunk was recorded in the file control structure by
    * the caller, if this is png_IDAT return 'skip' to the caller.
    *//* And fill in the next IDAT information buffer. *//* Move to the next block *//* We need to first check the entire sequence of IDAT chunks to ensure the
    * stream is in sync.  Do this by building a list of all the chunks and
    * recording the length of each because the length may have been fixed up by
    * sync_stream below.
    *
    * At the end of the list of chunks, where the type of the next chunk is not
    * png_IDAT, process the whole stream using the list data to check validity
    * then return control to the start and rewrite everything.
    *//* Process the IDAT stream, this is the more complex than the preceding
    * cases because the compressed data is spread across multiple IDAT chunks
    * (typically).  Rechunking of the data is not handled here; all this
    * function does is establish whether the zlib header needs to be modified.
    *
    * Initially the function returns false, indicating that the chunk should not
    * be written.  It does this until the last IDAT chunk is passed in, then it
    * checks the zlib data and returns true.
    *
    * It does not return false on a fatal error; it calls stop instead.
    *
    * The caller must have an instantiated (IDAT) control structure and it must
    * have extent over the whole read of the IDAT stream.  For a PNG this means
    * the whole PNG read, for MNG it could have lesser extent.
    *//* If this was the end return the count of the available bytes *//* Add up the remaining bytes.  This can't overflow because the
             * individual lengths are always <= 0x7fffffff, so when we add two
             * of them overflow is not possible.
             *//* the next IDAT in the list *//* The chunk size is the lesser of file->idat_max and the number
       * of remaining bytes.
       *//* rechunking *//* End of this list *//* Return length of the *next* chunk *//* Otherwise rechunk_length is called at the end of a chunk for the length
       * of the next one.
       *//* use the cache *//* use original chunk lengths *//* Return the length for the next IDAT chunk, taking into account
    * rechunking.
    *//* And store this for cleanup (and to check for double alloc or failure to
    * free.)
    *//* Now the chunk.  The allocator calls the initializer of the new chunk and
    * stores the result in file->chunk:
    *//* Initialize the tail to the pre-allocated buffer and set the count to 0
    * (empty.)
    *//* When the chunk is png_IDAT instantiate an IDAT control structure in place
    * of a chunk control structure.  The IDAT will instantiate a chunk control
    * structure using the file alloc routine.
    *
    * NOTE: this routine must only be called from the file alloc routine!
    *//* Regardless of why the IDAT was killed set the state back to CHUNKS (it may
    * already be CHUNKS because the state isn't changed until process_IDAT
    * returns; a stop will cause IDAT_end to be entered in state CHUNKS!)
    *//* NOTE: there is currently no IDAT_reset, so a stream cannot contain more than
 * one IDAT sequence (i.e. MNG is not supported).
 *//* Cache of current chunk length *//* Index of *next* input byte to write *//* And the *current* index into the list *//* Current list entry *//* PROTECTED IDAT INFORMATION: USED BY THE IDAT WRITE CODE *//* *END* of the list of IDAT information *//* START of the list of IDAT information *//* PROTECTED IDAT INFORMATION: SET BY THE IDAT READ CODE *//* IDAT READ/WRITE CONTROL STRUCTURE *//* Ran out of bytes in the compressed case. *//* terminator *//* Skip the translated keyword *//* Skip the language tag (null terminated). *//* compression method *//* nothing to check *//* uncompressed text *//* keyword null terminator *//* Like zTXt but more fields. *//* zTXt and iCCP have exactly the same form - keyword, null, compression
    * method then compressed data.
    *//* The next functions handle special processing for those chunks with LZ data,
 * the data is identified and checked for validity.  If there are problems which
 * cannot be corrected the routines return false, otherwise true (although
 * modification to the zlib header may be required.)
 *
 * The compressed data is in zlib format (RFC1950) and consequently has a
 * minimum length of 7 bytes.
 *//* Specific chunk handling - called for each chunk header, all special chunk
 * processing is initiated in these functions.
 *//* Reset the position to 'chunk_data_pos' - the start of the data for this
    * chunk.  As a side effect the read_count in the file is reset to 8, just
    * after the length/type header.
    *//* magic *//* This is probably wrong for the excess IDATs case, because then libpng
       * whines about too many of them (apparently in some cases erroneously)
       * when the header is read.
       *//* This may return png_IDAT for errors detected (late) in the header; that
    * includes any inter-chunk consistency check that libpng performs.  Assume
    * that if the chunk_type is png_IDAT and the file write count is 8 this is
    * what is happening.
    *//* Guess the actual chunk type that causes a stop() *//* Compressed/uncompressed size information (from the zlib control structure
    * that is used to check the compressed data in a chunk.)
    *//* When a chunk is initialized the file length/type/pos are copied into the
    * corresponding chunk fields and the new chunk is registered in the file
    * structure.  There can only be one chunk at a time.
    *
    * NOTE: this routine must onely be called from the file alloc routine!
    *//* Buffer of new byte values *//* Number of bytes left to change *//* Count of bytes before rewrite. *//* Output CRC (may differ from read_crc) *//* PUBLIC PER-CHUNK INFORMATION: FOR THE CHUNK WRITE CODE *//* From header *//* From header (or modified below) *//* Position of first byte of chunk data *//* This information is filled in by chunk_init from the data in the file
    * control structure, but chunk_length may be changed later.
    *//* PUBLIC PER-CHUNK INFORMATION: USED BY CHUNK READ CODE *//* PUBLIC IDAT INFORMATION: SET BY THE ZLIB CODE *//* PER-CHUNK CONTROL STRUCTURE
 * This structure is instantiated for each chunk, except for the IDAT chunks
 * where one chunk control structure is used for the whole of a single stream of
 * IDAT chunks (see the IDAT control structure below).
 *//* Set row_bytes * image-height to the file image_bytes field *//* As above, but use image_width in place of the pass width: *//* Add row_bytes * pass-height to the file image_bytes field
                   *//* calculate 1+((pw*pd+7)>>3) in row_bytes *//* Interlacing makes the image larger because of the replication of
          * both the filter byte and the padding to a byte boundary.
          *//* rgba *//* ga *//* rgb *//* g *//* Fill in the image_bytes field given the IHDR information, calls stop on
    * error.
    *//* OK *//* Truncated *//* Reads 'length' bytes and updates the CRC, returns true on success, false
    * if the input is truncated.
    *//* CRC handling - read but calculate the CRC while doing so. *//* Read four bytes, returns the number of bytes read successfully and, if all
    * four bytes are read, assigns the result to *pu.
    *//* Derivatives of the read/write functions. *//* Write one byte to the output - this causes a fatal error if the write
    * fails and the read of this PNG file immediately terminates.  Just
    * increments the write count if there is no output file.
    *//* Since the chunks were read before this shouldn't fail: *//* Skip exactly 12 bytes in the input stream - used to skip a CRC and chunk
    * header that has been read before.
    *//* The same but for a four byte quantity *//* Read a byte when an error is not expected to happen because the byte has
    * been read before without error.
    *//* 'TRUNCATED' is used for all cases of failure to read a byte, because of
    * the way libpng works a byte read is never attempted unless the byte is
    * expected to be there, so EOF should not occur.
    *//* unexpected *//* I.e. a regular EOF, no error *//* An error, it doesn't really matter what the error is but it gets
       * recorded anyway.
       *//* Interrupted, try again *//* This is very unexpected; an error message is always output: *//* out of range character *//* Read utility - read a single byte, returns a value in the range 0..255 or EOF
 * on a read error.  In the latter case status_code and read_errno are updated
 * appropriately.
 *//* Get the current position and store it in 'data_pos'.  The corresponding
    * setpos() function is chunk specific because it uses the copy of the
    * position for the specific chunk.
    *//* This is unexpected, so perror it *//* Input file positioning - we jump around in the input file while reading
 * stuff, these wrappers deal with the error handling.
 *//* Error message for a chunk; the chunk name comes from 'type' *//* This only works one strerror at a time, because of the way strerror is
       * implemented.
       *//* not a registered chunk! *//* magic: an IDAT header, produces bogons for too many IDATs *//* Gropes in struct chunk and IDAT *//* need two quiets to stop this. *//* The chunk being read is typically identified by file->chunk or, if this is
    * NULL, by file->type.  This may be wrong if libpng reads ahead, but this
    * only happens with IDAT where libpng reads the header then jumps around
    * finding errors in the previous chunks.  We know that is happening because
    * we are at the start of the IDAT (i.e. no IDAT data has yet been written.)
    *
    * SUMMARY FORMAT (stop):
    *
    * IDAT ERR status code read-errno write-errno message file
    *
    * 'uncompressed' will be 0 if there was a problem in the IHDR.  The errno
    * values are emit_string(strerror(errno)).
    *//* Return control when a PNG file cannot be read. This outputs an 'ERR'
    * summary line too.
    *//* In fact because chunk::chunk_type is validated prior to any call to this
    * function it will always return a-zA-Z, but the extra codes are just there
    * to help in finding internal (programming) errors.  Note that the code only
    * ever considers the low 7 bits of the value (so it is not necessary for the
    * type_name function to mask of the byte.)
    *//* Like emit_error but checks the global 'errors' flag *//* Always output: please give a readable file! *//* Open the files: *//* jmpbuf is garbage: must be set by read_png *//* Initialize a file control structure.  This will open the given files as
    * well.  The status code returned is 0 on success, non zero (using the flags
    * above) on a file open error.
    *//* status code: non-zero on read or write error *//* Accumulate the result codes *//* On some systems 'fclose' deletes the FILE struct (making it
       * inaccessbile).  There is no guarantee that fclose returns an error
       * code from fflush or, indeed, from the FILE error indicator.  There is
       * also no explicit (or clear) guarantee in the standard that anything
       * other than a read or write operation sets the error indicator; fflush
       * is not a read or write operation, so both conditions must be checked
       * to ensure the close succeeded and in ANSI-C conformant code they must
       * be checked before the fclose call.
       *//* If either of the chunk pointers are set end them here, the IDAT structure
    * must be deallocated first as it may deallocate the chunk structure.
    *//* Generic error message routine, takes a 'stop' code but can be used
    * elsewhere.  Always outputs a message.
    *//* Print a string with spaces replaced by '_' and non-printing characters by
    * an octal escape.
    *//* unexpected (internal?) error *//* error in write *//* read failed *//* detected an invalid PNG *//* generic zlib error *//* generic png_error *//* Valid longjmp (stop) codes are: *//* idat: allocate IDAT not chunk *//* Interface to allocate a new chunk or IDAT control structure.  The result
    * is returned by setting one or other of the above variables.  Note that the
    * relevant initializer is called by the allocator function.  The alloc_ptr
    * is used only by the implementation of the allocate function.
    *//* Two pointers used to enable clean-up in the event of fatal errors and to
    * hold state about the parser process (only one of each at present.)
    *//* An IDAT stream is being written *//* Non-IDAT chunks are being written *//* The signature is being written *//* As defined here: *//* Count of bytes written (in the chunk) *//* Count of bytes read (in the chunk) *//* These counts are maintained by the read and write routines below and are
    * reset by the chunk handling code.  They record the total number of bytes
    * read or written for the chunk, including the header (length,type) bytes.
    *//* Running chunk CRC (used by read_chunk) *//* Second word (type or signature end) *//* First word (length or signature start) *//* The following variables are used during reading to record the length, type
    * and data position of the *next* chunk or, right at the start, the
    * signature (in length,type).
    *
    * When a chunk control structure is instantiated these values are copied
    * into the structure and can then be overwritten with the data for the next
    * chunk.
    *//* PROTECTED CHUNK SPECIFIC VARIABLES: USED BY CHUNK CODE *//* Set while reading a PNG *//* If a new one is being written *//* Original PNG file *//* PROTECTED PER-FILE VARIABLES: USED BY THE READ CODE *//* IHDR information *//* Records a write error errno *//* Records a read error errno *//* Set to a bit mask of the following: *//* File specific result codes *//* PUBLIC PER-FILE VARIABLES: SET BY PNG READ CODE *//* Name of output file (if required) *//* PUBLIC PER-FILE VARIABLES: CALLER INITIALIZE *//* PER-FILE CONTROL STRUCTURE *//* Chunks that libpng does not know about (notice that this depends on the
       * list above including all known chunks!)  The decision here depends on
       * whether the safe-to-copy bit is set in the chunk type.
       *//* All other chunks that libpng knows about and affect neither image
       * interpretation nor libpng transforms - chunks that are effectively
       * unused by libpng even though libpng might recognize and store them.
       *//* Other chunks that are used by libpng in image transformations (as
       * opposed to known chunks that have get/set APIs but are not otherwise
       * used.)
       *//* Chunks that affect color interpretation - not used by libpng and rarely
       * used by applications, but technically still required for correct
       * interpretation of the image data:
       *//* Chunks that specify gamma encoding which should therefore only be
       * removed if the user insists:
       *//* Chunks that are treated as, effectively, critical because they affect
       * correct interpretation of the pixel values:
       *//* Never strip critical chunks: *//* Return true if this chunk is to be skipped according to the --strip
    * option.  This code needs to recognize all known ancillary chunks in order
    * to handle the --strip=unsafe option.
    *//* no re-chunking of IDAT *//* Globals *//* Call this once (and only once) to initialize the control *//* The structure is shared across all uses of this global control
       * structure to avoid reallocation between IDAT streams.
       *//* Cache of file IDAT information buffers *//* PUBLIC GLOBAL VARIABLES: USED INTERNALLY BY IDAT READ CODE *//* internal limits/errors encountered *//* write error (this terminates the read) *//* could not read the file *//* truncated but still readable *//* damaged PNG stream (may be fixable) *//* fixed an invalid CRC *//* found a too-far-back error *//* Accumulated status code *//* 0 to perform no re-chunking *//* Everything but tRNS and sBIT *//* Everything but tRNS, sBIT, gAMA and sRGB *//* Chunks only used in transforms *//* Chunks not used by libpng *//* Chunks not safe to copy *//* Chunks with a bad CRC *//* Non-critical chunks to skip *//* various internal tracking *//* don't output summaries *//* Run optimization search *//* print libpng warnings to stderr *//* print file errors to stderr *//* PUBLIC GLOBAL VARIABLES: OWNER INITIALIZE *//* GLOBAL CONTROL STRUCTURE *//* The caller must handle this: *//* arithmetic overflow *//* Insert a new, malloc'ed, block of IDAT information buffers, this
       * one twice as large as the previous one:
       *//* Use the previous cached value if available. *//* Return the size in bytes of an IDAT_list of the given length. *//* Number of entries that are valid *//* Actual length of the array below *//* Linked list *//* Information about a sequence of IDAT chunks, the chunks have been re-synced
 * using sync_stream below and the new lengths are recorded here.  Because the
 * number of chunks is unlimited this is handled using a linked list of these
 * structures.
 *//**************************** CONTROL INFORMATION *****************************//* Subtract 26, handling the overflow which should set the top
    * three bits of each byte.
    *//* Subtract 65 for each 8-bit quantity, this must not overflow
    * and each byte must then be in the range 0-25.
    *//* Remove bit 5 from all but the reserved byte; this means every
    * 8-bit unit must be in the range 65-90 to be valid.  So bit 5
    * must be zero, bit 6 must be set and bit 7 zero.
    *//* Bit whacking approach to chunk name validation that is intended to avoid
    * branches.  The cost is that it uses a lot of 32-bit constants, which might
    * be bad on some architectures.
    *//* This is an alternative to the algorithm used in zlib, which requires four
    * separate tables to parallelize the four byte operations, it only works for
    * a CRC of the first four bytes of the stream, but this is what happens in
    * the parser below where length+chunk-name is read and chunk-name used to
    * initialize the CRC.  Notice that the calculation here avoids repeated
    * conditioning (xor with 0xffffffff) by storing the conditioned value.
    *//* The CRC calculated here *IS* conditioned, the corresponding value used by
 * zlib and the result value is obtained by XORing with CRC_INIT, which is also
 * the first value that must be passed in (for the first byte) to crc_one_byte.
 *//* Copied from unreleased 1.7 code.
 *
 * CRC checking uses a local pre-built implementation of the Ethernet CRC32.
 * This is to avoid a function call to the zlib DLL and to optimize the
 * byte-by-byte case.
 *//* Clear an object to a random value. *//* There are thirty-three bits; the next bit in the sequence is bit-33 XOR
    * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.
    *//* Generate random bytes.  This uses a boring repeatable algorithm and it
 * is implemented here so that it gives the same set of numbers on every
 * architecture.  It's a linear congruential generator (Knuth or Sedgewick
 * "Algorithms") but it comes from the 'feedback taps' table in Horowitz and
 * Hill, "The Art of Electronics" (Pseudo-Random Bit Sequences and Noise
 * Generation.)
 *
 * (Copied from contrib/libtests/pngvalid.c)
 *//* Prints 'num' as a decimal if it will fit in an unsigned long, else as a
    * hexadecimal number.  Notice that the results vary for images over 4GByte
    * in a system dependent way, and the hexadecimal form doesn't work very well
    * in awk script input.
    *
    *
    * TODO: write uarb_div10
    *//* the number is 0 *//* Print 'num' as a hexadecimal number (easier than decimal!) *//* Return true if the uarb is equal to 'val' *//*UNUSED*//* Return -1/0/+1 according as a<b/a==b/a>b *//* The shift may reduce ndigits *//* Bottom bits to top bits of carry *//* Shift inout right by right_shift bits, right_shift must be in the range
    * 1..15
    *//* Because n_digits and val are >0 the following must be true: *//* calculate acc += num * val, 'val' may be any 32-bit value, 'acc' and 'num'
    * may be any value, returns the number of digits in 'acc'.
    *//* So carry is 0 and all the input digits have been consumed. This means
       * that it is possible to skip any remaining digits in acc.
       *//* Else the product is 0 *//* The digits in *acc, *num and val are in the range 0..65535, so the
    * result below is at most (65535*65535)+2*65635 = 65535*(65535+2), which is
    * exactly 0xffffffff.
    *//* Primitive one-digit multiply - 'val' must be 0..65535. Note that this
    * primitive is a multiply and accumulate - the result of *num * val is added
    * to *acc.
    *
    * This is a one-digit multiply, so the product may be up to one digit longer
    * than 'num', however the add to 'acc' means that the caller must ensure
    * that 'acc' is at least one digit longer than this *and* at least one digit
    * longer than the current length of 'acc'.  (Or the caller must otherwise
    * ensure 'adigits' is adequate from knowledge of the values.)
    *//* As above but this works with any 32-bit value and only does 'add' *//* negative result *//* may be 0 *//* This is a signed 32-bit add, except that to avoid overflow the value added
    * or subtracted must be no more than 2^31-65536.  A negative result
    * indicates a negative number (which is an error below).  The size of
    * 'num' should be max(in_digits+1,2) for arbitrary 'add' but can be just
    * in_digits+1 if add is known to be in the range -65535..65535.
    *//* Copy a uarb, may reduce the digit count *//* Set (initialize) 'result' to 'val'.  The size required for 'result' must
    * be determined by the caller from a knowledge of the maximum for 'val'.
    *//* IMPORTANT: only apply this to an array, applied to a pointer the result
    * will typically be '2', which is not useful.
    *//* A 'unum' is an array of these *//* 80-bit number handling - a PNG image can be up to (2^31-1)x(2^31-1) 8-byte
 * (16-bit RGBA) pixels in size; that's less than 2^65 bytes or 2^68 bits, so
 * arithmetic of 80-bit numbers is sufficient.  This representation uses an
 * arbitrary length array of png_uint_16 digits (0..65535).  The representation
 * is little endian.
 *
 * The arithmetic functions take zero to two uarb values together with the
 * number of digits in those values and write the result to the given uarb
 * (always the first argument) returning the number of digits in the result.
 * If the result is negative the return value is also negative (this would
 * normally be an error).
 *//* UNREACHED is a value to cause an assert to fail. Because of the way the
 * assert macro is written the string "UNREACHED" is produced in the error
 * message.
 *//********************************* UTILITIES **********************************//* Is it safe to copy? *//* Is the chunk critical? *//* The 8-byte signature as a pair of 32-bit quantities *//* Constants for known chunk types. *//* Chunk tags (copied from pngpriv.h) *//* Copied from pngpriv.h *//* zlib.h sometimes #defines const to nothing, undo this. *//* We must ensure that zlib uses 'const' in declarations. *//* zlib.h defines the structure z_stream, an instance of which is included
 * in this structure and is required for decompressing the LZ compressed
 * data in PNG files.
 *//* Define the following to use this program against your installed libpng,
 * rather than the one being built here:
 *//* pngfix.c
 *
 * Copyright (c) 2014-2017,2024 John Cunningham Bowler
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * Tool to check and fix the zlib inflate 'too far back' problem.
 * See the usage message for more information.
 */acca_digitsn_digitsin_digitstofromidigits_aligned_recalloc_aligned_realloc_aligned_offset_recalloc_aligned_offset_realloc_aligned_msize_aligned_offset_malloc_aligned_malloc_aligned_free_recalloc_recalloc_baserealloc_realloc_base_msize_msize_basemalloc_malloc_basefree_free_base_expand_callnewhcalloc_calloc_base_Ret1_impl_(__maybenull_impl)"_Ret_maybenull_"__maybenull_impl_Deref_post1_impl_(__notvalid_impl)"_Post_invalid_"__notvalid_impl_Post_writable_byte_size__Post1_impl_(__bytecap_impl(_Size))"_Post_writable_byte_size_"__bytecap_impl(_Size)_Count * _Size(_Count * _Size)_Post1_impl_(__bytecap_impl(_Count * _Size))__bytecap_impl(_Count * _Size)// shared by both <stdlib.h> and <malloc.h>.// The memory allocation library.  These pieces of the allocation library are// corecrt_malloc.h_Block_Alignmentlsearchlfind_lsearch_lsearch_s_lfind_lfind_sqsortbsearchqsort_sbsearch_s_CoreCrtNonSecureSearchSortCompareFunction_CoreCrtSecureSearchSortCompareFunctiondefined __cplusplus && defined _M_CEE_NumOfElements * _SizeOfElements_Inout_updates_bytes_(_NumOfElements * _SizeOfElements)_Pre_bytecap_(_NumOfElements * _SizeOfElements) _Pre_valid_impl_ _Post_valid_impl_"_Inout_updates_bytes_"_Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl(_NumOfElements * _SizeOfElements))__bytecap_impl(_NumOfElements * _SizeOfElements)_Pre_bytecount_(_NumOfElements * _SizeOfElements) _Deref_pre_readonly__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_impl(_NumOfElements * _SizeOfElements)) _Pre_valid_impl___bytecount_impl(_NumOfElements * _SizeOfElements)(*_NumOfElements) * _SizeOfElements((*_NumOfElements) * _SizeOfElements)_Pre_bytecap_((*_NumOfElements) * _SizeOfElements) _Pre_valid_impl_ _Post_valid_impl__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl((*_NumOfElements) * _SizeOfElements))__bytecap_impl((*_NumOfElements) * _SizeOfElements)(*_NumOfElements ) * _SizeOfElements((*_NumOfElements ) * _SizeOfElements)_Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl((*_NumOfElements ) * _SizeOfElements))__bytecap_impl((*_NumOfElements ) * _SizeOfElements)_Pre_bytecap_((*_NumOfElements ) * _SizeOfElements) _Pre_valid_impl_ _Post_valid_impl__Pre_bytecount_((*_NumOfElements) * _SizeOfElements) _Deref_pre_readonly__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_impl((*_NumOfElements) * _SizeOfElements)) _Pre_valid_impl___bytecount_impl((*_NumOfElements) * _SizeOfElements)// defined __cplusplus && defined _M_CEE// __STDC_WANT_SECURE_LIB__// Managed search routines// other user headers named <search.h>.// <stdlib.h> does not include <search.h> to avoid introducing conflicts with// split out so that they may be included by both <stdlib.h> and <search.h>.// Declarations of functions for sorting and searching.  These declarations are// corecrt_search.h_Key_NumOfElements_SizeOfElements_CompareFunction_Context_wsystem_wsearchenv_wsearchenv_s_wputenv_s_wputenv_wgetenv_s_wgetenv_wdupenv_swchar_t **_wsplitpath_s_wsplitpath_wmakepath_wmakepath_s_wfullpath_wcstoui64_l_wcstoui64_wcstoi64_l_wcstoi64_wtoi64_l_wtoi64_ui64tow_ui64tow_s_i64tow_i64tow_s_wtoll_l_wtoll_wtol_l_wtol_wtoi_l_wtoi_wtof_l_wtof_wcstof_lwcstof_wcstold_lwcstold_wcstoull_lwcstoull_wcstoul_lwcstoul_wcstoll_lwcstoll_wcstol_lwcstol_wcstod_lwcstod_ultow_ultow_s_ltow_ltow_s_itow_itow_s_MAX_U64TOSTR_BASE2_COUNT(64 + 1)_MAX_U64TOSTR_BASE8_COUNT(22 + 1)_MAX_U64TOSTR_BASE10_COUNT(20 + 1)_MAX_U64TOSTR_BASE16_COUNT(16 + 1)_MAX_I64TOSTR_BASE2_COUNT_MAX_I64TOSTR_BASE8_COUNT_MAX_I64TOSTR_BASE10_COUNT(1 + 19 + 1)_MAX_I64TOSTR_BASE16_COUNT_MAX_ULTOSTR_BASE2_COUNT(32 + 1)_MAX_ULTOSTR_BASE8_COUNT(11 + 1)_MAX_ULTOSTR_BASE10_COUNT(10 + 1)_MAX_ULTOSTR_BASE16_COUNT(8 + 1)_MAX_LTOSTR_BASE2_COUNT_MAX_LTOSTR_BASE8_COUNT_MAX_LTOSTR_BASE10_COUNT(1 + 10 + 1)_MAX_LTOSTR_BASE16_COUNT_MAX_ITOSTR_BASE2_COUNT_MAX_ITOSTR_BASE8_COUNT_MAX_ITOSTR_BASE10_COUNT_MAX_ITOSTR_BASE16_COUNTpush_macro("_wfullpath")pop_macro("_wfullpath")push_macro("_wdupenv_s")pop_macro("_wdupenv_s")__RETURN_POLICY_VOID_In_z_ wchar_t const*_Filename_VarName_Pre_notnull_ _Post_z__ResultPath_In_opt_z_ wchar_t const*_Drive_Dir_Ext_In_ unsigned long_In_ int_Radix_In_ long_Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__zterm_impl) _Post_valid_impl_"_Deref_post_z_"_Out_ size_t*_RequiredCount_Out_impl_ _Deref_post_opt_z_"_Outptr_result_maybenull_z_"_Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__zterm_impl) _Post_valid_impl_"_Deref_post_opt_z_"*_BufferCount_Outptr_result_buffer_maybenull_(*_BufferCount)_Out_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __cap_impl(*_BufferCount))"_Outptr_result_buffer_maybenull_"__cap_impl(*_BufferCount)_Path_ExtCount(_ExtCount)_Pre_opt_cap_(_ExtCount) _Post_valid_impl_ _Post_z__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(_ExtCount))__cap_impl(_ExtCount)_FilenameCount(_FilenameCount)_Pre_opt_cap_(_FilenameCount) _Post_valid_impl_ _Post_z__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(_FilenameCount))__cap_impl(_FilenameCount)_DirCount(_DirCount)_Pre_opt_cap_(_DirCount) _Post_valid_impl_ _Post_z__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(_DirCount))__cap_impl(_DirCount)_DriveCount(_DriveCount)_Pre_opt_cap_(_DriveCount) _Post_valid_impl_ _Post_z__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(_DriveCount))__cap_impl(_DriveCount)// bases and integer types.// where appropriate), needed for integer-to-string conversions for several// Maximum number of elements, including null terminator (and negative sign// that are declared by both <stdlib.h> and <wchar.h>.// This file declares the wide character (wchar_t) C Standard Library functions// corecrt_wstdlib.h_Name_EnvString_FullPath_String_EndPtr<corecrt_wstdlib.h><corecrt_search.h><corecrt_malloc.h>onexitputenvultoaswabltoaitoagcvtfcvtecvt_sleep_beep_seterrormode_searchenv_searchenv_s_putenv_s_putenvsystem_dupenv_sgetenvwchar_t ***unsigned short ***__p__wenviron__p__environ__p___wargv__p___argv__p___argcgetenv_s_splitpath_s_splitpath_makepath_makepath_s_fullpath_wcstombs_l_wcstombs_s_lwcstombswcstombs_s_wctomb_s_lwctomb_s_wctomb_lwctomb_mbstowcs_l_mbstowcs_s_lmbstowcsmbstowcs_s_mbtowc_lmbtowc_mbstrnlen_l_mbstrnlen_mbstrlen_l_mbstrlen_mblen_lmblen___mb_cur_max_l_func___mb_cur_max_func_gcvt_gcvt_s_fcvt_fcvt_s_ecvt_ecvt_s_ui64toa_ui64toa_s_i64toa_i64toa_s_ultoa_ultoa_s_ltoa_ltoa_s_itoa_itoa_s_strtoui64_l_strtoui64_strtoi64_l_strtoi64_strtoull_lstrtoull_strtoul_lstrtoul_strtoll_lstrtoll_strtol_lstrtol_strtold_lstrtold_strtod_lstrtod_strtof_lstrtof_atoldbl_l_LDOUBLE *_atodbl_l_CRT_DOUBLE *_atoflt_l_CRT_FLOAT *_atoldbl_atodbl_atoflt_atoi64_l_atoll_l_atol_l_atoi_l_atof_l_atoi64atollatolatoiatofrandsrand_rotr64_lrotr_rotr_rotl64_lrotl_rotllldivldivdiv_byteswap_uint64_byteswap_ulong_byteswap_ushort_abs64llabslabsabs_get_fmode_set_fmode_get_wpgmptr_get_pgmptr__p__fmode__p__wpgmptr__p__pgmptr__sys_nerr__sys_errlist_get_doserrno_set_doserrno__doserrno_set_error_mode_get_thread_local_invalid_parameter_handler_set_thread_local_invalid_parameter_handler_get_invalid_parameter_handler_set_invalid_parameter_handler_get_purecall_handler_set_purecall_handlerat_quick_exit_onexitatexit_set_abort_behaviorquick_exit_Exit_exitexit_swab_LDBL12_LONGDOUBLE_CRT_FLOAT_CRT_DOUBLE_LDOUBLElldiv_t_lldiv_tldiv_t_ldiv_tdiv_t_div_t_invalid_parameter_handler_purecall_handler_onexit_tunsigned char[12]ld12unsigned char[10]ldremquotenviron_environsys_nerr_sys_nerrsys_errlist_sys_errlistmin(a,b)(((a) < (b)) ? (a) : (b))max(a,b)(((a) > (b)) ? (a) : (b))_MAX_ENV_wenviron(*__p__wenviron())(*__p__environ())_CRT_V12_LEGACY_FUNCTIONALITY__wargv(*__p___wargv())__argv(*__p___argv())__argc(*__p___argc())_MAX_EXT_MAX_FNAME_MAX_DIR_MAX_DRIVE_MAX_PATH__mb_cur_max(___mb_cur_max_func())___mb_cur_max_func()_CVTBUFSIZE(309 + 40)_PTR_LD(x)((unsigned char*)(&(x)->ld))_CRT_DOUBLE_DECRAND_MAX0x7fff_fmode(*__p__fmode ())_wpgmptr(*__p__wpgmptr())_pgmptr(*__p__pgmptr ())(*__sys_nerr())(__sys_errlist())_doserrno(*__doserrno())_REPORT_ERRMODE_OUT_TO_MSGBOX_OUT_TO_STDERR_OUT_TO_DEFAULTonexit_t_CRT_ONEXIT_T_DEFINED_CALL_REPORTFAULT0x2_WRITE_ABORT_MSG0x1EXIT_FAILUREEXIT_SUCCESS__min(a,b)__max(a,b)_countof__crt_countof_INC_STDLIBdefined __cplusplus && defined _M_CEE_PUREwarning(disable: 6540)defined _CRT_RAND_S || defined _CRTBLD_LDSUPPORTpack(push, 4)push_macro("long")pop_macro("long")push_macro("_fullpath")pop_macro("_fullpath")_CRT_BEST_PRACTICES_USAGEdefined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)warning(disable: 4141)SleepThis function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. See online help for details.char[157]BeepThis function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. See online help for details.char[156]SetErrorModeThis function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode instead. See online help for details.char[164]_In_z_ char const*_In_opt_z_ char const*_Out_writes_opt_z_(_Size) char_Out_writes_(_MaxCount)_Dest_Source_Out_writes_opt_(_MaxCount)_Out_writes_opt_z_(_Size) wchar_t_Out_writes_z_(_MaxCount)_Out_writes_opt_z_(_MaxCount)_Func_Buf1_Buf2_SizeInBytes_DigitCount_DstBuf_FractionalDigitCount_PtDec_PtSign_Duration_Frequency_PtNumOfCharConverted_Dst_DstSizeInBytes_Src_MaxCountInBytes_SizeConverted_MbCh_WCh_SizeInWords_SrcBuf_DstCh_SrcCh_SrcSizeInBytes_In_reads_or_z_opt_(_SrcSizeInBytes)_In_opt_ _When_(_String_length_(_Curr_) < (_SrcSizeInBytes), _Pre_z_) _When_(_String_length_(_Curr_) >= (_SrcSizeInBytes), _Pre1_impl_(__count_impl(_SrcSizeInBytes)))"_In_reads_or_z_opt_"_String_length_(_Curr_) >= (_SrcSizeInBytes)_Pre1_impl_(__count_impl(_SrcSizeInBytes))__count_impl(_SrcSizeInBytes)_String_length_(_Curr_) < (_SrcSizeInBytes)"This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details.""This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details.""This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."_Inout_updates_z_(_SizeInBytes)_Pre_cap_(_SizeInBytes) _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl)"_Inout_updates_z_"_Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(_SizeInBytes))__cap_impl(_SizeInBytes)*_PtNumOfCharConverted_Out_writes_bytes_to_opt_(_DstSizeInBytes,*_PtNumOfCharConverted)_Pre_opt_bytecap_(_DstSizeInBytes) _Post_valid_impl_ _Post_bytecount_(*_PtNumOfCharConverted)"_Out_writes_bytes_to_opt_"(*_PtNumOfCharConverted)_Post1_impl_(__bytecount_impl(*_PtNumOfCharConverted)) _Post_valid_impl___bytecount_impl(*_PtNumOfCharConverted)_Pre_opt_bytecap_(_DstSizeInBytes)_Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(_DstSizeInBytes))"_Pre_opt_bytecap_"__bytecap_impl(_DstSizeInBytes)_Pre_opt_cap_(_MaxCount) _Post_valid_impl__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(_MaxCount))_Out_opt_ size_t*_Out_writes_bytes_opt_(_Size) char_Pre_cap_(_MaxCount) _Post_valid_impl__Out_writes_opt_(_Size) char_Post_z_ wchar_t_In_reads_or_z__In_ _When_(_String_length_(_Curr_) < (_MaxCount), _Pre_z_) _When_(_String_length_(_Curr_) >= (_MaxCount), _Pre1_impl_(__count_impl(_MaxCount)))"_In_reads_or_z_"_String_length_(_Curr_) >= (_MaxCount)_Pre1_impl_(__count_impl(_MaxCount))__count_impl(_MaxCount)_String_length_(_Curr_) < (_MaxCount)_Pre_opt_cap_(_SizeInBytes) _Post_valid_impl_ _Post_z__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(_SizeInBytes))*_SizeConverted(_SizeInBytes,*_SizeConverted)_Pre_opt_bytecap_(_SizeInBytes) _Post_valid_impl_ _Post_bytecount_(*_SizeConverted)(*_SizeConverted)_Post1_impl_(__bytecount_impl(*_SizeConverted)) _Post_valid_impl___bytecount_impl(*_SizeConverted)_Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(_SizeInBytes))__bytecap_impl(_SizeInBytes)(5)_Pre_opt_cap_(5) _Post_valid_impl_ _Post_z__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(5))__cap_impl(5)_Out_writes_to_opt_(_SizeInWords,*_PtNumOfCharConverted)_Pre_opt_cap_(_SizeInWords) _Post_valid_impl_ _Post_count_(*_PtNumOfCharConverted)"_Out_writes_to_opt_"_Post_count__Post1_impl_(__count_impl(*_PtNumOfCharConverted)) _Post_valid_impl_"_Post_count_"__count_impl(*_PtNumOfCharConverted)(_SizeInWords)_Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(_SizeInWords))__cap_impl(_SizeInWords)_Pre_opt_cap_(_MaxCount) _Post_valid_impl_ _Post_z__In_ double_Out_ int*return <= _String_length_(_String)_Post_satisfies_(return <= _String_length_(_String))_Post_satisfies_impl_(return <= _String_length_(_String))"_Post_satisfies_"_Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__zterm_impl) _Pre_valid_impl_"_Pre_opt_z_"_In_reads_bytes_opt__Pre_opt_bytecount_(_MaxCount) _Deref_pre_readonly_"_In_reads_bytes_opt_"_Pre_opt_bytecount__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_impl(_MaxCount)) _Pre_valid_impl_"_Pre_opt_bytecount_"__bytecount_impl(_MaxCount)(return <= _String_length_(_String) && return <= _MaxCount) || return == (size_t)-1((return <= _String_length_(_String) && return <= _MaxCount) || return == (size_t)-1)_Post_satisfies_impl_((return <= _String_length_(_String) && return <= _MaxCount) || return == (size_t)-1)return <= _String_length_(_String) || return == (size_t)-1(return <= _String_length_(_String) || return == (size_t)-1)_Post_satisfies_impl_(return <= _String_length_(_String) || return == (size_t)-1)return > 0 && return < MB_LEN_MAXreturn > 0 && return < 5(return > 0 && return < 5)_Post_satisfies_impl_(return > 0 && return < 5)_Post1_impl_(__count_impl(_SizeInBytes)) _Post_valid_impl___count_impl(_SizeInBytes)_Out_impl_ _Deref_post_z_"_Outptr_result_z_"strerror_Inout_updates__Pre_cap_(_SizeInBytes) _Pre_valid_impl_ _Post_valid_impl_"_Inout_updates_"// _INC_STDLIB// Using deprecated twice// The Win32 API SetErrorMode, Beep and Sleep should be used instead.// headers, causing PREfast to fire 6540 here// The functions below have declspecs in their declarations in the Windows// Sizes for buffers used by the getenv/putenv family of functions.// Pointer to wide environment table// Pointer to narrow environment table// legacy access is specifically requested// Deprecated symbol: Do not expose environment global pointers unless// Pointer to table of wide command line arguments// Pointer to table of narrow command line arguments// Pointer to number of command line arguments// max. length of extension component// max. length of file name component// max. length of path component// max. length of drive component// max. length of full pathname// note that the sizes include space for 0-terminator// Sizes for buffers used by the _makepath() and _splitpath() functions.// Path Manipulation// (also defined in ctype.h).// Multibyte String Operations and Conversions// # of digits in max. dp value + slop// ask for more to effect zero padding.)// are only 16 digits of accuracy in a double precision IEEE number, the user may// (This value actually allows 40 additional decimal places; even though there// buffer as is used in the printf support routines.// precision value (?.?e308 in IEEE arithmetic).  We will use the same size// should be at least as long as the number of digits in the largest double// _CVTBUFSIZE is the maximum size for the per-thread conversion buffer.  It// Number to Narrow String Conversions// Narrow String to Number Conversions// push and pop long, which is #defined as __int64 by a spec2k test// _LDSUPPORT// instructions when copying and pushing [long] double values// Structs used to fool the compiler into not generating floating point// Maximum value that can be returned by the rand function:// which cause PREfast to fire 6540.// These functions have declspecs in their declarations in the Windows headers,// Math// These point to the executable module name.// This is non-const for backwards compatibility; do not modify it.// Argument values for _set_error_mode().// Establishes an invalid parameter handler// Establishes a purecall handler// Invalid parameter handler function pointer type// a purecall handler procedure. Never returns normally// Global State (errno, global handlers, etc.)// In pure mode, atexit is the same as atexit_m_appdomain// Attributes not present on previous declaration// Non-ANSI name for compatibility// debug only, has no effect in release// Argument values for _set_abort_behavior().// Argument values for exit()// Exit and Abort// Minimum and maximum macros// The C Standard Library <stdlib.h> header.// stdlib.h_Seed_Shift_Numerator_Denominator_Number_PMode_ErrMsg_Handler_Flags_CodeEWOULDBLOCK140ETXTBSY139ETIMEDOUT138ETIMEEPROTOTYPE136EPROTONOSUPPORT135EPROTO134EOWNERDEAD133EOVERFLOWEOTHER131EOPNOTSUPP130ENOTSUP129ENOTSOCKENOTRECOVERABLEENOTCONNENOSTR125ENOSR124ENOPROTOOPT123ENOMSGENOLINK121ENODATAENOBUFS119ENETUNREACHENETRESET117ENETDOWNEMSGSIZEELOOPEISCONNEINPROGRESSEIDRMEHOSTUNREACHEDESTADDRREQECONNRESETECONNREFUSED107ECONNABORTED106ECANCELEDEBADMSGEALREADYEAFNOSUPPORTEADDRNOTAVAILEADDRINUSEEDEADLOCKEDEADLKSTRUNCATEEILSEQEINVAL_SECURECRT_ERRCODE_VALUES_DEFINEDENOTEMPTY41ENOSYS40ENOLCK39ENAMETOOLONG38EPIPEEMLINKEROFSESPIPEENOSPCEFBIGENOTTYEMFILEENFILEEISDIRENOTDIRENODEVEXDEVEEXISTEBUSYEFAULTEACCESEAGAINECHILDEBADFENOEXECE2BIGENXIOEIOESRCHENOENTEPERM_INC_ERRNO_CRT_NO_POSIX_ERROR_CODES// _INC_ERRNO// _CRT_NO_POSIX_ERROR_CODES// POSIX Supplement// Support EDEADLOCK for compatibility with older Microsoft C versions// Error codes used in the Secure CRT functions// Error codes// System error numbers for use with errno and errno_t.// errno.hwcsstrwcsrchrwcschrstrstrstrrchrstrchrmemsetmemmovememcpymemcmpmemchrreturn != NULLreturn != ((void *)0)_Ret_range_(_Str, _Str + _String_length_(_Str) - 1)_Str_Str + _String_length_(_Str) - 1_Ret_range_(_Str,_Str + _String_length_(_Str) - 1)_Ret_range_impl_(_Str,_Str + _String_length_(_Str) - 1)"_Ret_range_"_Out_writes_bytes_all__Out_writes_bytes_to_(_Old_(_Size), _Old_(_Size))"_Out_writes_bytes_all_"_Old_(_Size)(_Old_(_Size),_Old_(_Size))_Pre_bytecap_(_Old_(_Size)) _Post_valid_impl_ _Post_bytecount_(_Old_(_Size))(_Old_(_Size))_Post1_impl_(__bytecount_impl(_Old_(_Size))) _Post_valid_impl___bytecount_impl(_Old_(_Size))_Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl(_Old_(_Size)))__bytecap_impl(_Old_(_Size))(unsigned char*)_Dst_Iter__Post_satisfies_(((unsigned char*)_Dst)[_Iter_] == _Val)((unsigned char*)_Dst)[_Iter_] == _Val(((unsigned char*)_Dst)[_Iter_] == _Val)_Post_satisfies_impl_(((unsigned char*)_Dst)[_Iter_] == _Val)(_Dst)_Out_range_(==, _Dst)(==,_Dst)_Out_range_impl_(==,_Dst)_Pre_opt_bytecount_(_Size) _Deref_pre_readonly__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_impl(_Size)) _Pre_valid_impl___bytecount_impl(_Size)_Out_writes_bytes_all_opt__Out_writes_bytes_to_opt_(_Old_(_Size), _Old_(_Size))"_Out_writes_bytes_all_opt_"_Pre_opt_bytecap_(_Old_(_Size)) _Post_valid_impl_ _Post_bytecount_(_Old_(_Size))_Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(_Old_(_Size)))memmove_s_Pre_bytecount_(_Size) _Deref_pre_readonly__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_impl(_Size)) _Pre_valid_impl__Post_satisfies_(((unsigned char*)_Dst)[_Iter_] == ((unsigned char*)_Src)[_Iter_])((unsigned char*)_Dst)[_Iter_] == ((unsigned char*)_Src)[_Iter_](((unsigned char*)_Dst)[_Iter_] == ((unsigned char*)_Src)[_Iter_])_Post_satisfies_impl_(((unsigned char*)_Dst)[_Iter_] == ((unsigned char*)_Src)[_Iter_])memcpy_s// __midl// <string.h> functionality that is implemented in the VCRuntime.// vcruntime_string.h_SubStr_Val_Buf<vcruntime_string.h>void *constconst rsize_tconst void *const_Expr_val_Destination != NULL_Destination != ((void *)0)_Source != NULL_Source != ((void *)0)_DestinationSize >= _SourceSize_CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE_CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(expr,errorcode){ int _Expr_val=!!(expr); if (!(_Expr_val)) { errno = errorcode; _invalid_parameter_noinfo(); return errorcode; } }_CRT_MEMCPY_S_INLINEstatic __inline!defined RC_INVOKED && !defined __midl && __STDC_WANT_SECURE_LIB___SourceSize(_SourceSize)_Pre_opt_bytecount_(_SourceSize) _Deref_pre_readonly__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_impl(_SourceSize)) _Pre_valid_impl___bytecount_impl(_SourceSize)_DestinationSize(_DestinationSize,_SourceSize)_Pre_opt_bytecap_(_DestinationSize) _Post_valid_impl_ _Post_bytecount_(_SourceSize)_Post1_impl_(__bytecount_impl(_SourceSize)) _Post_valid_impl_(_DestinationSize)_Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(_DestinationSize))__bytecap_impl(_DestinationSize)// Unreachable, but required to suppress /analyze warnings:// Inline definitions of memcpy_s and memmove_s// corecrt_memcpy_s.h_Destination<corecrt_memcpy_s.h>memicmpmemccpy_memicmp_l_memicmp!defined RC_INVOKED && __STDC_WANT_SECURE_LIB__defined __cplusplus && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORYdefined __cplusplus && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY_Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(_Size))_Out_writes_bytes_opt__Pre_opt_bytecap_(_Size) _Post_valid_impl__memccpy"_Out_writes_bytes_opt_"// !__midl// !defined RC_INVOKED && __STDC_WANT_SECURE_LIB__// headers named <memory.h>.// does not include <memory.h> to avoid introducing conflicts with other user// so that they may be included by both <string.h> and <memory.h>.  <string.h>// The buffer (memory) manipulation library.  These declarations are split out// corecrt_memory.hwcsicollwcsuprwcslwrwcssetwcsrevwcsnsetwcsnicmpwcsicmpwcsdup_wcsnicoll_l_wcsnicoll_wcsncoll_l_wcsncoll_wcsicoll_l_wcsicoll_wcscoll_lwcscoll_wcsxfrm_lwcsxfrm_wcsupr_l_wcsupr_s_l_wcsupr_wcsupr_s_wcslwr_l_wcslwr_s_l_wcslwr_wcslwr_s_wcsset_wcsset_s_wcsrev_wcsnset_wcsnset_s_wcsnicmp_l_wcsnicmp_wcsicmp_l_wcsicmp__wcserror_s__wcserror_wcserror_s_wcserror_wcstokwcstokwcsspnwcspbrkwcsncpywcsncmpwcsncatwcsnlen_swcsnlenwcslenwcscspnwcscpywcscmpwcscat_wcsdupwcstok_swcsncpy_swcsncat_swcscpy_swcscat_swcswcs_WCSTOK_DEPRECATED_CRT_DEPRECATE_TEXT( "wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK.")__STDC_WANT_SECURE_LIB__ && !defined(__midl)!defined RC_INVOKED && !defined __midldefined _CRT_NON_CONFORMING_WCSTOKdefined _CRT_NON_CONFORMING_WCSTOK && !defined __cplusplusdefined __cplusplus && !defined _CRT_NO_INLINE_DEPRECATED_WCSTOK_Inout_updates_z_(_Size) wchar_t_In_ wchar_t_Inout_updates_z_(_MaxCount)_Out_writes_(_Count) _Post_maybez__In_reads_or_z_(_Count) wchar_t const*_Inout_updates_z_(_Count)_Out_writes_z_(_String_length_(_Source) + 1)_Inout_updates_z_(_String_length_(_Destination) + _String_length_(_Source) + 1)<=(<=,2147483647)_In_range_impl_(<=,2147483647)return < _MaxCount(return < _MaxCount)_Success_impl_(return < _MaxCount)_Pre_cap_(_MaxCount) _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl)_Ret2_impl_(__notnull_impl, __zterm_impl) _Ret_valid_impl_"_Ret_z_""_Inout_z_"_Pre_z_ _Post_z_"_Prepost_z_"(_Count)_In_ _When_(_String_length_(_Curr_) < (_Count), _Pre_z_) _When_(_String_length_(_Curr_) >= (_Count), _Pre1_impl_(__count_impl(_Count)))_String_length_(_Curr_) >= (_Count)_Pre1_impl_(__count_impl(_Count))__count_impl(_Count)_String_length_(_Curr_) < (_Count)_Pre_cap_(_Count) _Post_valid_impl__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(_Count))__cap_impl(_Count)_Prepost_z_ wchar_t_Pre_cap_(_SizeInWords) _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl)_Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(_SizeInWords))_Pre_cap_(_Size) _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl)_Pre_opt_cap_(_SizeInWords) _Post_valid_impl_ _Post_z__Error"_Inout_opt_z_"_Pre_opt_z_ _Post_z_"_Prepost_opt_z_"_Deref_pre_opt_z_ _Deref_post_opt_z_"_Deref_prepost_opt_z_"_Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__zterm_impl) _Pre_valid_impl_"_Deref_pre_opt_z_"_Pre_cap_(_SizeInWords) _Post_valid_impl_ _Post_z__MaxCount <= _String_length_(_Source)_Post_satisfies_(return == _MaxCount)return == _MaxCount(return == _MaxCount)_Post_satisfies_impl_(return == _MaxCount)_MaxCount > _String_length_(_Source)_Post_satisfies_(return == _String_length_(_Source))return == _String_length_(_Source)(return == _String_length_(_Source))_Post_satisfies_impl_(return == _String_length_(_Source))_String_length_(_Source) + 1(_String_length_(_Source) + 1)_Pre_cap_(_String_length_(_Source) + 1) _Post_valid_impl_ _Post_z__Pre_cap_(_Count) _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl)_Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(_String_length_(_Source) + 1))__cap_impl(_String_length_(_Source) + 1)_String_length_(_Destination) + _String_length_(_Source) + 1(_String_length_(_Destination) + _String_length_(_Source) + 1)_Pre_cap_(_String_length_(_Destination) + _String_length_(_Source) + 1) _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl)_Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(_String_length_(_Destination) + _String_length_(_Source) + 1))__cap_impl(_String_length_(_Destination) + _String_length_(_Source) + 1)// Declarations of functions defined in oldnames.lib:// Non-Standard Names// Inline C++ Overloads// !defined RC_INVOKED && !defined __midl// __STDC_WANT_SECURE_LIB__ && !defined(__midl)// Wide-Character <string.h> Functions// Secure Alternatives// by <string.h> and <wchar.h>.// This file declares the wide character (wchar_t) string functionality, shared// corecrt_wstring.h_Delimiter_String1_String2_ErrorNumber_Control<corecrt_wstring.h><corecrt_memory.h>struprstrsetstrrevstrnsetstrnicmpstrlwrstricmpstrcmpistrdup_strxfrm_lstrxfrm_strupr_l_strupr_s_l_strupr_strupr_sstrtokstrspn_strset_strset_s_strrevstrpbrk_strnset_strnset_sstrnlen_sstrnlenstrncpy__strncnt_strncoll_l_strncoll_strnicoll_l_strnicoll_strnicmp_l_strnicmpstrncmpstrncat_strlwr_l_strlwr_s_l_strlwr_strlwr_sstrlen_stricmp_l_stricoll_l_stricoll_stricmp_strerror_s_strerror_strdupstrcspnstrcpy_strcoll_lstrcoll_strcmpistrcmpstrcatstrtok_sstrncpy_sstrncat_sstrerror_sstrcat_sstrcpy_s_NLSCMPERROR_INC_STRING__STDC_WANT_SECURE_LIB__ && !defined __midlpush_macro("strdup")pop_macro("strdup")_Inout_updates_z_(_Size) char_Out_writes_z_(_Size) char_In_reads_or_z_(_Count) char const*_Prepost_z_ char_MaxCount <= _String_length_(_String)_MaxCount > _String_length_(_String)_Post_satisfies_(return == _String_length_(_String))return == _String_length_(_String)(return == _String_length_(_String))_Post_satisfies_impl_(return == _String_length_(_String))_Pre_cap_(_DestinationSize) _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl)_Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(_DestinationSize))__cap_impl(_DestinationSize)_Pre_opt_bytecap_(_MaxCount) _Post_valid_impl__Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(_MaxCount))__bytecap_impl(_MaxCount)_Pre_cap_(_SizeInBytes) _Post_valid_impl_ _Post_z__Post_z_ char// _INC_STRING// RC_INVOKED// currently == INT_MAX// The C Standard Library <string.h> header.// string.h_Str1_Str2PNG_sRGB_PROFILE_CHECKSPNG_sCAL_PRECISIONPNG_Z_DEFAULT_STRATEGYPNG_Z_DEFAULT_NOFILTER_STRATEGYPNG_Z_DEFAULT_COMPRESSIONPNG_ZLIB_VERNUMPNG_ZBUF_SIZEPNG_USER_WIDTH_MAXPNG_USER_HEIGHT_MAXPNG_USER_CHUNK_MALLOC_MAX8000000PNG_USER_CHUNK_CACHE_MAXPNG_TEXT_Z_DEFAULT_STRATEGYPNG_TEXT_Z_DEFAULT_COMPRESSIONPNG_QUANTIZE_RED_BITSPNG_QUANTIZE_GREEN_BITSPNG_QUANTIZE_BLUE_BITSPNG_LINKAGE_FUNCTIONPNG_LINKAGE_DATAPNG_LINKAGE_CALLBACKPNG_INFLATE_BUF_SIZEPNG_IDAT_READ_SIZEPNG_GAMMA_THRESHOLD_FIXEDPNG_API_RULEPNG_zTXt_SUPPORTEDPNG_tEXt_SUPPORTEDPNG_iTXt_SUPPORTEDPNG_WRITE_zTXt_SUPPORTEDPNG_WRITE_tIME_SUPPORTEDPNG_WRITE_tEXt_SUPPORTEDPNG_WRITE_sRGB_SUPPORTEDPNG_WRITE_sPLT_SUPPORTEDPNG_WRITE_sCAL_SUPPORTEDPNG_WRITE_sBIT_SUPPORTEDPNG_WRITE_pHYs_SUPPORTEDPNG_WRITE_pCAL_SUPPORTEDPNG_WRITE_oFFs_SUPPORTEDPNG_WRITE_mDCV_SUPPORTEDPNG_WRITE_iTXt_SUPPORTEDPNG_WRITE_iCCP_SUPPORTEDPNG_WRITE_hIST_SUPPORTEDPNG_WRITE_gAMA_SUPPORTEDPNG_WRITE_eXIf_SUPPORTEDPNG_WRITE_cLLI_SUPPORTEDPNG_WRITE_cICP_SUPPORTEDPNG_WRITE_cHRM_SUPPORTEDPNG_WRITE_bKGD_SUPPORTEDPNG_WRITE_UNKNOWN_CHUNKS_SUPPORTEDPNG_WRITE_TRANSFORMS_SUPPORTEDPNG_WRITE_TEXT_SUPPORTEDPNG_WRITE_OPTIMIZE_CMF_SUPPORTEDPNG_WRITE_GET_PALETTE_MAX_SUPPORTEDPNG_WRITE_COMPRESSED_TEXT_SUPPORTEDPNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTEDPNG_WRITE_ANCILLARY_CHUNKS_SUPPORTEDPNG_USER_LIMITS_SUPPORTEDPNG_TARGET_SPECIFIC_CODE_SUPPORTEDPNG_SIMPLIFIED_WRITE_BGR_SUPPORTEDPNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTEDPNG_SIMPLIFIED_READ_BGR_SUPPORTEDPNG_SIMPLIFIED_READ_AFIRST_SUPPORTEDPNG_READ_UNKNOWN_CHUNKS_SUPPORTEDPNG_READ_TEXT_SUPPORTEDPNG_READ_OPT_PLTE_SUPPORTEDPNG_READ_GET_PALETTE_MAX_SUPPORTEDPNG_READ_COMPRESSED_TEXT_SUPPORTEDPNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTEDPNG_READ_ANCILLARY_CHUNKS_SUPPORTEDPNG_POINTER_INDEXING_SUPPORTEDPNG_INCH_CONVERSIONS_SUPPORTEDPNG_GAMMA_SUPPORTEDPNG_FLOATING_ARITHMETIC_SUPPORTEDPNG_CONSOLE_IO_SUPPORTEDPNG_COLORSPACE_SUPPORTEDPNG_BENIGN_READ_ERRORS_SUPPORTEDPNG_16BIT_SUPPORTED/* PNGLCONF_H *//* end of settings *//* unknown *//* settings *//* end of options *//*#undef PNG_DISABLE_ADLER32_CHECK_SUPPORTED*//*#undef PNG_BENIGN_WRITE_ERRORS_SUPPORTED*//* options *//* Derived from: scripts/pnglibconf/pnglibconf.dfa *//* Machine generated file: DO NOT EDIT *//* pnglibconf.h *//* and license in png.h *//* For conditions of distribution and use, see the disclaimer *//* This code is released under the libpng license. *//* Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson *//* Copyright (c) 2018-2025 Cosmin Truta *//* libpng version 1.8.0.git *//* pnglibconf.h - library build configuration */D:/PracticeInCodeQL/libpng/arm/check.hdefined(__ARM_NEON__) || defined(__ARM_NEON)/* ARM_NEON *//* READ_EXPAND *//* arm/check.h - NEON optimised filter functions
 *
 * Copyright (c) 2018-2022 Cosmin Truta
 * Copyright (c) 2014,2016 Glenn Randers-Pehrson
 * Written by Mans Rullgard, 2011.
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */D:/PracticeInCodeQL/libpng/armD:/PracticeInCodeQL/libpng/intel/check.hPNG_TARGET_ROW_ALIGNMENTPNG_TARGET_IMPLEMENTS_FILTERSPNG_TARGET_CODE_IMPLEMENTATION"intel/intel_init.c"PNG_INTEL_SSE_IMPLEMENTATIONdefined(__SSE4_1__) || defined(__AVX__)defined(__SSSE3__)defined(__SSE2__) || defined(_M_X64) || defined(_M_AMD64) || (defined(_M_IX86_FP) && _M_IX86_FP >= 2)PNG_INTEL_SSE_IMPLEMENTATION > 0/* PNG_INTEL_SSE_IMPLEMENTATION > 0 *//*PNG_TARGET_IMPLEMENTS_EXPAND_PALETTE*//*PNG_TARGET_STORES_DATA*//* We are not actually using AVX, but checking for AVX is the best way we can
    * detect SSE4.1 and SSSE3 on MSVC.
    *//* PNG_INTEL_SSE_IMPLEMENTATION is used in the actual implementation to selecct
 * the correct code.
 *//* intel/check.h - SSE2 optimized filter functions
 *
 * Copyright (c) 2018 Cosmin Truta
 * Copyright (c) 2016-2017 Glenn Randers-Pehrson
 * Written by Mike Klein and Matt Sarett, Google, Inc.
 * Derived from arm/arm_init.c
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */D:/PracticeInCodeQL/libpng/intelD:/PracticeInCodeQL/libpng/mips/msacheck.hdefined(__mips_msa) && (__mips_isa_rev >= 5)__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)PNG_TARGET_MIPS_MSA_SUPPORTED/* !__mips_msa || __mips_isa_rev < 5 *//* !GNUC *//* MIPS MSA support requires gcc >= 4.7: *//* MIPS MSA checks: *//* mips/msacheck.h - MIPS optimised filter functions
 *
 * Copyright (c) 2018-2022 Cosmin Truta
 * Copyright (c) 2014,2016 Glenn Randers-Pehrson
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * This code has been moved from the original in pngpriv.h.
 */D:/PracticeInCodeQL/libpng/mipsD:/PracticeInCodeQL/libpng/mips/check.h"msacheck.h"PNG_TARGET_MIPS_TARGET_CODE_SUPPORTED/* Regardless of the optimization the following must always be the same: *//*... add other checks here (each in its own header file). *//* Check for MSA extensions *//* Unlike other architectures the tests here are written so that they can be
 * extended by the addition of other different ISA extensions.  This could
 * easily be done with all the other architectures too.
 *
 * TODO: move the ISA specific checks to sub-directories so that the code
 * does not taint other implementations.
 *//* mips/check.h - MIPS optimised filter functions
 *
 * Copyright (c) 2024 John Bowler
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */D:/PracticeInCodeQL/libpng/powerpc/check.hdefined(__PPC64__) && defined(__ALTIVEC__) && defined(PNG_READ_SUPPORTED)__VSX__/* __PPC64__ && __ALTIVEC__ && READ *//* __VSX__ *//* PNG_TARGET_ROW_ALIGNMENT *//* PNG_TARGET_IMPLEMENTS_EXPAND_PALETTE *//* PNG_TARGET_STORES_DATA *//* powerpc/check.h - POWERPC optimised filter functions
 *
 * Copyright (c) 2018 Cosmin Truta
 * Copyright (c) 2017 Glenn Randers-Pehrson
 * Written by Vadim Barkov, 2017.
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */D:/PracticeInCodeQL/libpng/powerpcD:/PracticeInCodeQL/libpng/pngtarget.h"powerpc/check.h""mips/check.h""intel/check.h""arm/check.h"PNGTARGET_H!defined(PNG_TARGET_IMPLEMENTS_FILTERS) && !defined(PNG_TARGET_IMPLEMENTS_EXPAND_PALETTE)defined(PNG_TARGET_ROW_ALIGNMENT) && ( PNG_TARGET_ROW_ALIGNMENT > 16 || PNG_TARGET_ROW_ALIGNMENT != (PNG_TARGET_ROW_ALIGNMENT & -PNG_TARGET_ROW_ALIGNMENT))defined(PNG_TARGET_STORES_DATA) || defined(PNG_TARGET_ROW_ALIGNMENT) || defined(PNG_TARGET_IMPLEMENTS_FILTERS) || defined(PNG_TARGET_IMPLEMENTS_EXPAND_PALETTE)/* PNGTARGET_H *//* PNG_TARGET_CODE_IMPLEMENTATION *//* Check PNG_TARGET_ macros are not defined. *//* PNG_TARGET_SPECIFIC_CODE_SUPPORTED *//* Target specific code macro checks. *//* PNG_TARGET_ROW_ALIGNMENT check *//*!power of 2*//*too big*//* Currently only row alignments which are a power of 2 and less than 17 are
 * supported: the current code always aligns to 16 bytes (but may not in the
 * future).
 *//* List all the supported target specific code types here: *//* There is target-specific code *//* Now check the condition above.  Note that these checks consider the composite
 * result of all the above includes; if errors are preceded by warnings about
 * redefinition of the macros those need to be fixed first.
 *//* This is also a convenience to avoid checking in every check.h: *//* checked here as a convenience *//* from pnglibconf.h *//* pngtarget.h - target configuration file for libpng
 *
 * libpng version 1.6.44.git
 *
 * Copyright (c) 2024 John Bowler
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * [[Added to libpng1.8]]
 *
 * This header file discovers whether the target machine has support for target
 * (normally CPU) specific code such as SIMD instructions.  It is included by
 * pngpriv.h immediately after pnglibconf.h to establish compile-time (as
 * opposed to configuration time) requirements for the build of libpng
 *
 * The header only defines a very limited number of macros and it only defines
 * macros; no functions are declared, no types etc.
 *
 * Every target architecture <arch> must have the following file:
 *
 *    <arch>/check.h
 *
 * This file contains checks based on compiler flags to determine if
 * target-specific code can be implemented for this architecture with this set
 * of compiler options.  Define
 *
 *    PNG_TARGET_CODE_IMPLEMENTATION
 *
 * To the quoted relative path name of a single C file to include to obtain the
 * implementation of the the target specific code.  For example:
 *
 *    "arm/arm_init.c"
 *    "intel/intel_init.c"
 *
 * This file will be included by pngsmid.c so the string must be a valid
 * relative path name from that file.  See the file pngsmid.c for the definition
 * of what the C file must do.
 *
 * When it defines PNG_TARGET_CODE_IMPLEMENTATION the check file may also
 * define:
 *
 *    PNG_TARGET_STORES_DATA
 *       If set a void *pointer called "target_data" will be defined in
 *       pngstruct.h.  The initialization code included in pngsimd.c must then
 *       also implement a function to free the data called png_target_free_data,
 *       see png_simd.c.
 *
 *    PNG_TARGET_ROW_ALIGNMENT
 *       If set this defines a power-of-2 required memory alignment for rows
 *       passed to the read "filter".  If not set this defaults to 1.
 *
 *    PNG_TARGET_IMPLEMENTS_FILTERS
 *       If defined this indicates to the system that target specific
 *       implementations of the read filters may be available.  This must be set
 *       to cause a target specific filter implementation to be used.
 *
 *    PNG_TARGET_IMPLEMENTS_EXPAND_PALETTE
 *       If defined this indicates to the system that target specific
 *       code for rgb_do_expand_palette is available.  This must be defined to
 *       cause such implementations to be used.
 *
 * It MUST NOT define these macros unless it also defines
 * PNG_TARGET_CODE_IMPLEMENTATION.  At least one of the 'IMPLEMENTS' macros must
 * be defined; this file will produce an error diagnostic if not.
 *
 * If the check.h file needs to define other macros, for example for use in the
 * PNG_TARGET_CODE_IMPLEMENTATION file macros must have the form:
 *
 *    PNG_TARGET_<ARCH>_...
 *
 * Where ARCH the architecture directory (the directory containing check.h) in
 * upper case.  See pngsimd.c for more information about function definitions
 * used to implement the code.
 */longjmp_setjmp_JBTYPE[16]_JBLENjmp_buf_JUMP_BUFFER_JBTYPESETJMP_FLOAT128_SETJMP_FLOAT128Xmm15Xmm14Xmm13Xmm12Xmm11Xmm10Xmm9Xmm8Xmm7Xmm6SpareFpCsrMxCsrRipR15R14R13R12RdiRsiRbpRspRbxFrameunsigned long long[2]Partsetjmp_JMP_BUF_DEFINED_INC_SETJMP_INC_SETJMPEX(16)_Pre_count_(16) _Deref_pre_readonly__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_impl(16)) _Pre_valid_impl___count_impl(16)// Define the buffer type for holding the state information// D8-D15 FP regs// fp status register// fp control register// x31 stack pointer// x30 link register// x29 frame pointer// x19 -- x28: callee saved registers// D8-D15 VFP/NEON regs// Definitions specific to particular setjmp implementations.// CLR which then can AV or do something very bad.// after jitting, and not unwinding CLR will result in bad state of// be case when CLR stubs are on the stack e.g. function call just// The reason why simple setjmp won't work here is that there may// The C Standard Library <setjmp.h> header.// setjmp.halign_wctime_sconst time_tconst time_t *const time_t *constconst __time64_tconst __time64_t *_wctime_wstrtime_wstrtime_s_wstrdate_wstrdate_s_wctime64_s_wctime64_wctime32_sconst __time32_tconst __time32_t *long *_wctime32_wcsftime_lwcsftime_wasctime_s_wasctimetmtm_isdsttm_ydaytm_wdaytm_yeartm_montm_mdaytm_hourtm_mintm_sec!defined RC_INVOKED && !defined __midl && !defined _INC_WTIME_INL && !defined _CRT_NO_TIME_T_Success_(return != 0) _Ret_writes_z_(9) wchar_t*_Out_writes_z_(9)(9)_Pre_cap_(9) _Post_valid_impl_ _Post_z__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(9))__cap_impl(9)_Ret_writes_z__Ret3_impl_(__notnull_impl, __count_impl(9), __zterm_impl) _Ret_valid_impl_"_Ret_writes_z_"__count_impl(9)_Post_readable_size_(9) wchar_t_SizeInWords >=9_Post_readable_size_(9)_Post1_impl_(__count_impl(9)) _Post_valid_impl__Post_readable_size_(26) wchar_t_In_ __time64_t const*_Time(>=,26)_In_range_impl_(>=,26)(26)_Post1_impl_(__count_impl(26)) _Post_valid_impl___count_impl(26)_Ret3_impl_(__notnull_impl, __count_impl(26), __zterm_impl) _Ret_valid_impl__In_ __time32_t const*return > 0(return > 0)_Success_impl_(return > 0)_In_ struct tm const*// !_USE_32BIT_TIME_T// ^^^ _USE_32BIT_TIME_T ^^^ // vvv !_USE_32BIT_TIME_T vvv //// Inline Definitions// Wide String Time Functions// daylight savings time flag// days since January 1 - [0, 365]// days since Sunday - [0, 6]// years since 1900// months since January - [0, 11]// day of the month - [1, 31]// hours since midnight - [0, 23]// minutes after the hour - [0, 59]// seconds after the minute - [0, 60] including leap second// Types// by <time.h> and <wchar.h>.// This file declares the wide character (wchar_t) time functionality, shared// corecrt_wtime.h_Tm<corecrt_wtime.h>tzsetlocaltime_stm *constgmtime_sctime_stimespec_gettimespec *timespec *const_timespec64 *time_t *time_t *const__time64_t *mktime_mkgmtimelocaltimegmtimedifftimectime_setsystime_getsystime_tzset_timespec64_get_timespec32_get_timespec32 *_time64_time32__time32_t *_strtime_strtime_s_strdate_strdate_s_strftime_lstrftime_mktime64_mktime32_mkgmtime64_mkgmtime32_localtime64_s_localtime64_localtime32_s_localtime32_gmtime64_s_gmtime64_gmtime32_s_gmtime32_difftime64_difftime32_ctime64_s_ctime64_ctime32_s_ctime32clockasctime_sasctime_get_tzname_get_timezone_get_dstbias_get_daylight__tzname__timezone__dstbias__daylighttimespec_timespec64_timespec32clock_ttv_nsectv_secCLK_TCKCLOCKS_PER_SEC_tzname(__tzname())_timezone(*__timezone())_dstbias(*__dstbias())_daylight(*__daylight())TIME_UTC((clock_t)1000)_CRT_USE_CONFORMING_ANNEX_K_TIME_INC_TIME!defined RC_INVOKED && !defined __midl && !defined _INC_TIME_INL && !defined _CRT_NO_TIME_TSetLocalTimeThis function or variable has been superceded by newer library or operating system functionality. Consider using SetLocalTime instead. See online help for details.GetLocalTimeThis function or variable has been superceded by newer library or operating system functionality. Consider using GetLocalTime instead. See online help for details._Post_readable_size_(9) char_SizeInBytes >=9_Pre_cap_(_SizeInBytes) _Post_valid_impl_"This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details.""This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."_Post_readable_size_(26) char_MaxSize(_MaxSize)_Pre_cap_(_MaxSize) _Post_valid_impl_ _Post_z__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(_MaxSize))__cap_impl(_MaxSize)_TimeZone != 0(_TimeZone != 0)_Success_impl_(_TimeZone != 0)_DaylightSavingsBias != 0(_DaylightSavingsBias != 0)_Success_impl_(_DaylightSavingsBias != 0)_Daylight != 0(_Daylight != 0)_Success_impl_(_Daylight != 0)_Deref_ret1_impl_(__notnull_impl_notref) _Deref_ret1_impl_(__zterm_impl)"_Deref_ret_z_"// _INC_TIME// _CRT_USE_CONFORMING_ANNEX_K_TIME// ^^^ _USE_32BIT_TIME_T ^^^ // vvv !_USE_32BIT_TIME_T vvv// Inline Function Definitions// The Win32 API GetLocalTime and SetLocalTime should be used instead.// DesktopCRT Time Functions// AppCRT Time Functions// Standard and Daylight Savings Time time zone names// Difference in seconds between GMT and local time// Offset for Daylight Savings Time// Nonzero if Daylight Savings Time is used// Time Zone and Daylight Savings Time Data and Accessors// The number of clock ticks per second// Nanoseconds - [0, 999999999]// Seconds - >= 0// The C Standard Library <time.h> header.// time.h_Ts_Time1_Time2_Milliseconds_ReturnValue_Index_TimeZone_DaylightSavingsBias_Daylight__declspec(dllexport) void__declspec(dllexport) png_fixed_point__declspec(dllexport) float__declspec(dllexport) png_uint_32__declspec(dllexport) png_alloc_size_t__declspec(dllexport) png_byte__declspec(dllexport) png_uint_16__declspec(dllexport) int__declspec(dllexport) png_int_32__declspec(dllexport) const char *__declspec(dllexport) void *__declspec(dllexport) const png_byte *__declspec(dllexport) png_byte **__declspec(dllexport) size_t__declspec(dllexport) png_info *__declspec(dllexport) png_struct *__declspec(dllexport) jmp_buf*fpreset_scalbf_fpclass_isnan_finite_nextafter_logb_scalb_chgsign_copysign__fpe_flt_rounds__fpecode_control87_fpreset_statusfp_controlfp_s_set_controlfp_controlfp_clearfpFPE_EXPLICITGEN_FPE_EXPLICITGENFPE_STACKUNDERFLOW_FPE_STACKUNDERFLOWFPE_STACKOVERFLOW_FPE_STACKOVERFLOWFPE_SQRTNEG_FPE_SQRTNEGFPE_UNEMULATED_FPE_UNEMULATEDFPE_INEXACT_FPE_INEXACTFPE_UNDERFLOW_FPE_UNDERFLOWFPE_OVERFLOW_FPE_OVERFLOWFPE_ZERODIVIDE_FPE_ZERODIVIDEFPE_DENORMAL_FPE_DENORMALFPE_INVALID_FPE_INVALIDSW_STACKUNDERFLOW_SW_STACKUNDERFLOWSW_STACKOVERFLOW_SW_STACKOVERFLOWSW_SQRTNEG_SW_SQRTNEGSW_UNEMULATED_SW_UNEMULATEDSW_INEXACT_SW_INEXACTSW_UNDERFLOW_SW_UNDERFLOWSW_OVERFLOW_SW_OVERFLOWSW_ZERODIVIDE_SW_ZERODIVIDESW_DENORMAL_SW_DENORMALSW_INVALID_SW_INVALIDCW_DEFAULT_CW_DEFAULTPC_64_PC_64PC_53_PC_53PC_24_PC_24MCW_PC_MCW_PCRC_NEAR_RC_NEARRC_DOWN_RC_DOWNRC_UP_RC_UPRC_CHOP_RC_CHOPMCW_RC_MCW_RCIC_PROJECTIVE_IC_PROJECTIVEIC_AFFINE_IC_AFFINEMCW_IC_MCW_ICEM_INEXACT_EM_INEXACTEM_UNDERFLOW_EM_UNDERFLOWEM_OVERFLOW_EM_OVERFLOWEM_ZERODIVIDE_EM_ZERODIVIDEEM_DENORMAL_EM_DENORMALEM_INVALID_EM_INVALIDMCW_EM_MCW_EMEM_AMBIGUOUS_EM_AMBIGUOUSEM_AMBIGUIOUSLDBL_ROUNDS_LDBL_ROUNDSLDBL_RADIX_LDBL_RADIXDBL_ROUNDS_DBL_ROUNDSDBL_RADIX_DBL_RADIXcontrol87status87_status87clear87_clear87FLT_ROUNDS(__fpe_flt_rounds())_fpecode(*__fpecode())(_RC_NEAR + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)_FPCLASS_PINF_FPCLASS_PN_FPCLASS_PD_FPCLASS_PZ_FPCLASS_NZ_FPCLASS_ND_FPCLASS_NN_FPCLASS_NINF_FPCLASS_QNAN_FPCLASS_SNAN_FPE_MULTIPLE_FAULTS0x8e_FPE_MULTIPLE_TRAPS0x8d0x8c0x8b0x8a0x880x870x860x850x840x830x820x81_DN_SAVE_OPERANDS_FLUSH_RESULTS0x03000000_DN_FLUSH_OPERANDS_SAVE_RESULTS0x02000000_DN_FLUSH0x01000000_DN_SAVE0x00000000_MCW_DN0x000400000x000200000x000100000x000300000x000003000x000002000x000001000x000800000x000000100x000000080x000000040x000000020x000000010x0008001f_EM_AMBIGUIOUSDECIMAL_DIGDBL_DECIMAL_DIGLDBL_TRUE_MINDBL_TRUE_MINLDBL_MIN_EXPDBL_MIN_EXPLDBL_MIN_10_EXPDBL_MIN_10_EXPLDBL_MINDBL_MINLDBL_MAX_EXPDBL_MAX_EXPLDBL_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAXDBL_MAXLDBL_MANT_DIGDBL_MANT_DIGLDBL_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_EPSILONLDBL_DIGDBL_DIGFLT_TRUE_MIN1.401298464e-45FFLT_RADIXFLT_NORMALIZEFLT_MIN_EXP(-125)FLT_MIN_10_EXP(-37)FLT_MIN1.175494351e-38FFLT_MAX_EXPFLT_MAX_10_EXPFLT_MAX3.402823466e+38FFLT_MANT_DIGFLT_GUARDFLT_HAS_SUBNORMFLT_EPSILON1.192092896e-07FFLT_DIGFLT_DECIMAL_DIG4.9406564584124654e-324(-1021)(-307)2.2250738585072014e-3083081.7976931348623158e+3082.2204460492503131e-016FLT_EVAL_METHOD_CRT_MANAGED_FP_DEPRECATE_INC_FLOAT_CRT_MANAGED_FP_NO_DEPRECATE_M_FP_FAST_M_IX86_FP >= 2// _INC_FLOAT// For backwards compatibility with the old spelling// Nonstandard Names for Compatibility// IEEE Recommended Functions// Global variable holding floating point error code// Double deprecation// not supported in managed code.// Note that reading or writing the floating point control or status words is// State Manipulation// Initial Control Word value// positive infinity// positive normal// positive denormal// +0// -0// negative denormal// negative normal// negative infinity// quiet NaN// signaling NaN// On x86 with arch:SSE2, the OS returns these exceptions// raise(SIGFPE);// Floating point error signals and return codes// FP stack underflow// FP stack overflow// Square root of a negative number// Unemulated instruction// Invalid subconditions (_SW_INVALID also set)// save operands and flush results to zero// flush operands to zero and save results//   flush denormal results and operands to zero//   save denormal results and operands// Denormal Control// RISC specific definitions//     projective//     affine// Infinity Control//     24 bits//     53 bits//     64 bits// Precision Control// i386 specific definitions//     chop//     up//     down//     near// Rounding Control// Denormal exception mask (_control87 only)//     invalid//     zero divide//     overflow//     underflow//     inexact (precision)// Interrupt Exception Masks// Abstract User Control Word Mask and bit definitions// New Control Bit that specifies the ambiguity in control word.// Denormal status bit// Invalid// Divide by zero// Overflow// Underflow// Inexact (precision)// Flags// min positive value// exponent radix// min binary exponent// min decimal exponent// min normalized positive value// max binary exponent// max decimal exponent// max value// # of bits in mantissa// type does support subnormal numbers// smallest such that 1.0+LDBL_EPSILON != 1.0// # of decimal digits of precision// smallest such that 1.0+FLT_EPSILON != 1.0// # of decimal digits of rounding precision// smallest such that 1.0+DBL_EPSILON != 1.0// Constants// method, which may in turn invalidate the value of FLT_EVAL_METHOD.// fenv_access/fp_contract #pragmas may alter the actual floating point evaluation// Note that manipulating the floating point behavior using the float_control/// indeterminable.// fastest precision and even mix within a single function, so precision is// If the compiler is invoked with /fp:fast, the compiler is allowed to use the// For x64 and ARM, results are in source precision.// case results are in source precision.// For x86, results are in double precision (unless /arch:sse2 is used, in which// Define the floating point precision used.// (floating point) programs.// Implementation-defined values commonly used by sophisticated numerical// float.h_X_Y_Sign_NewValue_CurrentStateyny1y0jnj1j0truncltgammaltanltanhlsqrtlsinlsinhlscalbnlscalblnlroundlrintlremquolremainderlpowlnexttowardlnextafterlnearbyintlnanlmodfllong double *_F_Ilroundllrintllogbllog2llog1pllog10lloglllroundlllrintllgammalldexplhypotl_hypotlilogblfrexplfmodlfminlfmaxlfmalfloorlfdimlfabslexpm1lexp2lexplerfclerflcoslcoshl_copysignlcopysignl_chgsignlceillcbrtlatanlatanhlatan2lasinlasinhlacoslacoshltanhftanfsqrtfsinhfsinfpowfmodfffloat *logflog10fldexpfhypotffrexpffmodffloorffabsfexpfcoshfcosfceilfatanfatan2fasinfacosf_get_FMA3_enable_set_FMA3_enable_fpclassf_isnanf_finitef_nextafterf_logbftruncftgammafscalbnfscalblnfroundfrintfremquofremainderfnexttowardfnextafterfnearbyintfnanflroundflrintflogbflog2flog1pfllroundfllrintflgammafilogbf_hypotffminffmaxffmaffdimfexp2fexpm1ferfcferff_copysignfcopysignf_chgsignfcbrtfatanhfasinhfacoshf_yn_y1_y0_jn_j1_j0trunctgammascalbnscalblnroundrintremquoremaindernexttowardnextafternearbyintnanmodf_matherr_exception *lroundlrintlogblog2log1pllroundllrintlgammaldexpilogb_hypothypotfrexpfminfmaxfmafloorfdimexpm1exp2erfcerfcopysignceilcbrt_cabsatanhasinhacoshtanhtansqrtsinhsinpowlog10fmodfabsexpcoshcosatan2atanasinacos_fdsin_ldsin_dsin_fdlog_ldlog_dlog_fdpolyconst floatconst float *_ldpolyconst long doubleconst long double *_dpoly_fdnorm_dnorm_fdexp_ldexp_dexp_fdunscale_ldunscale_dunscale_fdscale_ldscale_dscale_fd_int_ld_int_d_int_fdtest_ldtest_dtest_fdpcomp_ldpcomp_dpcomp_fdsign_ldsign_dsign_fdclass_ldclass_dclass_fperrraise_float_const_ldouble_val_float_val_double_valdouble_tfloat_t_complex_exception_Long_double_Double_Float_Sharg2arg1HUGE_LXbig_C_LZero_C_FXbig_C_FZero_C_Xbig_C_Zero_Cconst _float_const_LRteps_C_LEps_C_FRteps_C_FEps_C_Rteps_C_Eps_C_LSnan_C_LNan_C_LInf_C_LDenorm_C_FSnan_C_FNan_C_FInf_C_FDenorm_C_Hugeval_C_Snan_C_Nan_C_Inf_C_Denorm_C_HUGEmatherrPLOSS_PLOSSTLOSS_TLOSSUNDERFLOW_UNDERFLOWOVERFLOW_OVERFLOWSING_SINGDOMAIN_DOMAIN_matherrlisunordered(x,y)(_FPCOMPARE(x, y) == 0)islessgreater(x,y)((_FPCOMPARE(x, y) & (_FP_LT | _FP_GT)) != 0)islessequal(x,y)((_FPCOMPARE(x, y) & (_FP_LT | _FP_EQ)) != 0)isless(x,y)((_FPCOMPARE(x, y) & _FP_LT) != 0)isgreaterequal(x,y)((_FPCOMPARE(x, y) & (_FP_EQ | _FP_GT)) != 0)isgreater(x,y)((_FPCOMPARE(x, y) & _FP_GT) != 0)signbit(_Val)(_CLASSIFY(_Val, _fdsign, _dsign, _ldsign))isnormal(_Val)(fpclassify(_Val) == FP_NORMAL)isnan(_Val)(fpclassify(_Val) == FP_NAN)isinf(_Val)(fpclassify(_Val) == FP_INFINITE)isfinite(_Val)(fpclassify(_Val) <= 0)_FPCOMPARE(_Val1,_Val2)(_CLASSIFY2(_Val1, _Val2, _fdpcomp, _dpcomp, _ldpcomp))fpclassify(_Val)(_CLASSIFY(_Val, _fdclass, _dclass, _ldclass))_CLASSIFY2(_Val1,_Val2,_FFunc,_DFunc,_LDFunc)(_CLASS_ARG((_Val1) + (_Val2)) == 'f' ? _FFunc((float)(_Val1), (float)(_Val2)) : _CLASS_ARG((_Val1) + (_Val2)) == 'd' ? _DFunc((double)(_Val1), (double)(_Val2)) : _LDFunc((long double)(_Val1), (long double)(_Val2)))_CLASSIFY(_Val,_FFunc,_DFunc,_LDFunc)(_CLASS_ARG(_Val) == 'f' ? _FFunc((float)(_Val)) : _CLASS_ARG(_Val) == 'd' ? _DFunc((double)(_Val)) : _LDFunc((long double)(_Val)))_CLASS_ARG(_Val)__pragma(warning(suppress:6334))(sizeof ((_Val) + (float)0) == sizeof (float) ? 'f' : sizeof ((_Val) + (double)0) == sizeof (double) ? 'd' : 'l')_FP_GT_FP_EQ_FP_LT_LSIGN_C(_Val)(((_ldouble_val*)(char*)&(_Val))->_Sh[_L0_C] & _LSIGN)_FSIGN_C(_Val)(((_float_val *)(char*)&(_Val))->_Sh[_F0_C] & _FSIGN)_DSIGN_C(_Val)(((_double_val *)(char*)&(_Val))->_Sh[_D0_C] & _DSIGN)_LHUGE_EXP(int)(_LMAX * 900L / 1000)_FHUGE_EXP(int)(_FMAX * 900L / 1000)_DHUGE_EXP(int)(_DMAX * 900L / 1000)_LSIGN((unsigned short)0x8000)_LMAX((unsigned short)0x7fff)_LMASK_LFRAC((unsigned short)(-1))_FSIGN_FMAX((unsigned short)((1 << (15 - _FOFF)) - 1))_FMASK((unsigned short)(0x7fff & ~_FFRAC))_FFRAC((unsigned short)((1 << _FOFF) - 1))_DSIGN_DMAX((unsigned short)((1 << (15 - _DOFF)) - 1))_DMASK((unsigned short)(0x7fff & ~_DFRAC))_DFRAC((unsigned short)((1 << _DOFF) - 1))_LOFF_LBIAS0x3fe_L3_C_L2_C_L1_C_L0_C_FRND_FOFF_FBIAS0x7e_F1_C_F0_C_DOFF_DBIAS_D3_C_D2_C_D1_C_D0_C_FE_UNDERFLOW_FE_OVERFLOW_FE_INVALID_FE_INEXACT_FE_DIVBYZEROmath_errhandling(MATH_ERRNO | MATH_ERREXCEPT)MATH_ERREXCEPTMATH_ERRNOFP_ILOGBNANFP_ILOGB0(-0x7fffffff - _C2)_C2FP_ZEROFP_SUBNORMAL_DENORMFP_NORMAL_FINITEFP_NAN_NANCODEFP_INFINITE_INFCODENAN(-(float)(INFINITY * 0.0F))HUGE_VALL((long double)INFINITY)HUGE_VALF((float)INFINITY)HUGE_VAL((double)INFINITY)INFINITY((float)(_HUGE_ENUF * _HUGE_ENUF))_HUGE_ENUF1e+300complex_COMPLEX_DEFINED_INC_MATH__assemblerdefined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES && !defined __cplusplusdefined _M_IX86 && _M_IX86_FP < 2 && !defined _M_FP_FAST_UCRT_NEGATIVE_NANdefined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64defined _M_X64 || defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || defined _CORECRT_BUILD_APISET || defined _M_ARM64ECdefined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || defined _M_ARM64ECdefined _M_X64 || defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || defined _M_ARM64EC_N(_N)_Pre_count_(_N) _Deref_pre_readonly__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_impl(_N)) _Pre_valid_impl___count_impl(_N)_Pre_cap_(2) _Pre_valid_impl_ _Post_valid_impl__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(2))__cap_impl(2)(4)_Pre_cap_(4) _Pre_valid_impl_ _Post_valid_impl__Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(4))__cap_impl(4)/* _INC_MATH */// !__assembler// compare _Left and _Right// determine equivalent real type// default is double// determine widened real type// determine combined type// pun float types as integer array// pun floating type as integer array// long double declarations// float declarations// double declarations// IEEE 754 long double properties// IEEE 754 float properties// IEEE 754 double properties// little-endian, 64-bit long doubles// little-endian// little-endian, small long doubles// Values for use as arguments to the _fperrraise function// 0 if not 2's complement// Keep this for backwards compatibility// This operation creates a negative NAN adding a - to make it positive// _HUGE_ENUF*_HUGE_ENUF must overflow// math routines.// for a value returned in case of error by a number of the floating point// Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names// partial loss of precision// total loss of precision// underflow range error// overflow range error// argument singularity// argument domain error// Constant definitions for the exception type passed in the _exception struct// we use the default types.)// (When /fp:fast is used, floating point operations may be consistent, so// are performed using the x87 instruction set and FLT_EVAL_METHOD is 2.// On x86, when not using /arch:SSE2 or greater, floating point operations// __assembler// real and imaginary parts// functions and want type checking.// Definition of the _complex struct to be used by those who use the complex// value to be returned by function// second argument (if any) to function// first argument to function// name of function where error occurred// exception type - see below// when a floating point exception is detected:// Definition of the _exception struct, which is passed to the matherr function// The majority of the C Standard Library <math.h> functionality.// corecrt_math.h_Z_Flag_Except_Complex_value_Qoff_Baseflag_Tab_Ps_Px_Eoff_Pex_Lexp_Xexp<corecrt_math.h>_USE_MATH_DEFINES// this way for modularity (to support the C++ modules feature).// the nonstandard but useful constant definitions.  The headers are divided in// <corecrt_math.h> contains the math library; <corecrt_math_defines.h> contains// The C Standard Library <math.h> header.  This header consists of two parts:// math.hC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/winpackagefamily.hWINAPI_PARTITION_PKG_WER(WINAPI_PARTITION_SERVER == 1)WINAPI_PARTITION_PKG_APPXDEPLOYMENTWINAPI_PARTITION_PKG_MPSSVCWINAPI_PARTITION_PKG_STORAGEWINAPI_PARTITION_PKG_ISCSIWINAPI_PARTITION_PKG_TRAFFICWINAPI_PARTITION_PKG_VSSWINAPI_PARTITION_PKG_CLUSTERWINAPI_PARTITION_PKG_WNVWINAPI_PARTITION_PKG_WINMGMTWINAPI_PARTITION_PKG_ESENTWINAPI_PARTITION_PKG_APPRUNTIMEWINAPI_PARTITION_PKG_CORESETUPWINAPI_PARTITION_PKG_DISMWINAPI_PARTITION_PKG_CMDTOOLSWINAPI_PARTITION_PKG_BOOTABLESKUWINAPI_PARTITION_PKG_REMOTEFSWINAPI_PARTITION_PKG_SECURESTARTUPWINAPI_PARTITION_PKG_PERFCOUNTERWINAPI_PARTITION_PKG_VHDWINAPI_PARTITION_PKG_EVENTLOGSERVICEWINAPI_PARTITION_PKG_WEBSERVICESWINAPI_PARTITION_PKG_WINTRUSTWINAPI_PARTITION_SERVER(WINAPI_FAMILY == WINAPI_FAMILY_SERVER)_INC_WINPACKAGEFAMILYdefined(_MSC_VER) && !defined(MOFCOMP_PASS)_MSC_VER >= 1200warning(disable:4001)/* !_INC_WINPACKAGEFAMILY *//* 
 * PARTITIONS for feature packages. Each package might be active for one or more editions
 *//*
 * PARTITIONS based on packages are each #undef'ed below, and then will be #define-ed
 * to be either 1 or 0 or depending on the active WINAPI_FAMILY.
 */// defined(_MSC_VER) && !defined(MOFCOMP_PASS)/* nonstandard extension 'single line comment' was used *//*

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    winpackagefamily.h

Abstract:

    API family partitioning based on packages.

*/C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/sharedC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/winapifamily.h<winpackagefamily.h>_WINAPI_DEPRECATED_DECLARATION__declspec(deprecated("This API cannot be used in the context of the caller's application type."))WINAPI_FAMILY_PARTITION(Partitions)(Partitions)WINAPI_PARTITION_PHONEWINAPI_PARTITION_PHONE_APPWINAPI_PARTITION_SYSTEM(WINAPI_FAMILY == WINAPI_FAMILY_SYSTEM || WINAPI_FAMILY == WINAPI_FAMILY_SERVER)WINAPI_PARTITION_GAMES(WINAPI_FAMILY == WINAPI_FAMILY_GAMES || WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP)(WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)WINAPI_PARTITION_PC_APP(WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP || WINAPI_FAMILY == WINAPI_FAMILY_PC_APP)WINAPI_PARTITION_APP(WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP || WINAPI_FAMILY == WINAPI_FAMILY_PC_APP || WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)WINAPI_PARTITION_DESKTOP(WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP)WINAPI_FAMILY_DESKTOP_APPWINAPI_FAMILY_APPWINAPI_FAMILY_PC_APPWINAPI_FAMILY_SERVERWINAPI_FAMILY_SYSTEM_INC_WINAPIFAMILYWINAPI_FAMILY != WINAPI_FAMILY_DESKTOP_APP && WINAPI_FAMILY != WINAPI_FAMILY_PC_APP && WINAPI_FAMILY != WINAPI_FAMILY_PHONE_APP && WINAPI_FAMILY != WINAPI_FAMILY_SYSTEM && WINAPI_FAMILY != WINAPI_FAMILY_GAMES && WINAPI_FAMILY != WINAPI_FAMILY_SERVERWINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)(100 == 100)(100 == 100 || 100 == 2 || 100 == 3)/* !_INC_WINAPIFAMILY */// WINAPIFAMILY_PARTITION(WINAPI_PARTITION_APP) && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)/*
 * For compatibility with Windows 8 header files, the following
 * symbol is temporarily conditionally #define'd.  Additional symbols
 * like this should be not defined in winapifamily.h, but rather should be
 * introduced locally to the header files of the component that needs them.
 *//*
 * Macro used to #define or typedef a symbol used for selective deprecation
 * of individual methods of a COM interfaces that are otherwise available
 * for a given set of partitions.
 *//*
 * Header files use the WINAPI_FAMILY_PARTITION macro to assign one or
 * more declarations to some group of partitions.  The macro chooses
 * whether the preprocessor will emit or omit a sequence of declarations
 * bracketed by an #if/#endif pair.  All header file references to the
 * WINAPI_PARTITION_* values should be in the form of occurrences of
 * WINAPI_FAMILY_PARTITION(...).
 *
 * For example, the following usage of WINAPI_FAMILY_PARTITION identifies
 * a sequence of declarations that are part of both the Windows Desktop
 * Partition and the Windows-Phone-Specific Store Partition:
 *
 *     #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_PHONE_APP)
 *     ...
 *     #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP | WINAPI_PARTITION_PHONE_APP)
 *
 * The comment on the closing #endif allow tools as well as people to find the
 * matching #ifdef properly.
 *
 * Usages of WINAPI_FAMILY_PARTITION may be combined, when the partitition definitions are
 * related.  In particular one might use declarations like
 * 
 *     #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 *
 * or
 *
 *     #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_PHONE_APP)
 *
 * Direct references to WINAPI_PARTITION_ values (eg #if !WINAPI_FAMILY_PARTITION_...)
 * should not be used.
 *//*
 * For compatibility with Windows Phone 8 header files, the following
 * synonym for WINAPI_PARTITION_PHONE_APP is temporarily #define'd.
 * Use of this symbol should be regarded as deprecated.
 *//*
 * SYSTEM is the only partition defined here.
 * All other System based editions are defined as packages
 * on top of the System partition.
 * See winpackagefamily.h for packages level partitions
 *//*
 * The mapping between families and partitions is summarized here.
 * An X indicates that the given partition is active for the given
 * platform/family.
 *
 *                                +---------------------------+
 *                                |      *Partition*          |
 *                                +---+---+---+---+---+---+---+
 *                                |   |   |   |   |   |   |   |
 *                                |   |   |   |   |   |   |   |
 *                                |   |   |   | P |   |   |   |
 *                                |   |   |   | H |   |   |   |
 *                                | D |   |   | O |   |   |   |
 *                                | E |   | P | N | S | S |   |
 *                                | S |   | C | E | Y | E | G |
 *                                | K |   | _ | _ | S | R | A |
 *                                | T | A | A | A | T | V | M |
 * +-------------------------+----+ O | P | P | P | E | E | E |
 * |     *Platform/Family*       \| P | P | P | P | M | R | S |
 * +------------------------------+---+---+---+---+---+---+---+
 * | WINAPI_FAMILY_DESKTOP_APP    | X | X | X |   |   |   |   |
 * +------------------------------+---+---+---+---+---+---+---+
 * |      WINAPI_FAMILY_PC_APP    |   | X | X |   |   |   |   |
 * +------------------------------+---+---+---+---+---+---+---+
 * |   WINAPI_FAMILY_PHONE_APP    |   | X |   | X |   |   |   |
 * +----------------------------- +---+---+---+---+---+---+---+
 * |      WINAPI_FAMILY_SYSTEM    |   |   |   |   | X |   |   |
 * +----------------------------- +---+---+---+---+---+---+---+
 * |      WINAPI_FAMILY_SERVER    |   |   |   |   | X | X |   |
 * +------------------------------+---+---+---+---+---+---+---+
 * |       WINAPI_FAMILY_GAMES    |   |   |   |   |   |   | X |
 * +------------------------------+---+---+---+---+---+---+---+
 *
 * The table above is encoded in the following expressions,
 * each of which evaluates to 1 or 0.
 *
 * Whenever a new family is added, all of these expressions
 * need to be reconsidered.
 *//*
 * API PARTITONs are part of an indirection mechanism for mapping between
 * individual APIs and the FAMILYs to which they apply.
 * Each PARTITION is a category or subset of named APIs.  PARTITIONs
 * are permitted to have overlapping membership -- some single API
 * might be part of more than one PARTITION.  PARTITIONS are each #define-ed 
 * to be either 1 or 0 or depending on the platform at which the app is targeted.
 *//*
 * If no WINAPI_FAMILY value is specified, then all APIs available to
 * Windows desktop applications are exposed.
 *//*
 * For compatibility with Windows 8 header files, the following
 * synonym for WINAPI_FAMILY_PC_APP is temporarily #define'd.
 * Use of this symbol should be considered deprecated.
 *//* Additional WINAPI_FAMILY values may be defined in future SDKs. *//* The value of WINAPI_FAMILY_DESKTOP_APP may change in future SDKs. *//* Windows Desktop Applications *//* Windows Games and Applications *//* Windows Server Applications *//* Windows Drivers and Tools *//* Windows Phone Applications *//* Windows Store Applications *//*
 * The WINAPI_FAMILY values of 0 and 1 are reserved to ensure that
 * an error will occur if WINAPI_FAMILY is set to any
 * WINAPI_PARTITION value (which must be 0 or 1, see below).
 *//* In Windows 10, WINAPI_PARTITIONs will be used to add additional  
 * device specific APIs to a particular WINAPI_FAMILY.  
 * For example, when writing Windows Universal apps, specifying 
 * WINAPI_FAMILY_APP will hide phone APIs from compilation.  
 * However, specifying WINAPI_PARTITION_PHONE_APP=1 additionally, will         
 * unhide any API hidden behind the partition, to the compiler.

 * The following partitions are currently defined:
 * WINAPI_PARTITION_DESKTOP            // usable for Desktop Win32 apps (but not store apps)
 * WINAPI_PARTITION_APP                // usable for Windows Universal store apps
 * WINAPI_PARTITION_PC_APP             // specific to Desktop-only store apps
 * WINAPI_PARTITION_PHONE_APP          // specific to Phone-only store apps
 * WINAPI_PARTITION_SYSTEM             // specific to System applications
 * WINAPI_PARTITION_GAMES              // specific to games and apps

 * The following partitions are indirect partitions and defined in 
 * winpackagefamily.h. These partitions are related to package based 
 * partitions. For example, specifying WINAPI_PARTITION_SERVER=1 will light up
 * any API hidden behind the package based partitions that are bound to 
 * WINAPI_PARTITION_SERVER, to the compiler.
 * WINAPI_PARTITION_SERVER             // specific to Server applications
*//*
 * When compiling C and C++ code using SDK header files, the development
 * environment can specify a target platform by #define-ing the
 * pre-processor symbol WINAPI_FAMILY to one of the following values.
 * Each FAMILY value denotes an application family for which a different
 * subset of the total set of header-file-defined APIs are available.
 * Setting the WINAPI_FAMILY value will effectively hide from the
 * editing and compilation environments the existence of APIs that
 * are not applicable to the family of applications targeting a
 * specific platform.
 *//*

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    winapifamily.h

Abstract:

    Master include file for API family partitioning.

*/C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/sdkddkver.h_WIN32_IE0x0A00WINVER_WIN32_WINNTNTDDI_VERSIONWDK_NTDDI_VERSIONNTDDI_VERSION_FROM_WIN32_WINNT(ver)NTDDI_VERSION_FROM_WIN32_WINNT2(ver)ver ## 0000SUBVER(Version)(((Version) & SUBVERSION_MASK) )SPVER(Version)(((Version) & SPVERSION_MASK) >> 8)OSVER(Version)((Version) & OSVERSION_MASK)SUBVERSION_MASK0x000000FFSPVERSION_MASK0x0000FF00OSVERSION_MASK0xFFFF0000NTDDI_WIN10_NI0x0A00000CNTDDI_WIN10_CO0x0A00000BNTDDI_WIN10_FE0x0A00000ANTDDI_WIN10_MN0x0A000009NTDDI_WIN10_VB0x0A000008NTDDI_WIN10_19H10x0A000007NTDDI_WIN10_RS50x0A000006NTDDI_WIN10_RS40x0A000005NTDDI_WIN10_RS30x0A000004NTDDI_WIN10_RS20x0A000003NTDDI_WIN10_RS10x0A000002NTDDI_WIN10_TH20x0A000001NTDDI_WIN100x0A000000NTDDI_WINTHRESHOLDNTDDI_WINBLUE0x06030000NTDDI_WIN80x06020000NTDDI_WIN70x06010000NTDDI_WS08SP4NTDDI_WIN6SP4NTDDI_WS08SP3NTDDI_WIN6SP3NTDDI_WS08SP2NTDDI_WIN6SP2NTDDI_WS08NTDDI_WIN6SP1NTDDI_LONGHORNNTDDI_VISTANTDDI_VISTASP4NTDDI_VISTASP3NTDDI_VISTASP2NTDDI_VISTASP1NTDDI_WIN60x060004000x060003000x060002000x060001000x06000000NTDDI_WS03SP40x05020400NTDDI_WS03SP30x05020300NTDDI_WS03SP20x05020200NTDDI_WS03SP10x05020100NTDDI_WS030x05020000NTDDI_WINXPSP40x05010400NTDDI_WINXPSP30x05010300NTDDI_WINXPSP20x05010200NTDDI_WINXPSP10x05010100NTDDI_WINXP0x05010000NTDDI_WIN2KSP40x05000400NTDDI_WIN2KSP30x05000300NTDDI_WIN2KSP20x05000200NTDDI_WIN2KSP10x05000100NTDDI_WIN2K0x05000000NTDDI_WIN40x04000000_WIN32_IE_WIN10_WIN32_IE_IE110_WIN32_IE_WINTHRESHOLD_WIN32_IE_WINBLUE_WIN32_IE_IE100_WIN32_IE_WIN8_WIN32_IE_WIN7_WIN32_IE_IE80_WIN32_IE_LONGHORN_WIN32_IE_IE70_WIN32_IE_WIN6_WIN32_IE_WS03SP1_WIN32_IE_IE60SP2_WIN32_IE_WS030x0602_WIN32_IE_XPSP2_WIN32_IE_XPSP1_WIN32_IE_IE60SP1_WIN32_IE_XP_WIN32_IE_IE60_WIN32_IE_WIN2KSP4_WIN32_IE_IE501_WIN32_IE_WIN2KSP3_WIN32_IE_WIN2KSP2_WIN32_IE_WIN2KSP1_WIN32_IE_WIN2K_WIN32_IE_WINME_WIN32_IE_IE55_WIN32_IE_WIN98SE_WIN32_IE_IE50_WIN32_IE_WIN98_WIN32_IE_IE401_WIN32_IE_NT4SP6_WIN32_IE_NT4SP5_WIN32_IE_NT4SP4_WIN32_IE_NT4SP3_WIN32_IE_IE302_WIN32_IE_NT4SP2_WIN32_IE_IE20_WIN32_IE_NT4SP1_WIN32_IE_NT4_WIN32_IE_IE900x09000x07000x06030x06010x06000x05500x05010x05000x0401_WIN32_IE_IE400x0302_WIN32_IE_IE300x0300_WIN32_WINNT_WIN10_WIN32_WINNT_WINTHRESHOLD_WIN32_WINNT_WINBLUE_WIN32_WINNT_WIN8_WIN32_WINNT_WIN7_WIN32_WINNT_LONGHORN_WIN32_WINNT_WS08_WIN32_WINNT_VISTA_WIN32_WINNT_WIN6_WIN32_WINNT_WS030x0502_WIN32_WINNT_WINXP_WIN32_WINNT_WIN2K_WIN32_WINNT_NT4_INC_SDKDDKVER(_MSC_VER >= 800)(_MSC_VER >= 1200)warning(disable:4668)defined(DECLSPEC_DEPRECATED_DDK)(NTDDI_VERSION >= NTDDI_WIN2K)(NTDDI_VERSION >= NTDDI_WINXP)(NTDDI_VERSION >= NTDDI_WS03)(NTDDI_VERSION >= NTDDI_WIN6)!defined(_WIN32_WINNT) && !defined(_CHICAGO_)(_WIN32_WINNT <= _WIN32_WINNT_WINBLUE)(_WIN32_WINNT >= _WIN32_WINNT_WIN10)(_WIN32_WINNT <= _WIN32_WINNT_NT4)(_WIN32_WINNT <= _WIN32_WINNT_WIN2K)(_WIN32_WINNT <= _WIN32_WINNT_WINXP)(_WIN32_WINNT <= _WIN32_WINNT_WS03)(_WIN32_WINNT <= _WIN32_WINNT_VISTA)(_WIN32_WINNT <= _WIN32_WINNT_WIN7)(_WIN32_WINNT <= _WIN32_WINNT_WIN8)defined(_WIN32_WINNT) && !defined(MIDL_PASS) && !defined(RC_INVOKED)(defined(WINVER) && (WINVER < 0x0400) && (_WIN32_WINNT > 0x0400))(((OSVERSION_MASK & NTDDI_VERSION) == NTDDI_WIN2K) && (_WIN32_WINNT != _WIN32_WINNT_WIN2K))(((OSVERSION_MASK & NTDDI_VERSION) == NTDDI_WINXP) && (_WIN32_WINNT != _WIN32_WINNT_WINXP))(((OSVERSION_MASK & NTDDI_VERSION) == NTDDI_WS03) && (_WIN32_WINNT != _WIN32_WINNT_WS03))(((OSVERSION_MASK & NTDDI_VERSION) == NTDDI_VISTA) && (_WIN32_WINNT != _WIN32_WINNT_VISTA))((_WIN32_WINNT < _WIN32_WINNT_WIN2K) && (_WIN32_IE > _WIN32_IE_IE60SP1))/* !_INC_SDKDDKVER *//* nonstandard extension : single line comment */// defined(_WIN32_WINNT) && !defined(MIDL_PASS) && !defined(_WINRESRC_)// Sanity check for compatible versions// set _WIN32_IE based on _WIN32_WINNT// set WINVER based on _WIN32_WINNT// NTDDI_VERSION// _WIN32_WINNT// set NTDDI_VERSION to default to latest if _WIN32_WINNT isn't set// (_WIN32_WINNT <= _WIN32_WINNT_WINBLUE)// set NTDDI_VERSION to default to WDK_NTDDI_VERSION// set NTDDI_VERSION based on _WIN32_WINNT// if versions aren't already defined, default to most current// defined(DECLSPEC_DEPRECATED_DDK)// deprecate in WIN6 or later// deprecate in WS03 or later// deprecate in XP or later// deprecate in 2k or later// macros to extract various version fields from the NTDDI version// masks for version macros// NTDDI version constants// Win2k supports IE versions 5.01 -> 6.0 SP1// WinME supports IE versions 5.5 -> 6.0 SP1// Win98SE supports IE versions 5.0 -> 6.0 SP1// Win98 supports IE versions 4.01 -> 6.0 SP1// NT4 supports IE versions 2.0 -> 6.0 SP1// IE <-> OS version mapping// _WIN32_IE_ version constants// _WIN32_WINNT version constants/* #if not_defined treated as #if 0 *//*

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sdkddkver.h

Abstract:

    Master include file for versioning windows SDK/DDK.

*/C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.43.34808/include/excpt.h_abnormal_termination_exception_info_exception_code__C_specific_handler_EXCEPTION_RECORD *_CONTEXT *_DISPATCHER_CONTEXT *EXCEPTION_DISPOSITION_EXCEPTION_DISPOSITIONExceptionContinueExecutionExceptionContinueSearchExceptionNestedExceptionExceptionCollidedUnwindEXCEPTION_CONTINUE_EXECUTIONEXCEPTION_CONTINUE_SEARCHEXCEPTION_EXECUTE_HANDLERabnormal_terminationAbnormalTerminationexception_info()((struct _EXCEPTION_POINTERS *)_exception_info())GetExceptionInformation()exception_codeGetExceptionCode_INC_EXCPTdefined(_M_IX86) && !defined(_CHPE_X86_ARM64_EH_)defined _M_X64 || defined _M_ARM || defined _M_ARM64 || defined _CHPE_X86_ARM64_EH__DISPATCHER_CONTEXT_CONTEXT_EXCEPTION_RECORD// Defined values for the exception filter expression// SEH intrinsics// SEH handler// Exception disposition return values// keywords which implement the structured exception handling extensions.// The declarations of the compiler-dependent intrinsics, support functions, and// excpt.hExceptionRecordEstablisherFrameContextRecordDispatcherContextC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/specstrings_undef.h__xcount_opt__xcount__writableTo__volatile__typefix__type_has_adt_prop__transfer__this_out_validated__this_out_data_source__success__struct_xcount__struct_bcount__source_code_content__rpc_entry__readableTo__range__precond__post_nullnullterminated__postcond__post_invalid__possibly_notnullterminated__out_xcount_part_opt__out_xcount_part__out_xcount_opt__out_xcount_full_opt__out_xcount_full__out_xcount__out_validated__out_transfer_adt_prop__out_range__out_not_has_adt_prop__out_has_type_adt_props__out_has_adt_prop__out_ecount_z_opt__out_ecount_z__out_ecount_part_opt__out_ecount_part__out_ecount_opt__out_ecount_nz_opt__out_ecount_nz__out_ecount_full_opt__out_ecount_full__out_ecount__out_data_source__out_bound__out_bcount_z_opt__out_bcount_z__out_bcount_part_opt__out_bcount_part__out_bcount_opt__out_bcount_nz_opt__out_bcount_nz__out_bcount_full_opt__out_bcount_full__out_bcount__out_awcount__nonvolatile__range_min__range_max__kernel_entry__inout_xcount_part_opt__inout_xcount_part__inout_xcount_opt__inout_xcount_full_opt__inout_xcount_full__inout_xcount__inout_ecount_z_opt__inout_ecount_z__inout_ecount_part_opt__inout_ecount_part__inout_ecount_opt__inout_ecount_nz_opt__inout_ecount_nz__inout_ecount_full_opt__inout_ecount_full__inout_ecount__inout_bcount_z_opt__inout_bcount_z__inout_bcount_part_opt__inout_bcount_part__inout_bcount_opt__inout_bcount_nz_opt__inout_bcount_nz__inout_bcount_full_opt__inout_bcount_full__inout_bcount__inner_volatile__inner_typefix__inner_transfer__inner_success__inner_range__inner_possibly_notnullterminated__inner_out_validated__inner_nonvolatile__inner_encoded__inner_data_source__inner_data_entrypoint__inner_control_entrypoint__inner_compname_props__inner_checkReturn__inner_bound__inner_blocksOn__inner_assume_validated_dec__inner_assume_validated__inner_assume_bound_dec__inner_assume_bound__inner_analysis_assume_nullterminated__inner_analysis_assume_nulltermianted_dec__inner_adt_type_props__inner_adt_transfer_prop__inner_adt_remove_prop__inner_adt_prop__inner_adt_add_prop__inexpressible_writableTo__inexpressible_readableTo__in_xcount_opt__in_xcount__in_range__in_ecount_z_opt__in_ecount_z__in_ecount_opt__in_ecount_nz_opt__in_ecount_nz__in_ecount__in_data_source__in_bound__in_bcount_z_opt__in_bcount_z__in_bcount_opt__in_bcount_nz_opt__in_bcount_nz__in_bcount__in_awcount__gdi_entry__file_parser_library__file_parser_class__file_parser__field_xcount_part_opt__field_xcount_part__field_xcount_opt__field_xcount_full_opt__field_xcount_full__field_xcount__field_range__field_nullterminated__field_encoded_pointer__field_encoded_array__field_ecount_part_opt__field_ecount_part__field_ecount_opt__field_ecount_full_opt__field_ecount_full__field_ecount__field_data_source__field_bcount_part_opt__field_bcount_part__field_bcount_opt__field_bcount_full_opt__field_bcount_full__field_bcount__encoded_pointer__encoded_array__elem_writableTo__elem_readableTo__ecount_opt__ecount__deref_xcount_opt__deref_xcount__deref_volatile__deref_realloc_bcount__deref_out_xcount_part_opt__deref_out_xcount_part__deref_out_xcount_opt__deref_out_xcount_full_opt__deref_out_xcount_full__deref_out_xcount__deref_out_range__deref_out_ecount_z_opt__deref_out_ecount_z__deref_out_ecount_part_opt__deref_out_ecount_part__deref_out_ecount_opt__deref_out_ecount_nz_opt__deref_out_ecount_nz__deref_out_ecount_iterator__deref_out_ecount_full_opt__deref_out_ecount_full__deref_out_ecount__deref_out_bound__deref_out_bcount_z_opt__deref_out_bcount_z__deref_out_bcount_part_opt__deref_out_bcount_part__deref_out_bcount_opt__deref_out_bcount_nz_opt__deref_out_bcount_nz__deref_out_bcount_full_opt__deref_out_bcount_full__deref_out_bcount__deref_opt_xcount_opt__deref_opt_xcount__deref_opt_out_xcount_part_opt__deref_opt_out_xcount_part__deref_opt_out_xcount_opt__deref_opt_out_xcount_full_opt__deref_opt_out_xcount_full__deref_opt_out_xcount__deref_opt_out_ecount_z_opt__deref_opt_out_ecount_part_opt__deref_opt_out_ecount_part__deref_opt_out_ecount_opt__deref_opt_out_ecount_nz_opt__deref_opt_out_ecount_full_opt__deref_opt_out_ecount_full__deref_opt_out_ecount__deref_opt_out_bcount_z_opt__deref_opt_out_bcount_part_opt__deref_opt_out_bcount_part__deref_opt_out_bcount_opt__deref_opt_out_bcount_nz_opt__deref_opt_out_bcount_full_opt__deref_opt_out_bcount_full__deref_opt_out_bcount__deref_opt_inout_xcount_part_opt__deref_opt_inout_xcount_part__deref_opt_inout_xcount_opt__deref_opt_inout_xcount_full_opt__deref_opt_inout_xcount_full__deref_opt_inout_xcount__deref_opt_inout_ecount_z_opt__deref_opt_inout_ecount_z__deref_opt_inout_ecount_part_opt__deref_opt_inout_ecount_part__deref_opt_inout_ecount_opt__deref_opt_inout_ecount_nz_opt__deref_opt_inout_ecount_nz__deref_opt_inout_ecount_full_opt__deref_opt_inout_ecount_full__deref_opt_inout_ecount__deref_opt_inout_bcount_z_opt__deref_opt_inout_bcount_z__deref_opt_inout_bcount_part_opt__deref_opt_inout_bcount_part__deref_opt_inout_bcount_opt__deref_opt_inout_bcount_nz_opt__deref_opt_inout_bcount_nz__deref_opt_inout_bcount_full_opt__deref_opt_inout_bcount_full__deref_opt_inout_bcount__deref_opt_in_xcount_opt__deref_opt_in_xcount__deref_opt_in_opt__deref_opt_in_ecount_opt__deref_opt_in_ecount__deref_opt_in_bcount_opt__deref_opt_in_bcount__deref_opt_in__deref_opt_ecount_opt__deref_opt_ecount__deref_opt_bcount_opt__deref_opt_bcount__deref_nonvolatile__deref_inout_xcount_part_opt__deref_inout_xcount_part__deref_inout_xcount_opt__deref_inout_xcount_full_opt__deref_inout_xcount_full__deref_inout_xcount__deref_inout_range__deref_inout_ecount_iterator__deref_inout_ecount_z_opt__deref_inout_ecount_z__deref_inout_ecount_part_opt__deref_inout_ecount_part__deref_inout_ecount_opt__deref_inout_ecount_nz_opt__deref_inout_ecount_nz__deref_inout_ecount_full_opt__deref_inout_ecount_full__deref_inout_ecount__deref_inout_bcount_z_opt__deref_inout_bcount_z__deref_inout_bcount_part_opt__deref_inout_bcount_part__deref_inout_bcount_opt__deref_inout_bcount_nz_opt__deref_inout_bcount_nz__deref_inout_bcount_full_opt__deref_inout_bcount_full__deref_inout_bcount__deref_in_xcount_opt__deref_in_xcount__deref_in_range__deref_in_opt_out__deref_in_opt__deref_in_ecount_iterator__deref_in_ecount_opt__deref_in_ecount__deref_in_bcount_opt__deref_in_bcount__deref_in__deref_ecount_opt__deref_ecount__deref_bcount_opt__deref_bcount__deallocate_opt__deallocate__data_entrypoint__control_entrypoint__class_code_content__byte_writableTo__byte_readableTo__bound__blocksOn__bcount_opt__bcount__assume_validated__assume_bound__analysis_hint__analysis_assume_nullterminated__analysis_assert__allocator_When__Outptr_opt_result_bytebuffer_all_maybenull__Outptr_result_bytebuffer_all_maybenull__Outptr_opt_result_bytebuffer_to_maybenull__Outptr_result_bytebuffer_to_maybenull__Outptr_opt_result_bytebuffer_maybenull__Outptr_result_bytebuffer_maybenull__Outptr_opt_result_bytebuffer_all__Outptr_result_bytebuffer_all__Outptr_opt_result_bytebuffer_to__Outptr_result_bytebuffer_to__Outptr_opt_result_bytebuffer__Outptr_result_bytebuffer__Outptr_opt_result_buffer_all_maybenull__Outptr_result_buffer_all_maybenull__Outptr_opt_result_buffer_to_maybenull__Outptr_result_buffer_to_maybenull__Outptr_opt_result_buffer_maybenull__Outptr_opt_result_buffer_all__Outptr_result_buffer_all__Outptr_opt_result_buffer_to__Outptr_result_buffer_to__Outptr_opt_result_buffer__Outptr_result_buffer__Out_opt_bytecap__Out_bytecap__Out_opt_cap__Out_cap__In_opt_bytecount__In_bytecount__In_opt_count__In_count__Deref_post_opt_bytecount__Deref_post_bytecount__Deref_post_opt_count__Deref_post_count__Deref_post_opt_bytecap__Deref_post_bytecap__Deref_post_opt_cap__Deref_post_cap__At_//    Copyright (C) Microsoft.  All rights reserved.C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/specstrings_strict.h<specstrings_undef.h>__$allowed_on_global_or_field__$allowed_on_parameter_or_return__$allowed_on_field__$allowed_on_struct__$allowed_on_function__$allowed_on_parameter__$allowed_on_return__$allowed_on_typedecl__$allowed_on_function_or_typedecl__$allowed_as_statement__$allowed_as_statement_with_arg(1)__$allowed_as_statement_with_arg(x)__pragma(warning(push)) __pragma(warning(disable : 4548)) do {__noop(x);} while((0,0) __pragma(warning(pop)) )__$allowed_as_global_decl__allowed(p)__$allowed_ ## p__precond(condition)__elem_writableTo(count)__elem_readableTo(count)__byte_readableTo(count)__byte_writableTo(count)__inexpressible_readableTo(string)__writableTo(count)__readableTo(count)__allowed(on_global_or_field)__allowed(on_parameter_or_return)__out_has_type_adt_props(typ)__allowed(on_parameter)__out_transfer_adt_prop(arg)__out_not_has_adt_prop(adt,prop)__out_has_adt_prop(adt,prop)__type_has_adt_prop(adt,prop)__allowed(on_typdecl)__analysis_hint(hint)__allowed(on_function)__analysis_assert(expr)__allowed(as_statement_with_arg(expr))__assume_validated(exp)__allowed(as_statement_with_arg(exp))__transfer(formal)__allowed(on_field)__class_code_content(codetype_sym)__allowed(on_struct)__source_code_content(codetype_sym)__allowed(as_global_decl)__file_parser_library(filetype_sym)__file_parser_class(filetype_sym)__file_parser(filetype_sym)__this_out_validated(filetype_sym)__out_validated(filetype_sym)__this_out_data_source(src_syn)__field_data_source(src_sym)__out_data_source(src_sym)__in_data_source(src_sym)__struct_xcount(size)__struct_bcount(size)__field_xcount_full_opt(size)__field_bcount_full_opt(size)__field_ecount_full_opt(size)__field_xcount_full(size)__field_bcount_full(size)__field_ecount_full(size)__field_xcount_part_opt(size,init)__field_bcount_part_opt(size,init)__field_ecount_part_opt(size,init)__field_xcount_part(size,init)__field_bcount_part(size,init)__field_ecount_part(size,init)__field_xcount_opt(size)__field_bcount_opt(size)__field_ecount_opt(size)__field_xcount(size)__field_bcount(size)_SAL_VERSION_CHECK(__field_bcount)__field_ecount(size)_SAL_VERSION_CHECK(__field_ecount)__allowed(on_typedecl)__deallocate_opt(kind)__deallocate(kind)__analysis_assume_nullterminated(x)__allowed(as_statement_with_arg(x))__assume_bound(i)__allowed(as_statement_with_arg(i))__allowed(on_return)__range_min(a,b)__range_max(a,b)__field_range(lb,ub)_SAL_VERSION_CHECK(__field_range)__deref_inout_range(lb,ub)__deref_out_range(lb,ub)_SAL_VERSION_CHECK(__deref_out_range)__deref_in_range(lb,ub)__out_range(lb,ub)_SAL_VERSION_CHECK(__out_range)__in_range(lb,ub)_SAL_VERSION_CHECK(__in_range)__range(lb,ub)__allowed(as_statement)_SAL_VERSION_CHECK(__checkReturn)_SAL_VERSION_CHECK(__reserved)_SAL_VERSION_CHECK(__nullnullterminated)_SAL_VERSION_CHECK(__nullterminated)__in_awcount(expr,size)__out_awcount(expr,size)_SAL_VERSION_CHECK(__success)_When_(expr,annotes)_At_(expr,annotes)_SAL_VERSION_CHECK(_Deref_post_opt_bytecap_)_SAL_VERSION_CHECK(_Deref_post_bytecap_)_SAL_VERSION_CHECK(_Deref_post_opt_cap_)_SAL_VERSION_CHECK(_Deref_post_cap_)_SAL_VERSION_CHECK(_Deref_post_opt_bytecount_)_SAL_VERSION_CHECK(_Deref_post_bytecount_)_SAL_VERSION_CHECK(_Deref_post_opt_count_)_SAL_VERSION_CHECK(_Deref_post_count_)_SAL_VERSION_CHECK(_Out_opt_bytecap_)_SAL_VERSION_CHECK(_Out_bytecap_)_SAL_VERSION_CHECK(_Out_opt_cap_)_SAL_VERSION_CHECK(_Out_cap_)_SAL_VERSION_CHECK(_In_opt_bytecount_)_SAL_VERSION_CHECK(_In_bytecount_)_SAL_VERSION_CHECK(_In_opt_count_)_SAL_VERSION_CHECK(_In_count_)_SAL_VERSION_CHECK(_Deref_opt_out_opt_)_SAL_VERSION_CHECK(_Deref_opt_out_)_SAL_VERSION_CHECK(_Deref_out_opt_)_SAL_VERSION_CHECK(_Deref_out_)__deref_realloc_bcount(insize,outsize)__deref_inout_ecount_iterator(size,incr)__deref_out_ecount_iterator(size,incr)__deref_in_ecount_iterator(size,incr)__deref_opt_inout_xcount_full_opt(size)__deref_opt_inout_xcount_part_opt(size,len)__deref_opt_inout_bcount_part_opt(size,len)__deref_opt_inout_ecount_part_opt(size,len)__deref_opt_inout_xcount_opt(size)__deref_opt_out_xcount_full_opt(size)__deref_opt_out_xcount_part_opt(size,len)__deref_opt_out_bcount_part_opt(size,len)__deref_opt_out_ecount_part_opt(size,len)__deref_opt_out_xcount_opt(size)__deref_opt_in_xcount_opt(size)__deref_opt_in_bcount_opt(size)__deref_opt_in_ecount_opt(size)__deref_opt_xcount_opt(size)__deref_opt_inout_xcount_full(size)__deref_opt_inout_xcount_part(size,len)__deref_opt_inout_bcount_part(size,len)__deref_opt_inout_ecount_part(size,len)__deref_opt_inout_xcount(size)__deref_opt_out_xcount_full(size)__deref_opt_out_xcount_part(size,len)__deref_opt_out_bcount_part(size,len)__deref_opt_out_ecount_part(size,len)__deref_opt_out_xcount(size)_SAL_VERSION_CHECK(__deref_opt_out_xcount)_SAL_VERSION_CHECK(__deref_opt_out_bcount)_SAL_VERSION_CHECK(__deref_opt_out_ecount)_SAL_VERSION_CHECK(__deref_opt_out)__deref_opt_in_xcount(size)__deref_opt_in_bcount(size)__deref_opt_in_ecount(size)__deref_opt_xcount(size)__deref_inout_xcount_full_opt(size)__deref_inout_xcount_part_opt(size,len)__deref_inout_bcount_part_opt(size,len)__deref_inout_ecount_part_opt(size,len)__deref_inout_xcount_opt(size)__deref_out_xcount_full_opt(size)_SAL_VERSION_CHECK(__deref_out_xcount_full_opt)_SAL_VERSION_CHECK(__deref_out_bcount_full_opt)_SAL_VERSION_CHECK(__deref_out_ecount_full_opt)__deref_out_xcount_part_opt(size,len)_SAL_VERSION_CHECK(__deref_out_xcount_part_opt)__deref_out_bcount_part_opt(size,len)_SAL_VERSION_CHECK(__deref_out_bcount_part_opt)__deref_out_ecount_part_opt(size,len)_SAL_VERSION_CHECK(__deref_out_ecount_part_opt)__deref_out_xcount_opt(size)_SAL_VERSION_CHECK(__deref_out_xcount_opt)_SAL_VERSION_CHECK(__deref_out_bcount_opt)_SAL_VERSION_CHECK(__deref_out_ecount_opt)_SAL_VERSION_CHECK(__deref_out_opt)__deref_in_xcount_opt(size)__deref_in_bcount_opt(size)__deref_in_ecount_opt(size)__deref_xcount_opt(size)__deref_inout_xcount_full(size)__deref_inout_xcount_part(size,len)__deref_inout_bcount_part(size,len)__deref_inout_ecount_part(size,len)__deref_inout_xcount(size)_SAL_VERSION_CHECK(__deref_inout_xcount)_SAL_VERSION_CHECK(__deref_inout_bcount)_SAL_VERSION_CHECK(__deref_inout_ecount)_SAL_VERSION_CHECK(__deref_inout)__deref_out_xcount_full(size)_SAL_VERSION_CHECK(__deref_out_xcount_full)_SAL_VERSION_CHECK(__deref_out_bcount_full)_SAL_VERSION_CHECK(__deref_out_ecount_full)__deref_out_xcount_part(size,len)_SAL_VERSION_CHECK(__deref_out_xcount_part)__deref_out_bcount_part(size,len)_SAL_VERSION_CHECK(__deref_out_bcount_part)__deref_out_ecount_part(size,len)_SAL_VERSION_CHECK(__deref_out_ecount_part)__deref_out_xcount(size)_SAL_VERSION_CHECK(__deref_out_xcount)_SAL_VERSION_CHECK(__deref_out_bcount)_SAL_VERSION_CHECK(__deref_out_ecount)_SAL_VERSION_CHECK(__deref_out)__deref_in_xcount(size)_SAL_VERSION_CHECK(__deref_in_xcount)__deref_in_bcount(size)_SAL_VERSION_CHECK(__deref_in_bcount)__deref_in_ecount(size)_SAL_VERSION_CHECK(__deref_in_ecount)_SAL_VERSION_CHECK(__deref_in)__deref_xcount(size)__inout_xcount_full_opt(size)_SAL_VERSION_CHECK(__inout_xcount_full_opt)_SAL_VERSION_CHECK(__inout_bcount_full_opt)_SAL_VERSION_CHECK(__inout_ecount_full_opt)__inout_xcount_part_opt(size,len)_SAL_VERSION_CHECK(__inout_xcount_part_opt)__inout_bcount_part_opt(size,len)_SAL_VERSION_CHECK(__inout_bcount_part_opt)__inout_ecount_part_opt(size,len)_SAL_VERSION_CHECK(__inout_ecount_part_opt)__inout_xcount_opt(size)_SAL_VERSION_CHECK(__inout_xcount_opt)_SAL_VERSION_CHECK(__inout_bcount_opt)_SAL_VERSION_CHECK(__inout_ecount_opt)_SAL_VERSION_CHECK(__inout_opt)__out_xcount_full_opt(size)__out_xcount_part_opt(size,len)__out_bcount_part_opt(size,len)__out_ecount_part_opt(size,len)__out_xcount_opt(size)_SAL_VERSION_CHECK(__out_bcount_opt)_SAL_VERSION_CHECK(__out_ecount_opt)_SAL_VERSION_CHECK(__out_opt)__in_xcount_opt(size)_SAL_VERSION_CHECK(__in_bcount_opt)_SAL_VERSION_CHECK(__in_ecount_opt)_SAL_VERSION_CHECK(__in_opt)__xcount_opt(size)__inout_xcount_full(size)_SAL_VERSION_CHECK(__inout_xcount_full)_SAL_VERSION_CHECK(__inout_bcount_full)_SAL_VERSION_CHECK(__inout_ecount_full)__inout_xcount_part(size,len)_SAL_VERSION_CHECK(__inout_xcount_part)__inout_bcount_part(size,len)_SAL_VERSION_CHECK(__inout_bcount_part)__inout_ecount_part(size,len)_SAL_VERSION_CHECK(__inout_ecount_part)__inout_xcount(size)_SAL_VERSION_CHECK(__inout_xcount)_SAL_VERSION_CHECK(__inout_bcount)_SAL_VERSION_CHECK(__inout_ecount)_SAL_VERSION_CHECK(__inout)_SAL_VERSION_CHECK(__out_bcount_z)_SAL_VERSION_CHECK(__out_ecount_z)_SAL_VERSION_CHECK(__out_z)__out_xcount_full(size)_SAL_VERSION_CHECK(__out_xcount_full)_SAL_VERSION_CHECK(__out_bcount_full)_SAL_VERSION_CHECK(__out_ecount_full)__out_xcount_part(size,len)_SAL_VERSION_CHECK(__out_xcount_part)__out_bcount_part(size,len)_SAL_VERSION_CHECK(__out_bcount_part)__out_ecount_part(size,len)_SAL_VERSION_CHECK(__out_ecount_part)__out_xcount(size)_SAL_VERSION_CHECK(__out_xcount)_SAL_VERSION_CHECK(__out_bcount)_SAL_VERSION_CHECK(__out_ecount)_SAL_VERSION_CHECK(__out)_SAL_VERSION_CHECK(__in_bcount_z)_SAL_VERSION_CHECK(__in_ecount_z)_SAL_VERSION_CHECK(__in_z)__in_xcount(size)_SAL_VERSION_CHECK(__in_xcount)_SAL_VERSION_CHECK(__in_bcount)_SAL_VERSION_CHECK(__in_ecount)_SAL_VERSION_CHECK(__in)__xcount(size)_SAL_VERSION_CHECK(__xcount)_SAL_VERSION_CHECK(__bcount)_SAL_VERSION_CHECK(__ecount)__SPECSTRINGS_STRICT_LEVEL(_MSC_VER >= 1400) && !defined(__midl) && !defined(_PREFAST_) && (__SPECSTRINGS_STRICT_LEVEL > 0)(__SPECSTRINGS_STRICT_LEVEL > 1)!defined(_MSC_EXTENSIONS) && !defined(_PREFAST_) && !defined(OACR)(__SPECSTRINGS_STRICT_LEVEL == 1) || (__SPECSTRINGS_STRICT_LEVEL == 2)__SPECSTRINGS_STRICT_LEVEL == 3/* #endif  __cplusplus *//* empty *//* Define dummy source attributes. Still needs more testing *//**************************************************************************
*  This should go away. It's only for __success which we should split into.
*  __success and __typdecl_sucess
***************************************************************************//************************************************************************* 
* Definitions to force a compile error when macros are used improperly.
* Relies on VS 2005 source annotations.
*************************************************************************//* Define soon to be deprecated macros to nops. *//* Must come before macro defintions *//************************************************************************* 
* Macros deprecated with strict level greater then 1.
**************************************************************************//************************************************************************* 
* Advanced macros
* 
*  __volatile 
* The __volatile annotation identifies a global variable or
* structure field that: 
*   1) is not declared volatile; 
*   2) is accessed concurrently by multiple threads.
*
* The __deref_volatile annotation identifies a global variable
* or structure field that stores a pointer to some data that:
*   1) is not declared volatile; 
*   2) is accessed concurrently by multiple threads.
*
* Prefast uses these annotations to find patterns of code that
* may result in unexpected re-fetching of the global variable
* into a local variable.
*
* We also provide two complimentary annotations __nonvolatile
* and __deref_nonvolatile that could be used to suppress Prefast
*
* re-fetching warnings on variables that are known either:
*   1) not to be in danger of being re-fetched or,
*   2) not to lead to incorrect results if they are re-fetched
*
*************************************************************************//************************************************************************* 
* Macros used by Prefast for Drivers 
* 
*  __possibly_notnullterminated :
*
*  Used for return values of parameters or functions that do not
*  guarantee nulltermination in all cases.
*
*************************************************************************//************************************************************************* 
* Macros to encode abstract properties of values. Used by SALadt.h
*************************************************************************//************************************************************************* 
* __analysis_hint(hint_sym) : Expert macro use only when
* directed. Use this to influence certain analysis heuristics
* used by the tools. These hints do not describe the semantics
* of functions but simply direct the tools to act in a certain
* way.
*
* Current hints that are supported are:
*
* INLINE   - inline this function during analysis overrides any
*            default heuristics 
* NOINLINE - do not inline this function during analysis overrides 
*            and default heuristics
*************************************************************************//************************************************************************* 
* __analysis_assume(expr) : Expert macro use only when directed. Use this to
* tell static analysis tools like PREfix and PREfast about a non-coded
* assumption that you wish the tools to assume. The assumption will be
* understood by those tools. By default there is no dynamic checking or
* static checking of the assumption in any build.
*
* To obtain dynamic checking wrap this macro in your local version of a debug
* assert.
* Please do not put function calls in the expression because this is not
* supported by all tools:
*  __analysis_assume(GetObject () != NULL); // DO NOT DO THIS
*
*************************************************************************//*************************************************************************
* Macros to tag encoded function pointers
**************************************************************************//*************************************************************************** 
* Macros to track the code content in the class. The type of code
* contents currently tracked:
*
* DCOM                          - Class implementing DCOM
***************************************************************************//*************************************************************************** 
* Macros to track the code content in the file. The type of code
* contents currently tracked:
*
* NDIS_DRIVER                   - NDIS Device driver 
***************************************************************************//************************************************************************** 
* Macros to tag file parsing code. Predefined formats include:
*  PNG                     - Portable Network Graphics
*  JPEG                    - Joint Photographic Experts Group
*  BMP                     - Bitmap
*  RC_BMP                  - Resource bitmap
*  WMF                     - Windows Metafile
*  EMF                     - Windows Enhanced Metafile
*  GIF                     - Graphics Interchange Format
*  MIME_TYPE               - MIME type from header tokens
*  MAIL_MONIKER            - MAIL information refered by URL moniker
*  HTML                    - HyperText Markup Language
*  WMPHOTO                 - Windows media photo
*  OE_VCARD                - Outlook Express virtual card
*  OE_CONTACT              - Outlook Express contact
*  MIDI                    - Musical Instrument Digital Interface
*  LDIF                    - LDAP Data Interchange Format
*  AVI                     - Audio Visual Interchange
*  ACM                     - Audio Compression Manager
**************************************************************************//*************************************************************************** 
* Macros to track untrusted data and their validation. The list of untrusted
* sources include:
*
* FILE                     - File reading stream or API
* NETWORK                  - Socket readers
* INTERNET                 - WinInet and WinHttp readers
* USER_REGISTRY            - HKCU portions of the registry
* USER_MODE                - Parameters to kernel entry points
* RPC                      - Parameters to RPC entry points 
* DRIVER                   - Device driver 
***************************************************************************//*************************************************************************** 
* Macros to classify the entrypoints and indicate their category.
*
* Pre-defined control point categories include: RPC, KERNEL, GDI.
*
* Pre-defined control point macros include:
*  __rpc_entry, __kernel_entry, __gdi_entry.
***************************************************************************//*************************************************************************** 
* Macros to classify fields of structures.
*                          Structure Annotations
*
*   The buffer annotations are a convenient way of describing
*   relationships between buffers and their size on a function by
*   function basis. Very often struct or class data members have similar
*   invariants, which can be expressed directly on the type.
*
*   Similar to our buffer annotations we can summarize all the various
*   structure annotations by one choosing an element from each column of
*   this table to build a composite annotation.
*
*           +--------------------------------------------------+
*           | Selector |  Units  |    Size/Init     | Optional |
*           |----------+---------+------------------+----------|
*           | __field  | _ecount | (size)           | empty    |
*           |----------+---------+------------------+----------|
*           | __struct | _bcount | _full(size)      | _opt     |
*           |----------+---------+------------------+----------|
*           |          | _xcount | _part(size,init) |          |
*           +--------------------------------------------------+
*
*   Note that empty represents the empty string. Sometime arguments need
*   to be "floated" to the left to give us a valid annotation name. For
*   example the naive combination __field_ecount(size)_opt is actually
*   written as __field_ecount_opt(size). Not all possible combinations
*   are currently supported or sensible. See specstrings_strict.h for
*   the currently supported set. Those that are supported are documented
*   below.
*
*Summary of Elements
*
*   Selector
*
*                __field
*                        The annotation should only be placed in front
*                        of data members of structures and classes. The
*                        data members are pointers to a block of data.
*                        The annotations describe properties about the
*                        size of the block of data. This can be used for
*
*                __struct
*                        The annotation should only be placed at the
*                        beginning of the definition of a structure or
*                        class. These annotations are used when a struct
*                        or class is used as a "header" that is
*                        allocated inline with a block of data and there
*                        is no apparent field that represents the tail
*                        end of the structure.
*
*   Units
*
*                _ecount
*                        All size and initialization values are in terms
*                        of elements of the appropriate type
*
*                _bcount
*                        All size and initialization values are in terms
*                        of raw byte sizes.
*
*                _xcount
*                        The size or initialization values cannot be
*                        properly expressed as a simple byte or element
*                        count, and instead a place holder is used to
*                        document the relationship.
*
*   Size/Init
*           All the size/init expressions can contain references to
*           other fields in the struct or class.
*
*                (size)
*                        The size of the buffer is determined by the
*                        expression size. Unless, the type of the buffer
*                        provides more information nothing is know about
*                        how much of this data is initialized. For
*                        example, if the data member happens to be a
*                        string type such as LPSTR. It is assumed that
*                        the data is initialized to the first '\0'.
*
*                _full(size)
*                        The size of the buffer is determined by the
*                        expression size and all the data in the buffer
*                        is guaranteed to be initialized.
*
*                _part(size,init)
*                        The size of the buffer is determined by the
*                        expression size and all the data in the buffer
*                        is guaranteed to be initialized up to init
*                        elements or bytes.
*
*   Optional
*
*                empty
*                        The pointer to the block of memory is never
*                        NULL
*
*                _opt
*                        The pointer to the block of memory is may be
*                        NULL
*
*     
*   // Basic Usage of Struct Annotations                         
*   #include <stdio.h>                                           
*   #include <stdlib.h>                                          
*   struct buf_s {                                               
*    int sz;                                                     
*    __field_bcount_full(sz)                                     
*    char *buf;                                                  
*   };                                                           
*   void InitBuf(__out struct *buf_s b,int sz) {                 
*        b->buf = calloc(sz,sizeof(char));                       
*        b->sz = sz;                                             
*   }                                                            
*   void WriteBuf(__in FILE *fp,__in struct *buf_s b) {          
*     fwrite(b->buf,b->sz,sizeof(char),fp);                      
*   }                                                            
*   void ReadBuf(__in FILE *fp,__inout struct *buf_s b) {        
*     fread(b->buf,b->sz,sizeof(char),fp);                       
*   }                                                            
*                                                                 
*                                                                 
*                                                                 
*   // Inline Allocated Buffer                                   
*   struct buf_s {                                               
*    int sz;                                                     
*    __field_bcount(sz)                                          
*    char buf[1];                                                
*   };                                                           
*   void WriteBuf(__in FILE *fp,__in struct *buf_s b) {          
*     fwrite(&(b->buf),b->sz,sizeof(char),fp);                   
*   }                                                            
*   void ReadBuf(__in FILE *fp,__inout struct *buf_s b) {        
*     fread(&(b->buf),b->sz,sizeof(char),fp);                    
*   }                                                            
*                                                                 
*                                                                 
*                                                                 
*   // Embedded Header Structure                                 
*   __struct_bcount(sz)                                          
*   struct buf_s {                                               
*    int sz;                                                     
*   };                                                           
*   void WriteBuf(__in FILE *fp,__in struct *buf_s b) {          
*     fwrite(&b,b->sz,sizeof(char),fp);                          
*   }                                                            
*   void ReadBuf(__in FILE *fp,__inout struct *buf_s b) {        
*     fread(&b,b->sz,sizeof(char),fp);                           
*   }                                                            
*
*
****************************************************************************//*************************************************************************** 
* Expert Macros
***************************************************************************//************************************************************************
*  Advanced Annotations
* 
*  Advanced annotations describe behavior that is not expressible with the
*  regular buffer macros. These may be used either to annotate buffer
*  parameters that involve complex or conditional behavior, or to enrich
*  existing annotations with additional information.
* 
*  _At_(expr, annotes) : annotation list annotes applies to target 'expr'
*
*  _When_(expr, annotes) : annotation list annotes applies when 'expr' is true
*
*  __success(expr) T f() : <expr> indicates whether function f succeeded or
*  not. If <expr> is true at exit, all the function's guarantees (as given
*  by other annotations) must hold. If <expr> is false at exit, the caller
*  should not expect any of the function's guarantees to hold. If not used,
*  the function must always satisfy its guarantees. Added automatically to
*  functions that indicate success in standard ways, such as by returning an
*  HRESULT.
* 
*  __out_awcount(expr, size) T *p : Pointer p is a buffer whose size may be
*  given in either bytes or elements. If <expr> is true, this acts like
*  __out_bcount. If <expr> is false, this acts like __out_ecount. This
*  should only be used to annotate old APIs.
* 
*  __in_awcount(expr, size) T* p : Pointer p is a buffer whose size may be given
*  in either bytes or elements. If <expr> is true, this acts like
*  __in_bcount. If <expr> is false, this acts like __in_ecount. This should
*  only be used to annotate old APIs.
* 
*  __nullterminated T* p : Pointer p is a buffer that may be read or written
*  up to and including the first '\0' character or pointer. May be used on
*  typedefs, which marks valid (properly initialized) instances of that type
*  as being null-terminated.
* 
*  __nullnullterminated T* p : Pointer p is a buffer that may be read or
*  written up to and including the first sequence of two '\0' characters or
*  pointers. May be used on typedefs, which marks valid instances of that
*  type as being double-null terminated.
* 
*  __reserved T v : Value v must be 0/NULL, reserved for future use.
* 
*  __checkReturn T f(); : Return value of f must not be ignored by callers
*  of this function.
* 
*  __typefix(ctype) T v : Value v should be treated as an instance of ctype,
*  rather than its declared type when considering validity.
* 
*  __override T f(); : Specify C#-style 'override' behaviour for overriding
*  virtual methods.
* 
*  __callback T f(); : Function f can be used as a function pointer.
* 
*  __format_string T p : Pointer p is a string that contains % markers in
*  the style of printf.
* 
*  __blocksOn(resource) f(); : Function f blocks on the resource 'resource'.
* 
*  __fallthrough : Annotates switch statement labels where fall-through is
*  desired, to distinguish from forgotten break statements.
* 
*  __range(low_bnd, up_bnd) int f(): The return from the function "f" must
*  be in the inclusive numeric range [low_bnd, up_bnd].
*
*  __in_range(low_bnd, up_bnd) int i : Precondition that integer i must be
*  in the inclusive numeric range [low_bnd, up_bnd].
* 
*  __out_range(low_bnd, up_bnd) int i : Postcondition that integer i must be
*  in the inclusive numeric range [low_bnd, up_bnd].
* 
*  __deref_in_range(low_bnd, up_bnd) int* pi : Precondition that integer *pi
*  must be in the inclusive numeric range [low_bnd, up_bnd].
*
*  __deref_out_range(low_bnd, up_bnd) int* pi : Postcondition that integer
*  *pi must be in the inclusive numeric range [low_bnd, up_bnd].
*
*  __deref_inout_range(low_bnd, up_bnd) int* pi : Invariant that the integer
*  *pi must be in the inclusive numeric range [low_bnd, up_bnd].
*
*  The first argument of a range macro may also be a C relational operator
*  (<,>,!=, ==, <=, >=).
*  
*  __range(rel_op, j) int f(): Postcondition that "f() rel_op j" must be
*  true.  Note that j may be a expression known only at runtime.
*
*  __in_range(rel_op, j) int i : Precondition that "i rel_op j" must be
*  true.  Note that j may be a expression known only at runtime.
* 
*  __out_range(rel_op, j) int i : Postcondition that integer "i rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
* 
*  __deref_in_range(rel_op, j) int *pi : Precondition that "*pi rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
*
*  __deref_out_range(rel_op, j) int *pi : Postcondition that "*pi rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
*
*  __deref_inout_range(rel_op, j) int *pi : Invariant that "*pi rel_op j"
*  must be true.  Note that j may be a expression known only at runtime.
*
*  __range_max(a, b) int f(): Postcondition f acts as 'max', returns larger
*  of a and b.  Note that a and b may be expressions known only at runtime.
*
*  __range_min(a, b) int f(): Postcondition f acts as 'min', returns smaller
*  of a and b.  Note that a and b may be expressions known only at runtime.
*
*  __in_bound int i : Precondition that integer i must be bound, but the
*  exact range can't be specified at compile time.  __in_range should be
*  used if the range can be explicitly stated.
*
*  __out_bound int i : Postcondition that integer i must be bound, but the
*  exact range can't be specified at compile time.  __out_range should be
*  used if the range can be explicitly stated.
* 
*  __deref_out_bound int pi : Postcondition that integer *pi must be bound,
*  but the exact range can't be specified at compile time.
*  __deref_out_range should be used if the range can be explicitly stated.
* 
*  __assume_bound(expr); : Assume that the expression is bound to some known
*  range. This can be used to suppress integer overflow warnings on integral
*  expressions that are known to be bound due to reasons not explicit in the
*  code. Use as a statement in the body of a function.
*
*  __analysis_assume_nulltermianted(expr); : Assume that the expression is
*  a null terminated buffer. Use this to suppress tool noise specific to
*  nulltermination warnings, and capture deeper invariants tools can not
*  discover. 
* 
*  __allocator void f(): Function allocates memory using an integral size
*  argument
*
*  void myfree(__deallocate(Mem) void *p) : Memory is freed, no longer usable
*  upon return, and p may not be null.
*
*  void myfree(__deallocate_opt(Mem) void *p) : Memory is freed, no longer
*  usable upon return, and p may be null.
*
*  void free(__post_invalid void* x): Mark memory as untouchable when 
*  function returns.
*
*  ----------------------------------------------------------------------------
*  Advanced Annotation Examples
* 
*  __success(return == TRUE) LWSTDAPI_(BOOL) 
*  PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath);
*  //  pszBuf is only guaranteed to be null-terminated when TRUE is returned.
* 
*  // Initialized LPWSTRs are null-terminated strings.
*  typedef __nullterminated WCHAR* LPWSTR;
* 
*  __out_ecount(cch) __typefix(LPWSTR) void *psz;
*  // psz is a buffer parameter which will be a null-terminated WCHAR string 
*  // at exit, and which initially contains cch WCHARs.
* 
************************************************************************//************************************************************************
*  Orcas SAL
************************************************************************//************************************************************************
*  SAL 2 _Ouptr_ family of annotations
************************************************************************//************************************************************************
*  Introduction
*
*  specstrings.h provides a set of annotations to describe how a function uses
*  its parameters - the assumptions it makes about them, and the guarantees it
*  makes upon finishing.
* 
*  Annotations must be placed before a function parameter's type or its return
*  type. There are two basic classes of common annotations buffer annotations
*  and advanced annotations.  Buffer annotations describe how functions use
*  their pointer parameters, and advanced annotations either describe
*  complex/unusual buffer behavior, or provide additional information about a
*  parameter that is not otherwise expressible.
* 
*  Buffer Annotations
* 
*  The most important annotations in SpecStrings.h provide a consistent way to
*  annotate buffer parameters or return values for a function. Each of these
*  annotations describes a single buffer (which could be a string, a
*  fixed-length or variable-length array, or just a pointer) that the function
*  interacts with: where it is, how large it is, how much is initialized, and
*  what the function does with it.
* 
*  The appropriate macro for a given buffer can be constructed using the table
*  below.  Just pick the appropriate values from each category, and combine
*  them together with a leading underscore. Some combinations of values do not
*  make sense as buffer annotations. Only meaningful annotations can be added
*  to your code; for a list of these, see the buffer annotation definitions
*  section.
* 
*  Only a single buffer annotation should be used for each parameter.
* 
*  |------------|------------|---------|--------|----------|---------------|
*  |   Level    |   Usage    |  Size   | Output | Optional |  Parameters   |
*  |------------|------------|---------|--------|----------|---------------|
*  | <>         | <>         | <>      | <>     | <>       | <>            |
*  | _deref     | _in        | _ecount | _full  | _opt     | (size)        |
*  | _deref_opt | _out       | _bcount | _part  |          | (size,length) |
*  |            | _inout     |         |        |          |               |
*  |            |            |         |        |          |               |
*  |------------|------------|---------|--------|----------|---------------|
*
*  Note: "<>" represents the empty string.
* 
*  Level: Describes the buffer pointer's level of indirection from the
*  parameter or return value 'p'.
* 
*  <>         : p is the buffer pointer.
*  _deref     : *p is the buffer pointer. p must not be NULL.
*  _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the 
*               rest of the annotation is ignored.
* 
*  Usage: Describes how the function uses the buffer.
* 
*  <> : The buffer is not accessed. If used on the return value or with
*  _deref, the function will provide the buffer, and it will be uninitialized
*  at exit.  Otherwise, the caller must provide the buffer. This should only
*  be used for alloc and free functions.
*
*  _in : The function will only read from the buffer. The caller must provide
*  the buffer and initialize it.
*
*  _out : The function will only write to the buffer. If used on the return
*  value or with _deref, the function will provide the buffer and initialize
*  it.  Otherwise, the caller must provide the buffer, and the function will
*  initialize it.
*
*  _inout : The function may freely read from and write to the buffer. The
*  caller must provide the buffer and initialize it. If used with _deref, the
*  buffer may be reallocated by the function.
*
*  Size: Describes the total size of the buffer. This may be less than the
*  space actually allocated for the buffer, in which case it describes the
*  accessible amount.
* 
*  <> : No buffer size is given. If the type specifies the buffer size (such
*  as with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is
*  one element long. Must be used with _in, _out, or _inout.
*
*  _ecount : The buffer size is an explicit element count.
*
*  _bcount : The buffer size is an explicit byte count.
* 
*  Output: Describes how much of the buffer will be initialized by the
*  function. For _inout buffers, this also describes how much is initialized
*  at entry. Omit this category for _in buffers; they must be fully
*  initialized by the caller.
* 
*  <> : The type specifies how much is initialized. For instance, a function
*  initializing an LPWSTR must NULL-terminate the string.
*
*  _full : The function initializes the entire buffer.
*
*  _part : The function initializes part of the buffer, and explicitly
*  indicates how much.
* 
*  Optional: Describes if the buffer itself is optional.
* 
*  <>   : The pointer to the buffer must not be NULL.
*
*  _opt : The pointer to the buffer might be NULL. It will be checked before
*  being dereferenced.
* 
*  Parameters: Gives explicit counts for the size and length of the buffer.
* 
*  <> : There is no explicit count. Use when neither _ecount nor _bcount is
*  used.
*
*  (size) : Only the buffer's total size is given. Use with _ecount or _bcount
*  but not _part.
*
*  (size,length) : The buffer's total size and initialized length are
*  given. Use with _ecount_part and _bcount_part.
* 
*  ----------------------------------------------------------------------------
*  Buffer Annotation Examples
* 
*  LWSTDAPI_(BOOL) StrToIntExA(
*      LPCSTR pszString,  //  No annotation required, const implies __in.
*      DWORD dwFlags,
*      __out int *piRet   // A pointer whose dereference will be filled in.
*  );
* 
*  void MyPaintingFunction(
*      __in HWND hwndControl,     //  An initialized read-only parameter.
*      __in_opt HDC hdcOptional,  //  An initialized read-only parameter that 
*                                 //  might be NULL.
*      __inout IPropertyStore *ppsStore // An initialized parameter that 
*                                       // may be freely used and modified.
*  );
* 
*  LWSTDAPI_(BOOL) PathCompactPathExA(
*      __out_ecount(cchMax) LPSTR pszOut, //  A string buffer with cch elements
*                                         //  that will be '\0' terminated 
*                                         //  on exit.
*      LPCSTR pszSrc,                     //  No annotation required, 
*                                         //  const implies __in.
*      UINT cchMax,                              
*      DWORD dwFlags
*  );
* 
*  HRESULT SHLocalAllocBytes(
*      size_t cb,
*      __deref_bcount(cb) T **ppv //  A pointer whose dereference will be set
*                                 //  to an uninitialized buffer with cb bytes.
*  );
* 
*  __inout_bcount_full(cb) : A buffer with cb elements that is fully
*  initialized at entry and exit, and may be written to by this function.
* 
*  __out_ecount_part(count, *countOut) : A buffer with count elements that
*  will be partially initialized by this function. The function indicates how
*  much it initialized by setting *countOut.
* 
************************************************************************//************************************************************************* 
*  This file documents all the macros approved for use in windows source
*  code. It includes some experimental macros which should only be used by
*  experts.
*
*  DO NOT include this file directly.  This file is include after
*  specstrings.h. So we can undefine every possible old definition including
*  private internal macros people should not be using, as well as macros from
*  sal.h.  Macros are redefined here in a way to cause syntax errors when used
*  incorrectly during a normal build when specstrings.h is included and
*  __SPECSTRINGS_STRICT_LEVEL is defined.
*
*  There are several levels of strictness, each level includes the behavior of
*  all previous levels.
*
*  0 - Disable strict checking 
*  1 - Break on unapproved macros and misuse of statement 
*      macros such as __fallthrough (default)
*  2 - Deprecated some old macros that should not be used
*  3 - Use VS 2005 Source Annotation to make sure every macro 
*      is used in the right context. For example placing __in on a return 
*      parameter will result in an error.
************************************************************************/C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/sdv_driverspecs.h__sdv_save_adapter_context(c)__sdv_retrieve_request(r)__sdv_save_request(r)_SDV_//void sdv_retrieve(void *r){;}//#define	__sdv_retrieve sdv_retrieve//-----------------------// general purpose retrieve macros//void sdv_save(void *r){;}//#define	__sdv_save sdv_save// general purpose save // NDIS AdapterContext save // general purpose retrieve C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/driverspecs.h"sdv_driverspecs.h"__drv_isCancelIRQL_IRQL_is_cancel___drv_holdsPriorityRegion()__drv_neverHoldPriorityRegion__drv_mustHoldPriorityRegion__drv_releasesPriorityRegion__drv_acquiresPriorityRegion__drv_holdsCriticalRegion()__drv_neverHoldCriticalRegion__drv_mustHoldCriticalRegion__drv_releasesCriticalRegion__drv_acquiresCriticalRegion__drv_neverHoldCancelSpinLock__drv_holdsCancelSpinLock()__drv_mustHoldCancelSpinLock__drv_releasesCancelSpinLock__drv_acquiresCancelSpinLock__drv_releasesExclusiveResourceGlobal(kind,param)__drv_acquiresExclusiveResourceGlobal(kind,param)__drv_releasesExclusiveResource(kind)__drv_acquiresExclusiveResource(kind)__drv_callbackType(kind)_SAL1_1_Source_(__drv_callbackType, (kind), _SA_annotes1(SAL_callbackType, #kind))__drv_completionType(kindlist)_SAL1_1_Source_(__drv_completionType, (kindlist), _SA_annotes1(SAL_completionType, #kindlist))__drv_dispatchType_other_SAL1_1_Source_(__drv_dispatchType_other, (), __drv_dispatchType(IRP_MJ_OTHER))__drv_dispatchType(x)_SAL1_1_Source_(__drv_displatchType, (x), _SA_annotes1(SAL_functionClassNew, #x))_Dispatch_type_(x)_SAL2_Source_(Dispatch_type_, (x), _SA_annotes1(SAL_functionClassNew, #x))__drv_formatString(kind)_SAL1_1_Source_(__drv_formatString, (kind), _SA_annotes1(SAL_IsFormatString, #kind))__drv_notInTry_SAL_L_Source_(__drv_notInTry, (), _Pre_ _SA_annotes1(SAL_inTry,__no))__drv_inTry_SAL_L_Source_(__drv_inTry, (), _Pre_ _SA_annotes1(SAL_inTry,__yes))__drv_interlocked_SAL1_1_Source_(__drv_interlocked, (), _Interlocked_operand_)__drv_floatUsed_SAL1_1_Source_(__drv_floatUsed, (), _Kernel_float_used_)_Kernel_float_used__SAL2_Source_(_Kernel_float_used_, (), _Post_ _SA_annotes0(SAL_floatUsed))__drv_floatRestored_SAL1_1_Source_(__drv_floatRestored, (), _Kernel_float_restored_)_Kernel_float_restored__SAL2_Source_(_Kernel_float_restored_, (), _Post_ _SA_annotes0(SAL_floatRestored))__drv_floatSaved_SAL1_1_Source_(__drv_floatSaved, (), _Kernel_float_saved_)_Kernel_float_saved__SAL2_Source_(_Kernel_float_saved_, (), _Post_ _SA_annotes0(SAL_floatSaved))__drv_reportError(why)_SAL_L_Source_(__drv_reportError, (why), _Pre_ _SA_annotes1(SAL_error,why))__drv_preferredFunction(func,why)_SAL_L_Source_(__drv_preferredFunction, (func,why), _Pre_ _SA_annotes2(SAL_preferredFunction, func, why))__drv_freesMem(kind)_SAL_L_Source_(__drv_freesMem, (kind), _Post_ _SA_annotes1(SAL_NeedsRelease,__no))__drv_allocatesMem(kind)_SAL_L_Source_(__drv_allocatesMem, (kind), _Post_ _SA_annotes1(SAL_NeedsRelease,__yes))__drv_aliasesMem_SAL_L_Source_(__drv_aliasesMem, (), _Post_ _SA_annotes0(SAL_IsAliased))__drv_isObjectPointer_SAL1_1_Source_(__drv_isObjectPointer, (), _Points_to_data_)__drv_notPointer_SAL1_1_Source_(__drv_notPointer, (), _Pre_ _SA_annotes1(SAL_mayBePointer,__no))__drv_typeExpr__drv_typeBitset__drv_typeCond__drv_typeConst__drv_strictType(typename,mode)_SAL1_1_Source_(__drv_strictType, (typename,mode), _Pre_ _SA_annotes2(SAL_strictType, typename, mode))__drv_strictTypeMatch(mode)_SAL1_1_Source_(__drv_strictTypeMatch, (mode), _Pre_ _SA_annotes1(SAL_strictTypeMatch,mode))__drv_nonConstant_SAL1_1_Source_(__drv_nonConstant, (), _Notliteral_)__drv_constant_SAL1_1_Source_(__drv_constant, (), _Literal_)__drv_valueIs(arglist)_SAL1_1_Source_(__drv_valueIs, (arglist), _Post_ _SA_annotes1(SAL_return,arglist))__drv_IoGetDmaAdapter_SAL1_1_Source_(__drv_IoGetDmaAdapter, (), _Kernel_IoGetDmaAdapter_)_Kernel_IoGetDmaAdapter__SAL2_Source_(_Kernel_IoGetDmaAdapter_, (), _Post_ _SA_annotes0(SAL_IoGetDmaAdapter))__drv_clearDoInit(yesNo)_SAL1_1_Source_(__drv_clearDoInit, (yesNo), _Kernel_clear_do_init_(yesNo))_Kernel_clear_do_init_(yesNo)_SAL2_Source_(_Kernel_clear_do_init_, (yesNo), _Post_ _SA_annotes1(SAL_clearDoInit,yesNo))_IRQL_inout__IRQL_saves_ _IRQL_restores___drv_useCancelIRQL_SAL1_1_Source_(__drv_usesCancelIRQL, (), _IRQL_uses_cancel_)_IRQL_uses_cancel___drv_sameIRQL_SAL1_1_Source_(__drv_sameIRQL, (), _IRQL_requires_same_)_IRQL_requires_same___drv_maxFunctionIRQL(irql)_SAL1_1_Source_(__drv_maxFunctionIRQL, (irql), _IRQL_always_function_max_(irql))_IRQL_always_function_max_(irql)__drv_minFunctionIRQL(irql)_SAL1_1_Source_(__drv_minFunctionIRQL, (irql), _IRQL_always_function_min_(irql))_IRQL_always_function_min_(irql)__drv_restoresIRQLGlobal(kind,param)_SAL1_1_Source_(__drv_restoresIRQLGlobal, (kind,param), _IRQL_restores_global_(kind,param))_IRQL_restores_global_(kind,param)__drv_restoresIRQL_SAL1_1_Source_(__drv_restoresIRQL, (), _IRQL_restores_)_IRQL_restores___drv_savesIRQLGlobal(kind,param)_SAL1_1_Source_(__drv_savesIRQLGlobal, (kind,param), _IRQL_saves_global_(kind,param))_IRQL_saves_global_(kind,param)__drv_savesIRQL_SAL1_1_Source_(__drv_savesIRQL, (), _IRQL_saves_)_IRQL_saves___drv_minIRQL(irql)_SAL1_1_Source_(__drv_minIRQL, (irql), _IRQL_requires_min_(irql))_IRQL_requires_min_(irql)__drv_maxIRQL(irql)_SAL1_1_Source_(__drv_maxIRQL, (irql), _IRQL_requires_max_(irql))_IRQL_requires_max_(irql)__drv_requiresIRQL(irql)_SAL1_1_Source_(__drv_requiresIRQL, (irql), _IRQL_requires_(irql))_IRQL_requires_(irql)__drv_raisesIRQL_SAL1_1_Source_(__drv_raisesIRQL, (), _IRQL_raises_)_IRQL_raises_(irql)__drv_setsIRQL(irql)__drv_neverHoldGlobal(kind,param)_SAL1_1_Source_(__drv_neverHoldGlobal, (kind, param), _Requires_lock_not_held_(param))__drv_innerNeverHoldGlobal(kind,param)_SAL_L_Source_(__drv_innterNeverHoldGlobal, (#kind, param\t), _Pre_ _SA_annotes2(SAL_neverHoldGlobal, #kind, param\t))__drv_neverHold(kind)_SAL1_1_Source_(__drv_neverHold, (kind), _Requires_lock_not_held_(_Curr_))_Kernel_requires_resource_not_held_(kind)_SAL2_Source_(_Kernel_requires_resource_not_held_, (#kind), _Pre_ _SA_annotes1(SAL_neverHold, #kind))__drv_mustHoldGlobal(kind,param)_SAL1_1_Source_(__drv_mustHoldGlobal, (kind, param), _Requires_lock_held_(param))__drv_innerMustHoldGlobal(kind,param)_SAL_L_Source_(__drv_innerMustHoldGlobal, (#kind, param\t), _Pre_ _SA_annotes2(SAL_mustHoldGlobal, #kind, param\t))__drv_mustHold(kind)_SAL_L_Source_(_drv_mustHold, (kind), _When_(!_Arg_comp_(#kind,"Memory"), _Requires_lock_held_(_Curr_)) _When_(_Arg_comp_(#kind,"Memory"), _Kernel_requires_resource_held_(kind)))_Kernel_requires_resource_held_(kind)_SAL2_Source_(_Kernel_requires_resource_held_, (#kind), _Pre_ _SA_annotes1(SAL_mustHold, #kind))__drv_releasesResourceGlobal(kind,param)_SAL1_1_Source_(__drv_releasesResourceGlobal, (kind, param), _Releases_lock_(param))__drv_innerReleasesGlobal(kind,param)_SAL1_1_Source_(__drv_InnerReleasesGlobal, (#kind, param\t), _Post_ _SA_annotes2(SAL_releaseGlobal,#kind, param\t))__drv_acquiresResourceGlobal(kind,param)_SAL1_1_Source_(__drv_acquiresResourceGlobal, (kind, param), _Acquires_lock_(param))__drv_innerAcquiresGlobal(kind,param)_SAL1_1_Source_(_drv_innerAcquiresGlobal, (#kind, param\t), _Post_ _SA_annotes2(SAL_acquireGlobal, #kind, param\t))__drv_releasesResource(kind)_SAL1_1_Source_(__drv_releasesResource, (kind), _Releases_lock_(_Curr_))_Kernel_releases_resource_(kind)_SAL2_Source_(_Kernel_releases_resource_, (#kind), _Post_ _SA_annotes1(SAL_release, #kind))__drv_acquiresResource(kind)_SAL1_1_Source_(__drv_acquiresResource, (kind), _Acquires_lock_(_Curr_))_Kernel_acquires_resource_(kind)_SAL2_Source_(_Kernel_acquires_resource_, (#kind), _Post_ _SA_annotes1(SAL_acquire, #kind))__drv_functionClass(x)_SAL1_Source_(__drv_functionClass, (x), _Function_class_(x))__drv_defined(x)_Macro_defined_( #x )___drv_unit_user_code_SAL_L_Source_(___drv_unit_user_code, (), _SA_annotes0(SAL_nokernel) _SA_annotes0(SAL_nodriver))___drv_unit_user_driver_SAL_L_Source_(___drv_unit_user_driver, (), _SA_annotes0(SAL_nokernel) _SA_annotes0(SAL_driver))___drv_unit_kernel_driver_SAL_L_Source_(___drv_unit_kernel_driver, (), _SA_annotes0(SAL_kernel) _SA_annotes0(SAL_driver))___drv_unit_kernel_code_SAL_L_Source_(___drv_unit_kernel_code, (), _SA_annotes0(SAL_kernel) _SA_annotes0(SAL_nodriver))___drv_unit_internal_kernel_driver_SAL_L_Source_(__drv_unit_internal_kernel_driver, (), _SA_annotes0(SAL_internal_kernel_driver))__drv_unit(p)typedef int ___drv_unit_ ## p __GENSYM(__prefast_flag_kernel_driver_mode);__drv_arg(expr,annotes)__drv_ret(annotes)_At_(return,annotes _SAL_nop_impl_)__drv_fun(annotes)__drv_at(expr,annotes)_At_(expr, annotes _SAL_nop_impl_)__drv_when(cond,annotes)_When_(cond, annotes _SAL_nop_impl_)__drv_out_deref(annotes)_Post_ __deref _Group_(annotes _SAL_nop_impl_)__drv_out(annotes)_Post_ _Group_(annotes _SAL_nop_impl_)__drv_in_deref(annotes)_Pre_ __deref _Group_(annotes _SAL_nop_impl_)__drv_in(annotes)_Pre_ _Group_(annotes _SAL_nop_impl_)__drv_deref(annotes)__deref _Group_(annotes _SAL_nop_impl_)_IRQL_limited_to_(level)ASSERT(KeGetCurrentIrql() <= level); _Analysis_assume_(KeGetCurrentIrql() <= level);_Analysis_assume_section_unlocked_(name)_Analysis_assume_section_locked_(name)__prefast_operator_new_null__prefast_operator_new_throws__drv_NDIS__drv_KMDF__drv_WDM__drv_Mode_impl(x)__user_code__user_driver__kernel_driver__kernel_code__internal_kernel_driverDRIVERSPECS_HSPECSTRINGS_H_MSC_VER > 1000(_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_) && defined(_MSC_EXTENSIONS)_Is_driver_(void);_Is_kernel_(void);SAL_callbackType(__In_impl_ __AuToQuOtE char *);SAL_completionType(__In_impl_ __AuToQuOtE char *);SAL_IsFormatString(__In_impl_ char *);SAL_floatUsed(void);SAL_floatRestored(void);SAL_floatSaved(void);SAL_error2(__In_impl_ __AuToQuOtE char *, __In_impl_ __int64);SAL_error(__In_impl_ __AuToQuOtE char *);SAL_preferredFunction3(__In_impl_ __AuToQuOtE char *, __In_impl_ __AuToQuOtE char *, __In_impl_ __int64);SAL_preferredFunction(__In_impl_ __AuToQuOtE char *, __In_impl_ __AuToQuOtE char *);SAL_NeedsRelease(enum __SAL_YesNo);SAL_IsAliased(void);SAL_strictType(__In_impl_ __AuToQuOtE char *);SAL_strictTypeMatch(__int64);SAL_return(__In_impl_ __AuToQuOtE char *);SAL_IoGetDmaAdapter(void);SAL_clearDoInit(enum __SAL_YesNo);_Holds_resource_global_(__In_impl_ char *, ...);_Holds_resource_(__In_impl_ __deferTypecheck char *,__In_impl_ char *);SAL_neverHoldGlobal(__In_impl_ char *, ...);SAL_neverHold(__In_impl_ char *);SAL_mustHoldGlobal(__In_impl_ char *, ...);SAL_mustHold(__In_impl_ char *);SAL_releaseGlobal(__In_impl_ char *, ...);SAL_acquireGlobal(__In_impl_ char *, ...);SAL_release(__In_impl_ char *);SAL_acquire(__In_impl_ char *);// DRIVERSPECS_H// Check if this is kernel or driver code/* legacy *//* see kernelspecs.h */// Passing the cancel Irql to a utility function// PriorityRegion// CriticalRegion// CancelSpinLock// Exclusive Resources// [ expand to nothing immediately to avoid RC problem// Composite:// ---------------------------------------------------------------------// Legacy function class for driver callback functions (FDO or PDO):// Legacy function class for driver completion functions:// Legacy function class for driver dispatch functions - special case:// Legacy function class for driver dispatch functions:// Function class for driver dispatch functions:// Function classes for drivers:// kind can be "printf", "scanf", "strftime" or "FormatMessage".// FormatString:// The function must not be called inside a try block// The function must be called inside a try block// The parameter is used for interlocked instructions.// __drv_notInTry// __drv_inTry// __drv_interlocked// Usage:// in their type signature get this automatically.// The function uses floating point.  Functions with floating point// The floating point hardware was restored (no longer available)// The floating point hardware was saved (available to kernel)// __drv_floatUsed         (legacy, replaced by _Kernel_float_used_)// __drv_floatRestored     (legacy, replaced by _Kernel_float_restored_)// __drv_floatSaved        (legacy, replaced by _Kernel_float_saved_)// _Kernel_float_used_// _Kernel_float_restored_// _Kernel_float_saved_// Floating point save/restore:// The error given by 'why' was detected.  Used conditionally.// conditionally.// Function 'func' should be used for reason 'why'.  Often used// __drv_reportError// __drv_preferredFunction// Additional diagnostics// and "object" for new/delete.// Kind is unused, but should be "mem" for malloc/free// Allocate/release memory-like objects.// alias, and relieving any obligation to free the object.// The annotated parameter is "kept" by the function, creating an// __drv_freesMem// __drv_allocatesMem// __drv_aliasesMem// Memory management// Convenience for the most common form of the above.// intended).// are needed (because &pXXX is a common error when pXXX is// prevent passing pointers to pointers when pointers to structures// The actual parameter must be data (not a pointer).  Used to// plus literal constants// plus all operators// plus ?:// constants of that type//    The following modes are defined:// currently 1/2 args// within the specifications set by mode.// The actual parameter must match the type of typename (below)// The actual parameter must match the type of the annotated formal// (exclusive of a const symbol).// The actual parameter may never evaluate to a numeric constant// The actual parameter must evaluate to a constant (not a const).// __drv_strictType(type,mode)// __drv_strictTypeMatch(mode)// __drv_nonConstant// __drv_constant// Additional parameter checking.// See the documentation for use of this.// a comma-separated list.  In the future __VA_ARGS__ could be used.// This is a ; separated list of values.  The internal parser will accept// e.g. ==0 or <0.// during simulation.  The items in the list are <relational op><constant>,// The function being annotated will return each of the specified values// __drv_valueIs(<list>)// Function and out parameter return values.// This is (or is like) IoGetDmaAdapter: look for misuse of DMA pointers// is cleared (or not).// The annotated function clears the requirement that DoInitializeing// Specific function behaviors// value will be inserted.  (Use this in preference to directly coding it.)// The annotated parameter is an IRQL that will be restored and a new (probably the same)// by the called function.// The annotated parameter contains the cancelIRQL, which will be restored// (It may change it but it must restore it.)// The function must exit with the same IRQL it was entered with.// The maximum IRQL to which the function can raise itself.// at entry is assumed to be that value unless overridden.// The minimum IRQL to which the function can lower itself.  The IRQL// object identified by kind and further refined by param.// The current IRQL is restored from the (otherwise anonymous) global// The current IRQL is restored from the annotated parameter// identified by kind and further refined by param.// The current IRQL is saved in the (otherwise anonymous) global object// The current IRQL is saved in the annotated parameter// The minimum IRQL at which the function may be called.// The maximum IRQL at which the function may be called.// The called function must be entered at IRQL level// The function exits at IRQL irql, but this may only raise the irql./* see kernelspecs.h, legacy */// The function exits at IRQL irql (obsolete, use _IRQL_raises_)//   __drv_useCancelIRQL       _IRQL_uses_cancel_//   __drv_sameIRQL            _IRQL_requires_same_//   __drv_maxFunctionIRQL     _IRQL_always_function_max_//   __drv_minFunctionIRQL     _IRQL_always_function_min_//   __drv_restoresIRQLGlobal  _IRQL_restores_global_//   __drv_restoresIRQL        _IRQL_restores_//   __drv_savesIRQLGlobal     _IRQL_saves_global_//   __drv_savesIRQL           _IRQL_saves_//   __drv_minIRQL             _IRQL_requires_min_//   __drv_maxIRQL             _IRQL_requires_max_//   __drv_requiresIRQL        _IRQL_requires_//   __drv_raisesIRQL          _IRQL_raises_//   __drv_setsIRQL            (Obsolete, use _IRQL_raises_)//   Legacy annotation:        Use instead:// Legacy IRQL annotations:// // _IRQL_uses_cancel_// _IRQL_requires_same_// _IRQL_always_function_max_(irql)// _IRQL_always_function_min_(irql)// _IRQL_restores_global_(kind,param)// _IRQL_restores_// _IRQL_saves_global_(kind,param)// _IRQL_saves_// _IRQL_requires_min_(irql)// _IRQL_requires_max_(irql)// _IRQL_requires_(irql)// _IRQL_raises_(irql)// IRQL annotations:// Predicates to determine if a resource is held// of type kind named by param.// Flag that the annotated object must never hold a global resource// Flag that the annotated parameter must never hold a resource of type kind// Flag that the annotated object must hold a global resource named by param// Flag that the annotated parameter must hold a resource of type kind// Flag that the annotated object releases a global resource named by param// Flag that the annotated object acquires a global resource named by param// Flag that the annotated parameter releases a resource of type kind.// Flag that the annotated parameter acquires a resource of type kind.// __drv_neverHoldGlobal(kind,param)// __drv_mustHoldGlobal(kind,param)// __drv_neverHold(kind)// __drv_mustHold(kind)// __drv_releasesResourceGlobal(kind,param)// __drv_acquiresResourceGlobal(kind,param)// __drv_releasesResource(kind)// __drv_acquiresResource(kind)// Resources:// This can be tested by the condition function _In_function_class_()// by PREfast itself for special treatment.// is a member of that function class. Some class names are recognized// Flag that the the annotated function// __drv_functionClass(x)// Callback properties:// This should only be used inside a _When_ condition.// where it's defined with no value.// So we can use a macro name that might be used in #ifdef context,// Needed to make the annotations convenient to use.// Syntatic utilities:// These are needed for backwards compatability.// Indicate that the code is ordinary user mode code.// Indicate that the code is a user mode driver.// Indicate that the code is kernel, driver, code.// Indicate that the code is kernel, but not driver, code.// successfully parse.// or after __internal_kernel_driver is immaterial as long as it will// (.c/.cpp file) that doesn't get the correct default.     Whether before// These should be coded as early as possible in any compilation unit// code it is.// Flags for compilation units that indicated specifically what kind of// __drv_unit// Internal macros for convenience//   __drv_in(__drv_nonconstant __setsIRQL)// For example:// simpler.// core macros: these provide syntatic wrappers to make other uses// 'level'// Callback with high IRQL level will never actually be called above // This is only used when dynamically locked pages are being used.// memory, and calls to that section are deemed safe.// Past this point, the named section is assumed to be locked in//       locked in memory.//       A call will be made to <n>, and we should assume it is [not]//    _Analysis_assume_section_unlocked_(n)//    _Analysis_assume_section_locked_(n)// Paging information:// could change.// Be sure to use these macros for this purpose as the implementation// this after that header is included.// Header <new> will set the default to throwing, so be sure to place// operator new.// standard conformant, but much kernel code links with a non-throwing// these.  The default is throwing (and cannot return NULL) which is// Be sure you really know which is actually in use before using one of// Inform PREfast that operator new does [not] throw.// of driver.// Macros to declare a function to be a particular class// analysis tools, as needed.// "landmark" function definition to pass information to the// or after __internal_kernel_driver// (.c/.cpp file) that doesn't get the correct default.  Whether before// __user_code// __user_driver// __kernel_driver// __kernel_code// ';' inside the parens to keep MIDL happy// default to kernel mode driver.// as the "primary" header for a class of drivers.  It sets the// This should only be coded in headers that are normally used// Flag for headers that indicates a probable driver.// __internal_kernel_driver// Processing mode selection:// In case driverspecs.h is included directly (and w/o specstrings.h)/*****************************************************************************\
* The annotations described by KernelSpecs.h and DriverSpecs.h, taken together,
* are used to annotate drivers.  Many of the annotations are applicable to
* user space code (including subsystems) as well as to drivers.
*
* DriverSpecs.h contains those annotations which are appropriate to userspace
* code, or which might appear in headers that are shared between user space
* and kernel space.  In the case of annotations which might appear in such a
* shared header, but which are meaningless in user space, the annotations are
* #defined to nothing in DriverSpecs.h.
*
* KernelSpecs.h contains those annotations which either will only appear in
* kernel code or headers; or which might appear in shared headers.  In the
* latter case, it is assumed that DriverSpecs.h has been #included, and
* the anntoations are re-defined (using #undef) to give them a meaningful
* value.  In general, documentation for the shared-header annotations appears
* in DriverSpecs.h.
*
* Many annotations are context dependent.  They only apply to certain versions
* of Windows, or only to certain classes of driver.  These rules can be written
* using something like _When_(NTDDI_VERSION >= NTDDI_WINXP, ...)
* which causes the rule only to apply to Windows XP and later.  Many of these
* symbols are already defined in various Windows headers.
*
* To facilitate using this sort of conditional rule, we collect here the
* various known symbols that are (or reasonably might) be used in such
* a conditional annotation.  Some are speculative in that the symbol has
* not yet been defined because there are no known uses of it yet.
*
* Where the symbol already exists its relevant header is
* noted below (excluding the "really well known" ones).
*
* Each symbol is listed with the currently known possible values.
*
* Some symbols are marked as #define symbols -- they are used with #ifdef
* operators only.  To use them in _When_, use something like
* _When_(__drv_defined(NT), ...).
*
* WDK Version (copied for convenience from sdkddkver.h)
*     NTDDI_VERSION: NTDDI_WIN2K NTDDI_WIN2KSP1 NTDDI_WIN2KSP2 NTDDI_WIN2KSP3
*                    NTDDI_WIN2KSP4 NTDDI_WINXP NTDDI_WINXPSP1 NTDDI_WINXPSP2
*                    NTDDI_WS03 NTDDI_WS03SP1 NTDDI_VISTA
*     The WDK version is taken as the WDM version as well.
*
* OS Version: (copied for convenience from sdkddkver.h)
*     _WIN32_WINNT: _WIN32_WINNT_NT4 _WIN32_WINNT_WIN2K _WIN32_WINNT_WINXP
*                   _WIN32_WINNT_WS03 _WIN32_WINNT_LONGHORN
*     WINVER: 0x030B 0x0400 0x0500 0x0600
*     NT (#define symbol)
* (sdkddkver.h also defines symbols for IE versions should they be needed.)
*
* Compiler Version:
*     _MSC_VER: too many to list.
*     _MSC_FULL_VER: too many to list.
*
* KMDF Version:  (Currently defined/used only in makefiles.)
*     KMDF_VERSION_MAJOR: 1
*
* UMDF Version:  (Currently defined/used only in makefiles.)
*     UMDF_VERSION_MAJOR: 1
*
* Architecture kinds:
*     __WIN64 (#define symbols)
*     _X86_
*     _AMD64_
*     _IA64_
*
* Machine Architectures:
*     _M_IX86
*     _M_AMD64
*     _M_IA64
*
* Driver Kind (NYI: "not yet implemented")
*   Typically these will be defined in the most-common header for a
*   particular driver (or in individual source files if appropriate).
*   These are not intended to necessarily be orthogonal: more than one might
*   apply to a particular driver.
*     _DRIVER_TYPE_BUS: 1                // NYI
*     _DRIVER_TYPE_FUNCTIONAL: 1         // NYI
*     _DRIVER_TYPE_MINIPORT: 1           // NYI
*     _DRIVER_TYPE_STORAGE: 1            // NYI
*     _DRIVER_TYPE_DISPLAY: 1            // NYI
*     _DRIVER_TYPE_FILESYSTEM: 1
*     _DRIVER_TYPE_FILESYSTEM_FILTER: 1
*
* NDIS driver version: (see ndis.h for much more detail.)
*   These can be used to both identify an NDIS driver and to check the version.
*     NDIS40 NDIS50 NDIS51 NDIS60 (#defined symbols)
*     NDIS_PROTOCOL_MAJOR_VERSION.NDIS_PROTOCOL_MINOR_VERSION: 4.0 5.0 5.1 6.0
*     And many others in ndis.h (including MINIPORT)
*
\*****************************************************************************//*****************************************************************************\
* NOTE                                                                        *
* NOTE                                                                        *
* NOTE                                                                        *
*   The macro bodies in this file are subject to change without notice.       *
*   Attempting to use the annotations in the macro bodies directly is not     *
*   supported.                                                                *
* NOTE                                                                        *
* NOTE                                                                        *
* NOTE                                                                        *
\*****************************************************************************//*****************************************************************************\
*                                                                             *
* DriverSpecs.h - markers for documenting the semantics of driver APIs        *
*                 See also <SpecStrings.h>                                    *
*                                                                             *
* Version 1.2.10                                                              *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/specstrings.h<driverspecs.h><specstrings_strict.h>_Translates_last_error_to_HRESULT__SAL2_Source_(_Translates_last_error_to_HRESULT_, (), _Always_( _Post_satisfies_(_Curr_ < 0)))_Translates_NTSTATUS_to_HRESULT_(status)_SAL2_Source_(_Translates_NTSTATUS_to_HRESULT_, (status), _Always_( _Post_equal_to_((HRESULT)(status | FACILITY_NT_BIT))))_Translates_Win32_to_HRESULT_(errorCode)_SAL2_Source_(_Translates_Win32_to_HRESULT_, (errorCode), _Always_( _When_((HRESULT)errorCode <= 0, _At_(_Curr_, _Post_equal_to_((HRESULT)errorCode))) _When_((HRESULT)errorCode > 0, _At_(_Curr_, _Post_equal_to_((HRESULT)((errorCode & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000))))))_Post_equals_last_error__SAL2_Source_(_Post_equals_last_error_, (), _Post_satisfies_(_Curr_ != 0))_Writes_bytes_and_advances_ptr_(size)_SAL2_Source_(_Writes_bytes_and_advances_ptr, (size), _At_((void*)_Curr_, _Inout_) _At_(_Curr_, _Pre_writable_byte_size_(size) _Post_writable_byte_size_(size) _Post_satisfies_(((char*)_Curr_) - ((char*)_Old_(_Curr_)) == _Old_(size) - size)) _At_(_Old_(_Curr_), _Post_readable_byte_size_(_Old_(size) - size)))_Writes_and_advances_ptr_(size)_SAL2_Source_(_Writes_and_advances_ptr_, (size), _At_((void*)_Curr_, _Inout_) _At_(_Curr_, _Pre_writable_size_(size) _Post_writable_size_(size) _Post_satisfies_(_Curr_ - _Old_(_Curr_) == _Old_(size) - size)) _At_(_Old_(_Curr_), _Post_readable_size_(_Old_(size) - size)))_Flt_ConnectionCookie_Outptr__SAL_L_Source_(_Flt_ConnectionCookie_Outptr_, (), _Outptr_result_maybenull_ _Pre_valid_ _At_(*_Curr_, _Pre_null_ _On_failure_(_Post_null_)))_Flt_CompletionContext_Outptr__SAL_L_Source_(_Flt_CompletionContext_Outptr_, (), _Outptr_result_maybenull_ _Pre_valid_ _At_(*_Curr_, _Pre_null_ _When_(return != FLT_PREOP_SUCCESS_WITH_CALLBACK && return != FLT_PREOP_SYNCHRONIZE, _Post_null_)))_In_NLS_string_(size)_SAL_L_Source_(_In_NLS_string_, (size), _When_((size) < 0, _In_z_) _When_((size) >= 0, _In_reads_(size)))_Ret_reallocated_bytes_(before,size)_Reallocation_function_(_Curr_, before, size)_Reallocation_function_(after,before,size)_Success_((after) != NULL || (size) == 0) _At_((after), _Post_maybenull_ _Post_writable_byte_size_(size) _When_(((before) == NULL || (size) > 0), _Must_inspect_result_)) _At_((before), _Post_ptr_invalid_ __drv_freesMem(Mem))_Frees_ptr_opt__SAL_L_Source_(_Frees_ptr_opt_, (), _Pre_maybenull_ _Post_ptr_invalid_ __drv_freesMem(Mem))_Frees_ptr__SAL_L_Source_(_Frees_ptr_, (), _Pre_notnull_ _Post_ptr_invalid_ __drv_freesMem(Mem))_Unreferenced_parameter__SAL2_Source_(_Unreferenced_parameter_, (), _Const_)__inner_assume_bound(i)__assume_validated(p)__inner_assume_validated(p)_SAL_L_Source_(__deref_nonvolatile, (), __deref __nonvolatile)_SAL_L_Source_(__deref_volatile, (), __deref __volatile)_SAL_L_Source_(__nonvolatile, (), __inner_nonvolatile)_SAL_L_Source_(__volatile, (), __inner_volatile)_SAL_L_Source_(__possibly_notnullterminated, (), __inner_possibly_notnullterminated)_SAL_L_Source_(__out_has_type_adt_props, (typ), _Post_ __inner_adt_type_props(typ))_SAL_L_Source_(__out_transfer_adt_prop, (arg), _Post_ __inner_adt_transfer_prop(arg))_SAL_L_Source_(__out_not_has_adt_prop, (adt,prop), _Post_ __inner_adt_remove_prop(adt,prop))_SAL_L_Source_(__out_has_adt_prop, (adt,prop), _Post_ __inner_adt_add_prop(adt,prop))_SAL_L_Source_(__type_has_adt_prop, (adt,prop), __inner_adt_prop(adt,prop))_SAL_L_Source_(__field_encoded_array, (), __inner_encoded)_SAL_L_Source_(__field_encoded_pointer, (), __inner_encoded)_SAL_L_Source_(__encoded_array, (), __inner_encoded)_SAL_L_Source_(__encoded_pointer, (), __inner_encoded)_SAL_L_Source_(__gdi_entry, (), __inner_control_entrypoint(GDI))_SAL_L_Source_(__kernel_entry, (), __inner_control_entrypoint(UserToKernel))_SAL_L_Source_(__rpc_entry, (formal), __inner_control_entrypoint(RPC))_SAL_L_Source_(__transfer, (src_sym), _Post_ __inner_transfer(formal))__this_out_validated(typ_sym)_SAL_L_Source_(__this_out_validated, (src_sym), __inner_this_out_validated(#typ_sym))__this_out_data_source(src_sym)_SAL_L_Source_(__this_out_data_source, (src_sym), __inner_this_data_source(#src_sym))__out_validated(typ_sym)_SAL_L_Source_(__out_validated, (src_sym), __inner_out_validated(#typ_sym))_SAL_L_Source_(__out_data_source, (src_sym), _Post_ __inner_data_source(#src_sym))_SAL_L_Source_(__in_data_source, (src_sym), _Pre_ __inner_data_source(#src_sym))_SAL_L_Source_(__range_min, (a,b), __range(==, a < b ? a : b))_SAL_L_Source_(__range_max, (a,b), __range(==, a > b ? a : b))_SAL_L_Source_(__field_data_source, (lb,ub), __inner_data_source(#src_sym))_SAL_L_Source_(__field_range, (lb,ub), __range(lb,ub))_SAL_L_Source_(__deref_inout_range, (lb,ub), __deref_in_range(lb,ub) __deref_out_range(lb,ub))_SAL_L_Source_(__deref_out_range, (lb,ub), _Post_ __deref __inner_range(lb,ub))_SAL_L_Source_(__deref_in_range, (lb,ub), _Pre_ __deref __inner_range(lb,ub))_SAL_L_Source_(__out_range, (lb,ub), _Post_ __inner_range(lb,ub))_SAL_L_Source_(__in_range, (lb,ub), _Pre_ __inner_range(lb,ub))_SAL_L_Source_(__deref_out_bound, (), _Post_ __deref __inner_bound)_SAL_L_Source_(__out_bound, (), _Post_ __inner_bound)_SAL_L_Source_(__in_bound, (), _Pre_ __inner_bound)_SAL_L_Source_(__range, (lb,ub), __inner_range(lb,ub))_SAL_L_Source_(__bound, (), __inner_bound)_SAL_L_Source_(__deallocate_opt, (kind), _Pre_ __maybenull __post_invalid)_SAL_L_Source_(__deallocate, (kind), _Pre_ __notnull __post_invalid)_SAL_L_Source_(__allocator, (), __inner_allocator)_SAL1_Source_(__post_invalid, (), _Post_ __notvalid)_SAL1_Source_(__in_awcount, (expr,size), _Pre_ __valid _Pre_ _Notref_ __deref __readonly __byte_readableTo((expr) ? (size) : (size) * 2))_SAL1_Source_(__out_awcount, (expr,size), _Pre_ __notnull __byte_writableTo((expr) ? (size) : (size) * 2) _Post_ __valid __refparam)_SAL1_Source_(__struct_xcount, (size), __inexpressible_writableTo(size))_SAL1_Source_(__struct_bcount, (size), __byte_writableTo(size))_SAL1_Source_(__field_nullterminated, (), __nullterminated)_SAL1_Source_(__field_xcount_full_opt, (size), __field_xcount_part_opt(size,size))_SAL1_Source_(__field_bcount_full_opt, (size), __field_bcount_part_opt(size,size))_SAL1_Source_(__field_ecount_full_opt, (size), __field_ecount_part_opt(size,size))_SAL1_Source_(__field_xcount_full, (size), __field_xcount_part(size,size))_SAL1_Source_(__field_bcount_full, (size), __field_bcount_part(size,size))_SAL1_Source_(__field_ecount_full, (size), __field_ecount_part(size,size))_SAL1_Source_(__field_xcount_part_opt, (size,init), __maybenull __inexpressible_writableTo(size) __inexpressible_readableTo(init))_SAL1_Source_(__field_bcount_part_opt, (size,init), __maybenull __byte_writableTo(size) __byte_readableTo(init))_SAL1_Source_(__field_ecount_part_opt, (size,init), __maybenull __elem_writableTo(size) __elem_readableTo(init))_SAL1_Source_(__field_xcount_part, (size,init), __notnull __inexpressible_writableTo(size) __inexpressible_readableTo(init))_SAL1_Source_(__field_bcount_part, (size,init), __notnull __byte_writableTo(size) __byte_readableTo(init))_SAL1_Source_(__field_ecount_part, (size,init), __notnull __elem_writableTo(size) __elem_readableTo(init))_SAL1_Source_(__field_xcount_opt, (size), __maybenull __inexpressible_writableTo(size))_SAL1_Source_(__field_bcount_opt, (size), __maybenull __byte_writableTo(size))_SAL1_Source_(__field_ecount_opt, (size), __maybenull __elem_writableTo(size))_SAL1_Source_(__field_xcount, (size), __notnull __inexpressible_writableTo(size))_SAL1_Source_(__field_bcount, (size), __notnull __byte_writableTo(size))_SAL1_Source_(__field_ecount, (size), __notnull __elem_writableTo(size))_Kernel_entry_always__Kernel_entry__User_always_and_needs_probe_on_(mode)_User_always__User_on_(expr)_User__Pre_accessible_bytes_when_(context,previousContext,expr)_Pre_accessible_bytes_(context,expr)_Accessible_bytes_when_(previousContext,context,expr)_Accessible_bytes_(context,expr)_Memory_origin_when_(previousContext,context)_Memory_origin_(context)__inner_adt_type_props(typ)__inner_adt_transfer_prop(arg)__inner_adt_remove_prop(adt,prop)__inner_adt_add_prop(adt,prop)__inner_adt_prop(adt,prop)__inner_transfer(formal)__inner_this_out_validated(typ_raw)__inner_out_validated(typ_raw)__inner_this_data_source(src_raw)__inner_data_source(src_raw)__analysis_noreturn__analysis_assert(e)__class_code_content(typ)__source_code_content(typ)__file_parser_library(typ)__file_parser_class(typ)__file_parser(typ)_SAL1_Source_(__post_nullnullterminated, (), _Post_ __inexpressible_readableTo("string terminated by two nulls") _Post_ __nullterminated)_SAL1_Source_(__nullnullterminated, (), __inexpressible_readableTo("string terminated by two nulls") __nullterminated)__in_ecount_or_z(c)_SAL1_Source_(__in_ecount_or_z, (c), _When_(_String_length_(_Curr_) < (c), __in_z) _When_(_String_length_(_Curr_) >= (c), __in_ecount(c)))_SAL1_Source_(__deref_realloc_bcount, (insize,outsize), __inout _Pre_ __deref __byte_readableTo(insize) _Post_ __deref __byte_writableTo(outsize))__post_ecount(size)_SAL1_Source_(__post_ecount, (size), _Post_ __elem_writableTo(size))__post_bcount(size)_SAL1_Source_(__post_bcount, (size), _Post_ __byte_writableTo(size))_SAL1_Source_(__deref_inout_ecount_iterator, (size,incr), __inout _Pre_ __deref __elem_readableTo(size) _Pre_ __deref __elem_writableTo(size) __deref_out_range(==, _Old_(*_Curr_) + incr))_SAL1_Source_(__deref_out_ecount_iterator, (size,incr), __inout _Pre_ __deref __elem_writableTo(size) __deref_out_range(==, _Old_(*_Curr_) + incr))_SAL1_Source_(__deref_in_ecount_iterator, (size,incr), __inout _Pre_ __deref __elem_readableTo(size) __deref_out_range(==, _Old_(*_Curr_) + incr))_SAL1_Source_(__deref_opt_inout_scount_full_opt, (size), __deref_inout_xcount_full_opt(size) __exceptthat __maybenull)__deref_opt_inout_xcount_part_opt(size,length)_SAL1_Source_(__deref_inout_xcount_part_opt(size, (size,length), length) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_inout_xcount_opt, (size), __deref_inout_xcount_opt(size) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_out_scount_full_opt, (size), __deref_out_xcount_full_opt(size) __exceptthat __maybenull)__deref_opt_out_xcount_part_opt(size,length)_SAL1_Source_(__deref_opt_out_xcount_part_opt, (size,length), __deref_out_xcount_part_opt(size,length) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_out_xcount_opt, (size), __deref_out_xcount_opt(size) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_in_xcount_opt, (size), __deref_in_xcount_opt(size) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_in_bcount_opt, (size), __deref_in_bcount_opt(size) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_in_ecount_opt, (size), __deref_in_ecount_opt(size) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_in_opt, (), __deref_in_opt __exceptthat __maybenull)_SAL1_Source_(__deref_opt_xcount_opt, (size), __deref_xcount_opt(size) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_inout_xcount_full, (size), __deref_inout_xcount_full(size) __exceptthat __maybenull)__deref_opt_inout_xcount_part(size,length)_SAL1_Source_(__deref_opt_inout_xcount_part, (size,length), __deref_inout_xcount_part(size,length) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_inout_xcount, (size), __deref_inout_xcount(size) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_out_xcount_full, (size), __deref_out_xcount_full(size) __exceptthat __maybenull)__deref_opt_out_xcount_part(size,length)_SAL1_Source_(__deref_opt_out_xcount_part, (size,length), __deref_out_xcount_part(size,length) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_out_xcount, (size), __deref_out_xcount(size) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_in_xcount, (size), __deref_in_xcount(size) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_in_bcount, (size), __deref_in_bcount(size) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_in_ecount, (size), __deref_in_ecount(size) __exceptthat __maybenull)_SAL1_Source_(__deref_opt_in, (), __deref_in __exceptthat __maybenull)_SAL1_Source_(__deref_opt_xcount, (size), __deref_xcount(size) __exceptthat __maybenull)_SAL1_Source_(__deref_inout_xcount_full_opt, (size), __deref_inout_xcount_full(size) _Pre_ __deref __exceptthat __maybenull _Post_ __deref __exceptthat __maybenull)__deref_inout_xcount_part_opt(size,length)_SAL1_Source_(__deref_inout_xcount_part_opt, (size,length), __deref_inout_xcount_part(size,length) _Pre_ __deref __exceptthat __maybenull _Post_ __deref __exceptthat __maybenull)_SAL1_Source_(__deref_inout_xcount_opt, (size), __deref_inout_xcount(size) _Pre_ __deref __exceptthat __maybenull _Post_ __deref __exceptthat __maybenull)_SAL1_Source_(__deref_out_xcount_full_opt, (size), __deref_out_xcount_full(size) _Post_ __deref __exceptthat __maybenull)__deref_out_xcount_part_opt(size,length)_SAL1_Source_(__deref_out_xcount_part_opt, (size,length), __deref_out_xcount_part(size,length) _Post_ __deref __exceptthat __maybenull)_SAL1_Source_(__deref_out_xcount_opt, (size), __deref_out_xcount(size) _Post_ __deref __exceptthat __maybenull)_SAL1_Source_(__deref_in_xcount_opt, (size), __deref_in_xcount(size) _Pre_ __deref __exceptthat __maybenull)_SAL1_Source_(__deref_in_bcount_opt_, (size), __deref_in_bcount(size) _Pre_ __deref __exceptthat __maybenull)_SAL1_Source_(__deref_in_ecount_opt, (size), __deref_in_ecount(size) _Pre_ __deref __exceptthat __maybenull)_SAL1_Source_(__deref_in_opt_out, (), __deref_inout _Pre_ __deref __exceptthat __maybenull _Post_ __deref __notnull)_SAL1_Source_(__deref_in_opt, (), __deref_in _Pre_ __deref __exceptthat __maybenull)_SAL1_Source_(__deref_xcount_opt, (size), __deref_xcount(size) _Post_ __deref __exceptthat __maybenull)_SAL1_Source_(__deref_inout_xcount_full, (size), __deref_inout_xcount_part(size,size))__deref_inout_xcount_part(size,length)_SAL1_Source_(__deref_inout_xcount_part, (size,length), __deref_inout_xcount(size) _Pre_ __deref __inexpressible_readableTo(length) _Post_ __deref __inexpressible_readableTo(length))_SAL1_Source_(__deref_inout_xcount, (size), __deref_inout _Pre_ __deref __inexpressible_writableTo(size) _Post_ __deref __inexpressible_writableTo(size))_SAL1_Source_(__deref_out_xcount, (size), __deref_xcount(size) _Post_ __deref __valid __refparam)_SAL1_Source_(__deref_out_xcount_full, (size), __deref_out_xcount_part(size,size))__deref_out_xcount_part(size,length)_SAL1_Source_(__deref_out_xcount_part, (size,length), __deref_out_xcount(size) _Post_ __deref __inexpressible_readableTo(length))_SAL1_Source_(__deref_in_xcount, (size), __deref_in _Pre_ __deref __inexpressible_readableTo(size))_SAL1_Source_(__deref_in_bcount, (size), __deref_in _Pre_ __deref __byte_readableTo(size))_SAL1_Source_(__deref_in_ecount, (size), __deref_in _Pre_ __deref __elem_readableTo(size))_SAL1_Source_(__deref_in, (), __in _Pre_ __deref __deref __readonly)_SAL1_Source_(__deref_xcount, (size), __ecount(1) _Post_ __elem_readableTo(1) _Post_ __deref __notnull _Post_ __deref __inexpressible_writableTo(size))_SAL1_Source_(__inout_xcount_opt, (size), __inout_xcount(size) __exceptthat __maybenull)_SAL1_Source_(__inout_xcount_full_opt, (size), __inout_xcount_full(size) __exceptthat __maybenull)__inout_xcount_part_opt(size,length)_SAL1_Source_(__inout_xcount_part_opt, (size, length), __inout_xcount_part(size,length) __exceptthat __maybenull)_SAL1_Source_(__out_xcount_full_opt, (size), __out_xcount_full(size) __exceptthat __maybenull)__out_xcount_part_opt(size,length)_SAL1_Source_(__out_xcount_part_opt, (size,length), __out_xcount_part(size,length) __exceptthat __maybenull)_SAL1_Source_(__out_xcount_opt, (size), __out_xcount(size) __exceptthat __maybenull)_SAL1_Source_(__in_xcount_opt, (size), __in_xcount(size) __exceptthat __maybenull)_SAL1_Source_(__xcount_opt, (size), __xcount(size) __exceptthat __maybenull)_SAL1_Source_(__inout_xcount_full, (size), __inout_xcount_part(size,size))__inout_xcount_part(size,length)_SAL1_Source_(__inout_xcount_part, (size,length), __out_xcount_part(size,length) _Pre_ __valid _Pre_ __inexpressible_readableTo(length))_SAL1_Source_(__inout_xcount, (size), __out_xcount(size) _Pre_ __valid)_SAL1_Source_(__out_xcount_full, (size), __out_xcount_part(size,size))__out_xcount_part(size,length)_SAL1_Source_(__out_xcount_part_, (size,length), __out_xcount(size) _Post_ __inexpressible_readableTo(length))_SAL1_Source_(__out_xcount, (size), __xcount(size) _Post_ __valid __refparam)_SAL1_Source_(__in_xcount, (size), __in _Pre_ __inexpressible_readableTo(size))_SAL1_Source_(__xcount, (size), __notnull __inexpressible_writableTo(size))__failureDefault(x)__valueUndefined__failure(x)__static_context(ctx,annotes)__inner_allocator__inner_range(lb,ub)__SAL_H_FULL_VER140050727SAL_VERSION_SAL2(_A)_SAL_VERSION_SAL2(_A)SAL_VERSION_CHECK(_A)_SAL_VERSION_CHECK(_A)!defined(_SAL_VERSION_SAL2)defined(__BUILDMACHINE__) || defined(_USE_SAL2_ONLY)_USE_SAL2_ONLYSAL_VERSION_CHECK__SAL_H_FULL_VER <= 140050727!defined(__midl) && defined(_PREFAST_) && _MSC_VER >= 1000(_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_)defined(_MSC_EXTENSIONS) || defined(_PREFAST_) || defined(OACR)_Writes_and_advances_ptr__Writes_bytes_and_advances_ptr__Translates_Win32_to_HRESULT__Translates_NTSTATUS_to_HRESULT__PREFIX_!(defined(RC_INVOKED) || defined(SORTPP_PASS))(!defined(_Outptr_) || _MSC_FULL_VER <= 160000000) && !( defined( MIDL_PASS ) || defined(__midl) || defined(RC_INVOKED) )(!defined(_Outptr_) || _MSC_FULL_VER <= 160000000) && !( defined( MIDL_PASS ) || defined(__midl) || defined(RC_INVOKED) ) && !( defined( _SDV_ ) )/* #ifndef SPECSTRINGS_H *//* !defined(_Outptr_) || _MSC_VER <= 1600 *//*IFSTRIP=IGN*//*
 If no SAL 2 appears to have been defined (_Outptr_ is a representative choice)
 then we must be operating in a downlevel build environment (such as VS10).
 We also test against the compiler version to identify a downlevel environment,
 as VS11 is the minimum required for SAL 2 support.

 If we are in a downlevel environment, we can go ahead and include no_sal2.h
 to make all of SAL 2 no-ops to ensure no build failures.
*//* fun *//*
 If no SAL 2 appears to have been defined (_Outptr_ is a representative choice)
 then we must be operating in a downlevel build environment (such as VS10).
 We also test against the compiler version to identify a downlevel environment,
 as VS11 is the minimum required for SAL 2 support.

 If we are operating in a downlevel build environment (such as VS10)
 we need to undefine the following symbols before including driverspecs.h
 or we will end up referencing SAL 2 implementation symbols and cause
 build failures.
*//* if !(defined(RC_INVOKED) || defined(SORTPP_PASS)) *//**************************************************************************
* This include should always be the last thing in this file.
* Must avoid redfinitions of macros to workaround rc.exe issues.
***************************************************************************//* ifdef _PREFIX_ *//**************************************************************************
* Redefintion of __analysis_assume and __analysis_assert for PREFIX build
**************************************************************************//**************************************************************************
* Defintion of __pfx_assume and __pfx_assert. Thse should be the only
* defintions of these functions.
***************************************************************************/// for analysis, the specific translations rarely matter.// This results in fewer false positives and unnecessary path explorations. This is because// are almost never meant to be called when GetLastError() could return 0).// functions as simple translators that will always return a failure-value HRESULT (these functions// This convenience macro allows analyzers to understand the many bespoke GetLastError-translation// Indicates the funtion just translates the result of GetLastError() into an HRESULT.// functions as simple translators that can be treated as equivalent to HRESULT_FROM_NT().// This convenience macro allows analyzers to understand the many bespoke error-translation// Indicates the function just directly translates the given NTSTATUS error code into an HRESULT.// HRESULT and when a success-range HRESULT.// that function cannot fail and the conditions under which it will return an error-range// for analysis, the specific translations rarely matter, it is more important to know the// functions as simple translators that can be treated as equivalent to HRESULT_FROM_WIN32().// with broadly the same semantics as HRESULT_FROM_WIN32().// Indicates the function simply translates the given Win32 error code into an HRESULT// completely accurate approximation, but reasonable.// that GetLastError() always returns a failed error code. This is not a// in _Curr_ as a postcondition. This is currently approximated by assuming// Gets the current error code (as returned by GetLastError()), and stores// HRESULT WriteChunkOfData(_Inout_ PCHAR* ppBuf, _Inout_ DWORD* pBufSize);// _At_(*ppBuf, _Writes_and_advances_ptr_(*pBufSize))// _At_, like so:// It is expected that these supplementary annotations would be used inside an// (e.g. when reading from a network interface in a driver).// large buffer in chunks// This pattern is frequently used when progressively filling a// is written to *pSize.// (*ppBuf - Old(*ppBuf)). The size of the remaining unwritten capacity// past the last written byte. Thus the length of the write is// to a function that writes to **pBuf, incrementing *ppBuf to point to one// A common pattern is to pass an "_Inout_ PCHAR* ppBuf" of size "_Inout_ DWORD* pSize"// but it must be NULL on failure.// default to NULL.  On successful return, it may be set to NULL or non-NULL,// Minifilter ConnectionCookie parameters on the port connect notify callback// other returns, it must be NULL.// FLT_PREOP_SYNCHRONIZE, it may be set to NULL or a valid pointer.  For all// default to NULL.  For return type FLT_PREOP_SUCCESS_WITH_CALLBACK or// Minifilter CompletionContext parameters on the pre-operation callback// first, but based on whether the size is negative or not.// null termination. Unlike _In_reads_or_z_, this is not whichever comes// NLS APIs allow strings to be specified either by an element count or// that to the annotation on the argument// zero.  We do not say here whether the before may be null, we leave// free memory directly by requesting that the new block is of size// which case the original block is still valid, or may be used to// freeing one block of memory and allocating another, or may fail, in// Functions which behave like realloc in that they may succeed by// memory should not be used after return.// Pointer parameters that are freed by the function, and thus the pointed-to// Unlike _Reserved_, an _Unreferenced_parameter_ pointer need not be NULL.// Annotation for parameters that are not used in any way by the function./**************************************************************************
* SAL 2 extensions for Windows-specific APIs.
***************************************************************************//* declare stub functions for macros *//* Windows Internal *//* useful PFD related macros *//* Penetration review macros *//* integer related macros */// ] // #if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_)///////////////////////////////////////////////////////////////////////////////// kernel mode code.// annotations that support checking of kernel/user memory handling within// These annotations form the expected interface for users to the Memory Correctness// High Level Memory Correctness annotations// that support checking of kernel/user memory handling within kernel mode code.// These are the implementation details for the Memory Correctness annotations// Low Level Memory Correctness annotations/* Internal defintions */// and _Current_execution_context_// The "When" variant is a hack for new until NMM can parse _Previous_execution_context_// Annotation elements that support the memory accessibility concept.// The "When" variant is a hack for now until NMM can parse _Previous_execution_context_// Annotation elements that support the memory origin concept.// to offer these.// _Current_execution_context_ and _Previous_execution_context_. NMM will need to be modified// temporary hack: Globals that stand in for the globally available SAL-pseudo-variables// The enum that defines the types of memory context that exist in the system.// For "breakpoint": doesn't return as far as analysis is concerned./************************************************************************
 New extensions to sal.h follow here.
*************************************************************************///__SAL_H_FULL_VER <= 140050727 // ]/* Must protect redfinitions of macros to workaround rc.exe issues. *//* Provide default definition to be overridden when needed *//* __in_ecount_or_z(c) specifies semantics like strncmp, where a string
 * parameter is either null terminated, or valid up to c elements.
 *//* Missing from RTM sal.h *//* version specific fixes to bring sal.h upto date *//* This version symbol is deprecated in favor of __SAL_H_VER *//* End compatibility fixes required for Win8/VS2012 RTM sal.h *//* Begin compatibility fixes required for Win8/VS2012 RTM sal.h */// #if not_defined treated as #if 0/*************************************************************************
* See specstrings_strict.h for documentation of all user visible macros.
*************************************************************************//***
*specstrings.h - support for markers for documenting the semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*       [Public]
****/on_parameter_or_returnC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/kernelspecs.h"DriverSpecs.h"_SAL1_Source_(__drv_useCancelIRQL, (), _IRQL_uses_cancel_)_SAL2_Source_(_IRQL_uses_cancel_, (), _Post_ _SA_annotes0(SAL_UseCancelIrql))_SAL1_Source_(__drv_sameIRQL, (), _IRQL_requires_same_)_SAL2_Source_(_IRQL_requires_same_, (), _Post_ _SA_annotes0(SAL_sameIRQL))_SAL1_Source_(__drv_maxFunctionIRQL, (), _IRQL_always_function_max_(irql) )__drv_maxFunctionIRQL_SAL2_Source_(_IRQL_always_function_max_, (irql), _Pre_ _SA_annotes1(SAL_maxFunctionIrql,irql))_IRQL_always_function_max__SAL1_Source_(__drv_minFunctionIRQL, (), _IRQL_always_function_min_(irql))__drv_minFunctionIRQL_SAL2_Source_(_IRQL_always_function_min_, (irql), _Pre_ _SA_annotes1(SAL_minFunctionIrql,irql))_IRQL_always_function_min__SAL1_Source_(__drv_restoresIRQLGlobal, (), _IRQL_restores_global_(kind, param))__drv_restoresIRQLGlobal_SAL2_Source_(_IRQL_restores_global_, (kind, param), _Post_ _SA_annotes2(SAL_restoreIRQLGlobal, #kind, param\t))_IRQL_restores_global__SAL1_Source_(__drv_restoresIRQL, (), _IRQL_restores_)_SAL2_Source_(_IRQL_restores_, (), _Post_ _SA_annotes0(SAL_restoreIRQL))_SAL1_Source_(__drv_savesIRQLGlobal, (), _IRQL_saves_global_(kind, param))__drv_savesIRQLGlobal_SAL2_Source_(_IRQL_saves_global_, (kind, param), _Post_ _SA_annotes2(SAL_saveIRQLGlobal,#kind, param\t))_IRQL_saves_global__SAL1_Source_(__drv_savesIRQL, (), _IRQL_saves_)_SAL2_Source_(_IRQL_saves_, (), _Post_ _SA_annotes0(SAL_saveIRQL))_SAL1_Source_(__drv_minIRQL, (), _IRQL_requires_min_(irql))__drv_minIRQL_SAL2_Source_(_IRQL_requires_min_, (irql), _Pre_ _SA_annotes1(SAL_minIRQL,irql))_IRQL_requires_min__SAL1_Source_(__drv_maxIRQL, (), _IRQL_requires_max_(irql))__drv_maxIRQL_SAL2_Source_(_IRQL_requires_max_, (irql), _Pre_ _SA_annotes1(SAL_maxIRQL,irql))_IRQL_requires_max__SAL1_Source_(__drv_requiresIRQL, (), _IRQL_requires_(irql))__drv_requiresIRQL_SAL2_Source_(_IRQL_requires_, (irql), _Pre_ _SA_annotes1(SAL_IRQL,irql))_IRQL_requires___drv_raisesIRQL(irql)_SAL1_Source_(__drv_raisesIRQL, (), _IRQL_raises_(irql))_SAL2_Source_(_IRQL_raises_, (), _Post_ _SA_annotes1(SAL_raiseIRQL,irql))_IRQL_raises__SAL1_Source_(__drv_setsIRQL, (), _Post_ _SA_annotes1(SAL_IRQL,irql))__drv_setsIRQLHIGH_LEVELPASSIVE_LEVELAPC_LEVELDISPATCH_LEVELKERNELSPECS_Hdefined(_X86_)defined(_AMD64_)defined(_ARM_)defined(_IA64_)defined(_ARM64_)SAL_UseCancelIrql(void);SAL_sameIRQL(void);SAL_maxFunctionIrql(__int64);SAL_minFunctionIrql(__int64);SAL_restoreIRQLGlobal(__In_impl_ char *, ...);SAL_restoreIRQL(void);SAL_saveIRQLGlobal(__In_impl_ char *, ...);SAL_saveIRQL(void);SAL_minIRQL(__int64);SAL_maxIRQL(__int64);SAL_IRQL(__int64);SAL_raiseIRQL(__int64);// KERNELSPECS_H// RC workaround; already #defined to nothing if not needed// The minimum IRQL to which the function can lower itself. The IRQL// the usual ones here, for PREfast purposes only.// The symbolic IRQL values can sometimes end up undefined, so define/*****************************************************************************\
* As noted in DriverSpecs.h, this header contains "real" definitions for
* annotations that either never appear in user space, or which are meaningles
* in user space and are #defined to nothing by DriverSpecs.h.
*
* Further commentary appears in DriverSpecs.h.
\*****************************************************************************//*****************************************************************************\
*                                                                             *
* KernelSpecs.h - markers for documenting the semantics of driver APIs        *
*                 See DriverSpecs.h for detailed comments                     *
*                 See also <SpecStrings.h>                                    *
*                                                                             *
* Version 1.2.00                                                              *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/basetsd.hvoid *__ptr32PtrToPtr32Handle32ToHandleconst void *__ptr32Ptr32ToPtrULongToPtrconst unsigned longLongToPtrconst longUIntToPtrconst unsigned intIntToPtrPtrToShortPtrToIntPtrToLongPtrToUshortPtrToUintPtrToUlongLongToHandleULongToHandleHandleToLongHandleToULongKAFFINITY *PKAFFINITYKAFFINITYPDWORD64DWORD64PULONG64ULONG64PLONG64LONG64ULONG_PTR *PDWORD_PTRDWORD_PTRLONG_PTR *PSSIZE_TSSIZE_TPSIZE_TSIZE_TPHALF_PTRHALF_PTRPUHALF_PTRUHALF_PTRHANDLE_PTRSHANDLE_PTRHANDLE64 *void *__ptr64void *__ptr64 *PHANDLE64HANDLE64PULONG_PTRULONG_PTRPLONG_PTRLONG_PTRPUINT_PTRUINT_PTRPINT_PTRINT_PTRPDWORD32DWORD32PULONG32ULONG32signed int *PLONG32LONG32PUINT64UINT64PUINT32UINT32PUINT16UINT16PUINT8UINT8signed long long *PINT64INT64PINT32INT32signed short *PINT16INT16PINT8INT8POINTER_64_INTMAXDWORD64((DWORD64)~((DWORD64)0))MAXDWORD32((DWORD32)~((DWORD32)0))MININT((INT)~MAXINT)MAXINT((INT)(MAXUINT >> 1))MAXUINT((UINT)~((UINT)0))MINSSIZE_T((SSIZE_T)~MAXSSIZE_T)MAXSSIZE_T((SSIZE_T)(MAXSIZE_T >> 1))MAXSIZE_T((SIZE_T)~((SIZE_T)0))MINLONGLONG((LONGLONG)~MAXLONGLONG)MAXULONGLONG((ULONGLONG)~((ULONGLONG)0))MINLONG64((LONG64)~MAXLONG64)MAXLONG64((LONG64)(MAXULONG64 >> 1))MAXULONG64((ULONG64)~((ULONG64)0))MINLONG32((LONG32)~MAXLONG32)MAXLONG32((LONG32)(MAXULONG32 >> 1))MAXULONG32((ULONG32)~((ULONG32)0))MININT64((INT64)~MAXINT64)MAXINT64((INT64)(MAXUINT64 >> 1))MAXUINT64((UINT64)~((UINT64)0))MININT32((INT32)~MAXINT32)MAXINT32((INT32)(MAXUINT32 >> 1))MAXUINT32((UINT32)~((UINT32)0))MININT16((INT16)~MAXINT16)MAXINT16((INT16)(MAXUINT16 >> 1))MAXUINT16((UINT16)~((UINT16)0))MININT8((INT8)~MAXINT8)MAXINT8((INT8)(MAXUINT8 >> 1))MAXUINT8((UINT8)~((UINT8)0))MINHALF_PTR(~MAXHALF_PTR)MAXHALF_PTR((HALF_PTR)(MAXUHALF_PTR >> 1))MAXUHALF_PTR((UHALF_PTR)~0)MINLONG_PTR(~MAXLONG_PTR)MAXLONG_PTR((LONG_PTR)(MAXULONG_PTR >> 1))MAXULONG_PTR(~((ULONG_PTR)0))MININT_PTR(~MAXINT_PTR)MAXINT_PTR((INT_PTR)(MAXUINT_PTR >> 1))MAXUINT_PTR(~((UINT_PTR)0))UintToPtr(ui)UIntToPtr(ui)UlongToPtr(ul)ULongToPtr(ul)UlongToHandle(ul)ULongToHandle(ul)HandleToUlong(h)HandleToULong(h)HandleToHandle32(h)(PtrToPtr32( h ))Handle64ToHandle(h)(Ptr64ToPtr( h ))HandleToHandle64(h)(PtrToPtr64( h ))Ptr64ToPtr(p)((void *) p)PtrToPtr64(p)((void * POINTER_64) p)ADDRESS_TAG_BIT0x40000000000UI64__HANDLE64_DEFINED____int3264UPOINTER_32POINTER_UNSIGNED POINTER_32SPOINTER_32POINTER_SIGNED POINTER_32POINTER_UNSIGNEDPOINTER_SIGNEDFIRMWARE_PTRPOINTER_32POINTER_64_BASETSD_H_!defined(_MAC) && (defined(_M_MRX000) || defined(_WIN64)) && (_MSC_VER >= 1100) && !(defined(MIDL_PASS) || defined(RC_INVOKED))defined(_WIN64)defined(_MAC) && defined(_MAC_INT_64)(_MSC_VER >= 1300) && !(defined(MIDL_PASS) || defined(RC_INVOKED))(_MSC_FULL_VER >= 140041204) && !defined(MIDL_PASS) && !defined(RC_INVOKED)!defined(_W64)!defined(__midl) && (defined(_X86_) || defined(_M_IX86) || defined(_ARM_) || defined(_M_ARM)) && _MSC_VER >= 1300( defined(__midl) && (501 < __midl) )!defined(__midl)_WIN32_WINNT >= 0x0600 || (defined(__cplusplus) && defined(WINDOWS_ENABLE_CPLUSPLUS))// _BASETSD_H_// end_wudfpwdm// Legacy thread affinity.// begin_wudfpwdm// The following types are guaranteed to be unsigned and 64 bits wide.// The following types are guaranteed to be signed and 64 bits wide.// Add Windows flavor DWORD_PTR types// _WIN32_WINNT >= 0x0600// of a pointer.  SSIZE_T is the signed variation.// SIZE_T used for counts or ranges which need to span the range of// !_WIN64// !_midl// Caution: ULongToPtr() zero-extends the unsigned long value.// Caution: LongToPtr() sign-extends the long value.// Caution: UIntToPtr() zero-extends the unsigned int value.// Caution: IntToPtr() sign-extends the int value.// UHALF_PTR is the unsigned variation.// within structures which contain a pointer and two small fields.// HALF_PTR is half the size of a pointer it intended for use with// reasons.// when we prefer to use fixed size types in both WIN32 and WIN64 for other// support while user mode and kernel mode communicate with a shared memory or// HandleToHandle64 and Handle64ToHandle conversion macros, help simplify WOW// HANDLE64 uses 64 bits in both WIN32 and WIN64 platforms. This along with// midl64// old midl and C++ compiler// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.// the unsigned variation.// anywhere that a pointer is cast to an integer type. UINT_PTR is// size with change with pointer size (32/64).  It should be used// The INT_PTR is guaranteed to be the same size as a pointer.  Its// The following types are guaranteed to be unsigned and 32 bits wide.// The following types are guaranteed to be signed and 32 bits wide./*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    basetsd.h

Abstract:

    Type definitions for the basic sized types.

Author:

Revision History:

--*/uluiC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/guiddef.hFMTID *_GUID *LPFMTIDFMTIDCLSID *LPCLSIDCLSIDIID *LPIIDIIDconst GUIDconst GUID *LPCGUIDGUID *LPGUIDGUID_GUIDData4Data3Data2Data1_SYS_GUID_OPERATOR_EQ_IsEqualCLSID(rclsid1,rclsid2)IsEqualGUID(rclsid1, rclsid2)IsEqualIID(riid1,riid2)IsEqualGUID(riid1, riid2)IsEqualGUID(rguid1,rguid2)(!memcmp(rguid1, rguid2, sizeof(GUID)))InlineIsEqualGUID(rguid1,rguid2)(((unsigned long *) rguid1)[0] == ((unsigned long *) rguid2)[0] && ((unsigned long *) rguid1)[1] == ((unsigned long *) rguid2)[1] && ((unsigned long *) rguid1)[2] == ((unsigned long *) rguid2)[2] && ((unsigned long *) rguid1)[3] == ((unsigned long *) rguid2)[3])_SYS_GUID_OPERATORS_REFFMTIDconst IID * __MIDL_CONST_REFFMTID_DEFINEDREFCLSID_REFCLSID_DEFINEDREFIID_REFIID_DEFINEDREFGUIDconst GUID * __MIDL_CONST_REFGUID_DEFINED__MIDL_CONSTIsEqualFMTID(rfmtid1,rfmtid2)IsEqualGUID(rfmtid1, rfmtid2)FMTID_NULLGUID_NULLCLSID_NULLIID_NULL__IID_DEFINED____LPCGUID_DEFINED____LPGUID_DEFINED___GUIDDEF_H_DEFINE_OLEGUID(name,l,w1,w2)DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)EXTERN_C const GUID FAR nameGUID_DEFINEDdefined(__midl)DECLSPEC_SELECTANY(_MSC_VER >= 1100)EXTERN_CDEFINE_GUIDINITGUID__midl_proxy!defined (__midl)!defined (_SYS_GUID_OPERATORS_)__INLINE_ISEQUAL_GUID!defined _SYS_GUID_OPERATOR_EQ_ && !defined _NO_SYS_GUID_OPERATOR_EQ_// _GUIDDEF_H_// _SYS_GUID_OPERATORS_// _SYS_GUID_OPERATOR_EQ_// A couple of C++ helpers// Same type, different name// ! __cplusplus// Faster (but makes code fatter) inline version...use sparingly// !__IID_DEFINED__// INITGUID//----------------------------------------------------------------------------//  Contents:   GUID definition//  File:       guiddef.h//  Copyright (c) Microsoft Corporation.  All rights reserved.//  Microsoft Windows//+---------------------------------------------------------------------------C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/pshpack4.h! (defined(lint) || defined(RC_INVOKED))( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)warning(disable:4103)!(defined( MIDL_PASS )) || defined( __midl )pack(push,4)/* ! (defined(lint) || defined(RC_INVOKED)) *//*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/poppack.h/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/pshpack2.hpack(push,2)/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/pshpack8.hpack(push,8)/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack8.h

Abstract:

    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/pshpack1.hpack(push,1)/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/apiset.hAPI_SET_LIBRARY(X)LIBRARY XAPI_SET_LEGACY_WITH_OPTIONAL_ORDINAL_DIR(X,L,O,PO,DIR)X @ ## O DIRAPI_SET_LEGACY_WITH_OPTIONAL_ORDINAL(X,L,O,PO)X @ ## OAPI_SET_LEGACY_BY_ORDINAL_DIR(X,L,O,PO,DIR)X @ ## O NONAME DIRAPI_SET_LEGACY_BY_ORDINAL(X,L,O,PO)X @ ## O NONAMEAPI_SET_LEGACY_DIR(X,L,DIR)X DIRAPI_SET_LEGACY(X,L)API_SET_WITH_OPTIONAL_ORDINAL_DIR(X,O,PO,DIR)API_SET_WITH_OPTIONAL_ORDINAL(X,O,PO)API_SET_BY_ORDINAL_DIR(X,O,PO,DIR)API_SET_BY_ORDINAL(X,O,PO)API_SET_DIR(X,DIR)API_SET(X)API_SET_LEGACY_WITH_OPTIONAL_ORDINAL_DIRAPI_SET_LEGACY_WITH_OPTIONAL_ORDINALAPI_SET_LEGACY_BY_ORDINAL_DIRAPI_SET_LEGACY_BY_ORDINALAPI_SET_LEGACY_DIRAPI_SET_LEGACYAPI_SET_WITH_OPTIONAL_ORDINAL_DIRAPI_SET_WITH_OPTIONAL_ORDINALAPI_SET_BY_ORDINAL_DIRAPI_SET_BY_ORDINALAPI_SET_DIRAPI_SETAPI_SET_CHPE_GUESTAPI_SET_OVERRIDE_DEF(X)API_SET_LEGACY_OVERRIDE_DEF(X) PRIVATEAPI_SET_LEGACY_OVERRIDE_DEF(X)X = API_SET_OVERRIDE(X)API_SET_OVERRIDE(X)X ## Implementation_API_SET_H__M_HYBRID_X86_ARM64_API_SET_HOSTdefined(_API_SET_LEGACY_TARGET)defined(_API_SET_FORWARDER_TARGET)// _API_SET_H_// _API_SET_HOST// _API_SET_LEGACY_TARGET, _API_SET_FORWARDER_TARGET// This section is intended for internal contract generation to build artifacts that model the contract without forwarding.// Any legacy targets are ignored.// This section is intended for "reverse forwarders" that are forwarding to an explicit apiset name.// entire contract. But any APIs which specify LegacyHost directly will override this definition.// In this section, the definition for _API_SET_LEGACY_TARGET is taken as the default legacy host for the// This section is intended for "classic apiset forwarders" that are forwarding back to a legacy host.// This section is intended for hosting contracts. Any legacy host definitions are ignored.// API set interface definitions./*++

Copyright (c) 2008  Microsoft Corporation

Module Name:

    apiset.h

Abstract:

    This module contains definitions related to the management of API namespaces.

Author:

    Arun Kishan (arunki) 14-Sep-2008

--*/C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/shared/ktmtypes.h_KCRM_PROTOCOL_BLOB *PRKCRM_PROTOCOL_BLOBPKCRM_PROTOCOL_BLOBKCRM_PROTOCOL_BLOB_KCRM_PROTOCOL_BLOB_KCRM_TRANSACTION_BLOB *PRKCRM_TRANSACTION_BLOBPKCRM_TRANSACTION_BLOBKCRM_TRANSACTION_BLOB_KCRM_TRANSACTION_BLOB_KCRM_MARSHAL_HEADER *PRKCRM_MARSHAL_HEADERPKCRM_MARSHAL_HEADERKCRM_MARSHAL_HEADER_KCRM_MARSHAL_HEADERTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT *_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENTTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENTTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENTPTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENTTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENTTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENTULONG *PSAVEPOINT_IDSAVEPOINT_ID_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENTTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENTTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT_TRANSACTION_NOTIFICATION *PTRANSACTION_NOTIFICATIONTRANSACTION_NOTIFICATION_TRANSACTION_NOTIFICATIONNOTIFICATION_MASKPCRM_PROTOCOL_IDCRM_PROTOCOL_IDPUOWUOWUnused2Unused1TransactionIdInfoLengthStaticInfoLengthProtocolIdWCHAR[64]unsigned short[64]MAX_TRANSACTION_DESCRIPTION_LENGTHDescriptionTimeoutIsolationFlagsIsolationLevelTmIdentityUnusedNumProtocolsVersionMinorVersionMajorMarshalCookieBufferLengthPropagationCookieSavepointIdFlagsEnlistmentIdArgumentLengthTmVirtualClockTransactionNotificationTransactionKeyMAX_RESOURCEMANAGER_DESCRIPTION_LENGTHKTM_MARSHAL_BLOB_VERSION_MINORKTM_MARSHAL_BLOB_VERSION_MAJORTRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTEREDRESOURCE_MANAGER_OBJECT_NAME_LENGTH_IN_BYTES(sizeof(RESOURCE_MANAGER_OBJECT_PATH)+(38*sizeof(WCHAR)))ENLISTMENT_OBJECT_NAME_LENGTH_IN_BYTES(sizeof(ENLISTMENT_OBJECT_PATH)+(38*sizeof(WCHAR)))TRANSACTION_OBJECT_NAME_LENGTH_IN_BYTES(sizeof(TRANSACTION_OBJECT_PATH)+(38*sizeof(WCHAR)))TRANSACTIONMANAGER_OBJECT_NAME_LENGTH_IN_BYTES(sizeof(TRANSACTIONMANAGER_OBJECT_PATH)+(38*sizeof(WCHAR)))RESOURCE_MANAGER_OBJECT_PATHL"\\ResourceManager\\"ENLISTMENT_OBJECT_PATHL"\\Enlistment\\"TRANSACTION_OBJECT_PATHL"\\Transaction\\"TRANSACTIONMANAGER_OBJECT_PATHL"\\TransactionManager\\"TRANSACTION_NOTIFY_COMMIT_FINALIZE0x40000000TRANSACTION_NOTIFY_REQUEST_OUTCOME0x20000000TRANSACTION_NOTIFY_PROMOTE_NEW0x10000000TRANSACTION_NOTIFY_PROMOTE0x08000000TRANSACTION_NOTIFY_COMMIT_REQUESTTRANSACTION_NOTIFY_TM_ONLINETRANSACTION_NOTIFY_RM_DISCONNECTEDTRANSACTION_NOTIFY_ENLIST_MASKTRANSACTION_NOTIFY_MARSHALTRANSACTION_NOTIFY_PROPAGATE_PUSHTRANSACTION_NOTIFY_PROPAGATE_PULL0x00008000TRANSACTION_NOTIFY_INDOUBT0x00004000TRANSACTION_NOTIFY_LAST_RECOVER0x00002000TRANSACTION_NOTIFY_ENLIST_PREPREPARE0x00001000TRANSACTION_NOTIFY_RECOVER_QUERY0x00000800TRANSACTION_NOTIFY_DELEGATE_COMMIT0x00000400TRANSACTION_NOTIFY_SINGLE_PHASE_COMMITTRANSACTION_NOTIFY_RECOVERTRANSACTION_NOTIFY_ROLLBACK_COMPLETE0x00000080TRANSACTION_NOTIFY_COMMIT_COMPLETE0x00000040TRANSACTION_NOTIFY_PREPARE_COMPLETE0x00000020TRANSACTION_NOTIFY_PREPREPARE_COMPLETETRANSACTION_NOTIFY_ROLLBACKTRANSACTION_NOTIFY_COMMITTRANSACTION_NOTIFY_PREPARETRANSACTION_NOTIFY_PREPREPARETRANSACTION_NOTIFY_MASK0x3FFFFFFFENLISTMENT_MAXIMUM_OPTIONENLISTMENT_SUPERIORCRM_PROTOCOL_MAXIMUM_OPTION0x00000003CRM_PROTOCOL_DYNAMIC_MARSHAL_INFOCRM_PROTOCOL_EXPLICIT_MARSHAL_ONLYRESOURCE_MANAGER_MAXIMUM_OPTIONRESOURCE_MANAGER_COMMUNICATIONRESOURCE_MANAGER_VOLATILETRANSACTION_MAXIMUM_OPTIONTRANSACTION_DO_NOT_PROMOTETRANSACTION_MANAGER_MAXIMUM_OPTION0x0000003FTRANSACTION_MANAGER_CORRUPT_FOR_PROGRESSTRANSACTION_MANAGER_CORRUPT_FOR_RECOVERYTRANSACTION_MANAGER_COMMIT_LOWESTTRANSACTION_MANAGER_COMMIT_SYSTEM_HIVESTRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUMETRANSACTION_MANAGER_COMMIT_DEFAULTTRANSACTION_MANAGER_VOLATILE_KTMTYPES_warning(disable:4820)ULONG_MAX/20xffffffffUL/2(0,0xffffffffUL/2)_Field_range_impl_(0,0xffffffffUL/2)// _KTMTYPES_// for alignment purposes//??? ProtocolDynamicInfoLength;// Bufferlength bytes of Buffer follow// TODO: warning, duplicated def in tm.h.// transaction manager object name, e.g., \Transaction\{GUID}// of string buffers which are to contain a fully qualified // The following three defines are here to ease the allocation// object namespace.// Path to the transaction manager objects in the NT//  out before enlisting in any transaction.//  flag is strictly for the use of filter manager. In fact we mask it//  The reason being that KTM does not understand this flag yet. This//  Note that this flag is not included in the TRANSACTION_NOTIFY_MASK.// Define the Enlistment option values// Define the RegisterProtocol option values// Define the ResourceManager option values// Define the Transaction option values// Define the TransactionManager option values// padding added after data member// begin_wdm begin_winnt/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ktmtypes.h

Abstract:

    Common types for KTM exposed at both the Nt- and Win32-layer.

Revision History:

--*/C:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/um/winnt.h<ktmtypes.h><specstrings.h><apiset.h>"poppack.h""pshpack1.h""pshpack8.h"<poppack.h><pshpack2.h>"pshpack2.h""pshpack4.h"<pshpack4.h><sdkddkver.h><excpt.h><guiddef.h><basetsd.h><kernelspecs.h><winapifamily.h>GetFiberDataPVOID *GetCurrentFiberNT_TIBFiberDataNT_TIB *_NT_TIB *FIELD_OFFSET(NT_TIB, FiberData)_TEB *NtCurrentTebSelfFIELD_OFFSET(NT_TIB, Self)TpDestroyCallbackEnvironCallbackEnvironTpSetCallbackPersistentTpSetCallbackPriorityTpSetCallbackFinalizationCallbackTpSetCallbackRaceWithDllTpSetCallbackLongFunctionTpSetCallbackNoActivationContext_ACTIVATION_CONTEXT *(struct _ACTIVATION_CONTEXT *)(LONG_PTR) -1TpSetCallbackActivationContextTpSetCallbackCleanupGroupTpSetCallbackThreadpoolTpInitializeCallbackEnvironTP_CALLBACK_PRIORITY_NORMALsizeof(TP_CALLBACK_ENVIRON)RtlSwitchedVVIRtlConvertDeviceFamilyInfoToStringRtlGetDeviceFamilyInfoEnumULONGLONG *DWORD *RtlSetSystemGlobalDataRtlGetSystemGlobalDataRtlNormalizeSecurityDescriptorPSECURITY_DESCRIPTOR *RtlIsZeroMemoryRtlRaiseCustomSystemEventTriggerCUSTOM_SYSTEM_EVENT_TRIGGER_INITConfigsizeof(CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG)RtlValidateCorrelationVectorRtlExtendCorrelationVectorRtlIncrementCorrelationVectorRtlInitializeCorrelationVectorRtlFlushNonVolatileMemoryRangesRtlFillNonVolatileMemory__unaligned void__unaligned void *const BYTERtlWriteNonVolatileMemoryconst __unaligned voidconst __unaligned void *RtlDrainNonVolatileFlushRtlFlushNonVolatileMemoryRtlFreeNonVolatileTokenRtlGetNonVolatileTokenRtlOsDeploymentStateRtlCrc64RtlCrc32RtlGetProductInfoVerSetConditionMaskRtlSecureZeroMemoryvolatile charvolatile char *vptrRtlConstantTimeEqualMemoryconst volatile charconst volatile char *p1p2HEAP_MAKE_TAG_FLAGSHEAP_TAG_SHIFT__fastfailRtlGetReturnAddressHijackTargetRtlQueryDepthSListRtlInterlockedFlushSListRtlInterlockedPushListSListExRtlInterlockedPushEntrySListRtlInterlockedPopEntrySListRtlFirstEntrySListconst SLIST_HEADERconst SLIST_HEADER *_SLIST_HEADER *RtlInitializeSListHeadRtlCompareMemoryRtlPcToFileHeaderRtlRaiseExceptionRtlVirtualUnwindRtlUnwindExRtlRestoreContextRtlLookupFunctionEntryRtlDeleteGrowableFunctionTableRtlGrowFunctionTableRtlAddGrowableFunctionTableRtlInstallFunctionTableCallbackRtlDeleteFunctionTableRtlAddFunctionTableRtlUnwindRtlCaptureContext2RtlCaptureContextRtlCaptureStackBackTraceWritePointerRawvolatile PVOIDvolatile PVOID *volatile LONG64volatile LONG64 *WritePointerNoFenceWritePointerReleaseReadPointerRawconst volatile PVOIDconst volatile PVOID *const volatile LONG64const volatile LONG64 *ReadPointerNoFenceReadPointerAcquireWriteULong64Rawvolatile DWORD64volatile DWORD64 *WriteULong64NoFenceWriteULong64ReleaseReadULong64Rawconst volatile DWORD64const volatile DWORD64 *ReadULong64NoFenceReadULong64AcquireWriteUInt32Rawvolatile UINT32volatile UINT32 *volatile LONGvolatile LONG *WriteUInt32NoFenceWriteUInt32ReleaseReadUInt32Rawconst volatile UINT32const volatile UINT32 *const volatile LONGconst volatile LONG *ReadUInt32NoFenceReadUInt32AcquireWriteInt32Rawvolatile INT32volatile INT32 *WriteInt32NoFenceWriteInt32ReleaseReadInt32Rawconst volatile INT32const volatile INT32 *ReadInt32NoFenceReadInt32AcquireWriteULongRawvolatile DWORDvolatile DWORD *WriteULongNoFenceWriteULongReleaseReadULongRawconst volatile DWORDconst volatile DWORD *ReadULongNoFenceReadULongAcquireWriteUShortRawvolatile WORDvolatile WORD *volatile SHORTvolatile SHORT *WriteUShortNoFenceWriteUShortReleaseReadUShortRawconst volatile WORDconst volatile WORD *const volatile SHORTconst volatile SHORT *ReadUShortNoFenceReadUShortAcquireC:/Program Files (x86)/Windows Kits/10/Include/10.0.22621.0/umPriorityFinalizationCallbackDllHandleActivationContextCleanupGroupCleanupGroupCancelCallbackPoolTriggerIdcntv1v2TagBaseTagDestinationValueSourceWriteUCharRawvolatile BYTEvolatile BYTE *volatile CHARvolatile CHAR *WriteBooleanNoFencevolatile BOOLEANvolatile BOOLEAN *WriteBooleanReleaseWriteUCharNoFenceWriteUCharReleaseReadUCharRawconst volatile BYTEconst volatile BYTE *const volatile CHARconst volatile CHAR *ReadBooleanRawconst volatile BOOLEANconst volatile BOOLEAN *ReadBooleanNoFenceReadBooleanAcquireReadUCharNoFenceReadUCharAcquireWriteRaw64LONG64 *ReadRaw64WriteRawLONG *ReadRawWriteRaw16SHORT *ReadRaw16WriteRaw8CHAR *ReadRaw8BarrierAfterReadWriteNoFence64WriteRelease64ReadNoFence64ReadAcquire64WriteNoFenceWriteReleaseReadNoFenceReadAcquireWriteNoFence16WriteRelease16ReadNoFence16ReadAcquire16WriteNoFence8WriteRelease8ReadNoFence8ReadAcquire8__int2c__addgsqword__incgsqword__addgsdword__incgsdword__addgsword__incgsword__addgsbyte__incgsbyte__writegsqword__writegsdword__writegsword__writegsbyte__readgsqword__readgsdword__readgsword__readgsbyteUnsignedMultiplyExtract128extractedProducthighProductlowProductDWORD64 *MultiplyExtract128negateuhighProductulowProductFALSE_umul128UnsignedMultiply128_mul128__shiftright128__shiftleft128__popcnt64__umulh__mulh__stosq__stosd__stosw__stosb__movsqconst DWORD64const DWORD64 *__movsdconst DWORDconst DWORD *__movswconst WORDconst WORD *__movsbconst BYTE *__rdtsc__readpmc__segmentlimit__getcallerseflags_mm_setcsr_mm_getcsr_m_prefetchw_mm_prefetchconst CHARconst CHAR *_mm_pause_mm_sfence_mm_mfence_mm_lfence__faststorefence_ReadWriteBarrier_mm_clflush__cpuidex_InterlockedXor16_InterlockedOr16_InterlockedAnd16_InterlockedXor8_InterlockedOr8_InterlockedAnd8_InterlockedExchangeAdd8_InterlockedExchange16_InterlockedExchange8_InterlockedExchangePointer_InterlockedCompareExchangePointer_InterlockedCompareExchange128_InterlockedCompareExchange64_InlineInterlockedAdd64_InterlockedExchangeAdd64_InterlockedExchange64_InterlockedDecrement64_InterlockedIncrement64_InterlockedCompareExchange_InlineInterlockedAdd_InterlockedExchangeAdd_InterlockedExchange_InterlockedDecrement_InterlockedIncrement_InterlockedXor64_InterlockedOr64_InterlockedAnd64_InterlockedXor_InterlockedOr_InterlockedAnd_InterlockedCompareExchange16_InterlockedDecrement16_InterlockedIncrement16_BitScanReverse64_BitScanForward64_BitScanReverse_BitScanForward_interlockedbittestandreset64_interlockedbittestandset64_bittestandreset64_bittestandset64_bittestandcomplement64_bittest64const LONG64const LONG64 *_interlockedbittestandreset_interlockedbittestandset_bittestandreset_bittestandset_bittestandcomplement_bittestconst LONGconst LONG *_rotr16_rotr8_rotl16_rotl8_TEB_TP_IO *PTP_IOTP_IO_TP_IOPTP_WAIT_CALLBACK_TP_WAIT *PTP_WAITTP_WAIT_TP_WAITTP_WAIT_RESULTPTP_TIMER_CALLBACK_TP_TIMER *PTP_TIMERTP_TIMER_TP_TIMERPTP_WORK_CALLBACK_TP_WORK *PTP_WORKTP_WORK_TP_WORKTP_CALLBACK_ENVIRON_V3 *_TP_CALLBACK_ENVIRON_V3 *PTP_CALLBACK_ENVIRONTP_CALLBACK_ENVIRONTP_CALLBACK_ENVIRON_V3_TP_CALLBACK_ENVIRON_V3_ACTIVATION_CONTEXTPTP_CLEANUP_GROUP_CANCEL_CALLBACK_TP_CLEANUP_GROUP *PTP_CLEANUP_GROUPTP_CLEANUP_GROUP_TP_CLEANUP_GROUP_TP_POOL_STACK_INFORMATION *PTP_POOL_STACK_INFORMATIONTP_POOL_STACK_INFORMATION_TP_POOL_STACK_INFORMATIONTP_CALLBACK_PRIORITY_TP_CALLBACK_PRIORITYTP_CALLBACK_PRIORITY_HIGHTP_CALLBACK_PRIORITY_LOWTP_CALLBACK_PRIORITY_INVALIDTP_CALLBACK_PRIORITY_COUNT_TP_POOL *PTP_POOLTP_POOL_TP_POOLPTP_SIMPLE_CALLBACK_TP_CALLBACK_INSTANCE *PTP_CALLBACK_INSTANCETP_CALLBACK_INSTANCE_TP_CALLBACK_INSTANCEPTP_VERSIONTP_VERSION_KTMOBJECT_CURSOR *PKTMOBJECT_CURSORKTMOBJECT_CURSOR_KTMOBJECT_CURSOR_KTMOBJECT_TYPE *PKTMOBJECT_TYPEKTMOBJECT_TYPE_KTMOBJECT_TYPEKTMOBJECT_TRANSACTIONKTMOBJECT_TRANSACTION_MANAGERKTMOBJECT_RESOURCE_MANAGERKTMOBJECT_ENLISTMENTKTMOBJECT_INVALID_TRANSACTION_LIST_INFORMATION *PTRANSACTION_LIST_INFORMATIONTRANSACTION_LIST_INFORMATION_TRANSACTION_LIST_INFORMATION_TRANSACTION_LIST_ENTRY *PTRANSACTION_LIST_ENTRYTRANSACTION_LIST_ENTRY_TRANSACTION_LIST_ENTRYENLISTMENT_INFORMATION_CLASS_ENLISTMENT_INFORMATION_CLASSEnlistmentBasicInformationEnlistmentRecoveryInformationEnlistmentCrmInformation_ENLISTMENT_CRM_INFORMATION *PENLISTMENT_CRM_INFORMATIONENLISTMENT_CRM_INFORMATION_ENLISTMENT_CRM_INFORMATION_ENLISTMENT_BASIC_INFORMATION *PENLISTMENT_BASIC_INFORMATIONENLISTMENT_BASIC_INFORMATION_ENLISTMENT_BASIC_INFORMATIONRESOURCEMANAGER_INFORMATION_CLASS_RESOURCEMANAGER_INFORMATION_CLASSResourceManagerBasicInformationResourceManagerCompletionInformationTRANSACTIONMANAGER_INFORMATION_CLASS_TRANSACTIONMANAGER_INFORMATION_CLASSTransactionManagerBasicInformationTransactionManagerLogInformationTransactionManagerLogPathInformationTransactionManagerRecoveryInformationTransactionManagerOnlineProbeInformationTransactionManagerOldestTransactionInformationTRANSACTION_INFORMATION_CLASS_TRANSACTION_INFORMATION_CLASSTransactionBasicInformationTransactionPropertiesInformationTransactionEnlistmentInformationTransactionSuperiorEnlistmentInformationTransactionBindInformationTransactionDTCPrivateInformation_RESOURCEMANAGER_COMPLETION_INFORMATION *PRESOURCEMANAGER_COMPLETION_INFORMATIONRESOURCEMANAGER_COMPLETION_INFORMATION_RESOURCEMANAGER_COMPLETION_INFORMATION_RESOURCEMANAGER_BASIC_INFORMATION *PRESOURCEMANAGER_BASIC_INFORMATIONRESOURCEMANAGER_BASIC_INFORMATION_RESOURCEMANAGER_BASIC_INFORMATION_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATIONTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION_TRANSACTION_ENLISTMENTS_INFORMATION *PTRANSACTION_ENLISTMENTS_INFORMATIONTRANSACTION_ENLISTMENTS_INFORMATION_TRANSACTION_ENLISTMENTS_INFORMATION_TRANSACTION_ENLISTMENT_PAIR *PTRANSACTION_ENLISTMENT_PAIRTRANSACTION_ENLISTMENT_PAIR_TRANSACTION_ENLISTMENT_PAIR_TRANSACTION_BIND_INFORMATION *PTRANSACTION_BIND_INFORMATIONTRANSACTION_BIND_INFORMATION_TRANSACTION_BIND_INFORMATION_TRANSACTION_PROPERTIES_INFORMATION *PTRANSACTION_PROPERTIES_INFORMATIONTRANSACTION_PROPERTIES_INFORMATION_TRANSACTION_PROPERTIES_INFORMATION_TRANSACTIONMANAGER_OLDEST_INFORMATION *PTRANSACTIONMANAGER_OLDEST_INFORMATIONTRANSACTIONMANAGER_OLDEST_INFORMATION_TRANSACTIONMANAGER_OLDEST_INFORMATION_TRANSACTIONMANAGER_RECOVERY_INFORMATION *PTRANSACTIONMANAGER_RECOVERY_INFORMATIONTRANSACTIONMANAGER_RECOVERY_INFORMATION_TRANSACTIONMANAGER_RECOVERY_INFORMATION_TRANSACTIONMANAGER_LOGPATH_INFORMATION *PTRANSACTIONMANAGER_LOGPATH_INFORMATIONTRANSACTIONMANAGER_LOGPATH_INFORMATION_TRANSACTIONMANAGER_LOGPATH_INFORMATION_TRANSACTIONMANAGER_LOG_INFORMATION *PTRANSACTIONMANAGER_LOG_INFORMATIONTRANSACTIONMANAGER_LOG_INFORMATION_TRANSACTIONMANAGER_LOG_INFORMATION_TRANSACTIONMANAGER_BASIC_INFORMATION *PTRANSACTIONMANAGER_BASIC_INFORMATIONTRANSACTIONMANAGER_BASIC_INFORMATION_TRANSACTIONMANAGER_BASIC_INFORMATION_TRANSACTION_BASIC_INFORMATION *PTRANSACTION_BASIC_INFORMATIONTRANSACTION_BASIC_INFORMATION_TRANSACTION_BASIC_INFORMATIONTRANSACTION_STATE_TRANSACTION_STATETransactionStateNormalTransactionStateIndoubtTransactionStateCommittedNotifyTRANSACTION_OUTCOME_TRANSACTION_OUTCOMETransactionOutcomeUndeterminedTransactionOutcomeCommittedTransactionOutcomeAbortedTAPE_DRIVE_PROBLEM_TYPE_TAPE_DRIVE_PROBLEM_TYPETapeDriveProblemNoneTapeDriveReadWriteWarningTapeDriveReadWriteErrorTapeDriveReadWarningTapeDriveWriteWarningTapeDriveReadErrorTapeDriveWriteErrorTapeDriveHardwareErrorTapeDriveUnsupportedMediaTapeDriveScsiConnectionErrorTapeDriveTimetoCleanTapeDriveCleanDriveNowTapeDriveMediaLifeExpiredTapeDriveSnappedTape_TAPE_WMI_OPERATIONS *PTAPE_WMI_OPERATIONSTAPE_WMI_OPERATIONS_TAPE_WMI_OPERATIONS_TAPE_CREATE_PARTITION *PTAPE_CREATE_PARTITIONTAPE_CREATE_PARTITION_TAPE_CREATE_PARTITION_TAPE_SET_MEDIA_PARAMETERS *PTAPE_SET_MEDIA_PARAMETERSTAPE_SET_MEDIA_PARAMETERS_TAPE_SET_MEDIA_PARAMETERS_TAPE_GET_MEDIA_PARAMETERS *PTAPE_GET_MEDIA_PARAMETERSTAPE_GET_MEDIA_PARAMETERS_TAPE_GET_MEDIA_PARAMETERS_TAPE_SET_DRIVE_PARAMETERS *PTAPE_SET_DRIVE_PARAMETERSTAPE_SET_DRIVE_PARAMETERS_TAPE_SET_DRIVE_PARAMETERS_TAPE_GET_DRIVE_PARAMETERS *PTAPE_GET_DRIVE_PARAMETERSTAPE_GET_DRIVE_PARAMETERS_TAPE_GET_DRIVE_PARAMETERS_TAPE_SET_POSITION *PTAPE_SET_POSITIONTAPE_SET_POSITION_TAPE_SET_POSITION_TAPE_GET_POSITION *PTAPE_GET_POSITIONTAPE_GET_POSITION_TAPE_GET_POSITION_TAPE_WRITE_MARKS *PTAPE_WRITE_MARKSTAPE_WRITE_MARKS_TAPE_WRITE_MARKSMultiplierMultiplicandShiftAddend_TAPE_PREPARE *PTAPE_PREPARETAPE_PREPARE_TAPE_PREPARE_TAPE_ERASE *PTAPE_ERASETAPE_ERASE_TAPE_ERASESERVICE_ERROR_TYPE_CM_ERROR_CONTROL_TYPEIgnoreErrorSERVICE_ERROR_IGNORENormalErrorSERVICE_ERROR_NORMALSevereErrorSERVICE_ERROR_SEVERECriticalErrorSERVICE_ERROR_CRITICALSERVICE_LOAD_TYPE_CM_SERVICE_LOAD_TYPEBootLoadSERVICE_BOOT_STARTSystemLoadSERVICE_SYSTEM_STARTAutoLoadSERVICE_AUTO_STARTDemandLoadSERVICE_DEMAND_STARTDisableLoadSERVICE_DISABLEDSERVICE_NODE_TYPE_CM_SERVICE_NODE_TYPEDriverTypeSERVICE_KERNEL_DRIVERFileSystemTypeSERVICE_FILE_SYSTEM_DRIVERWin32ServiceOwnProcessSERVICE_WIN32_OWN_PROCESSWin32ServiceShareProcessSERVICE_WIN32_SHARE_PROCESSAdapterTypeSERVICE_ADAPTERRecognizerTypeSERVICE_RECOGNIZER_DRIVER_PACKEDEVENTINFO *PPACKEDEVENTINFOPACKEDEVENTINFO_PACKEDEVENTINFO_EVENTSFORLOGFILE *PEVENTSFORLOGFILEEVENTSFORLOGFILE_EVENTSFORLOGFILE_EVENTLOGRECORD *PEVENTLOGRECORDEVENTLOGRECORD_EVENTLOGRECORD_PERFORMANCE_DATA *PPERFORMANCE_DATAPERFORMANCE_DATA_PERFORMANCE_DATA_HARDWARE_COUNTER_DATA *PHARDWARE_COUNTER_DATAHARDWARE_COUNTER_DATA_HARDWARE_COUNTER_DATAconst _ACTIVATION_CONTEXT_DETAILED_INFORMATIONconst _ACTIVATION_CONTEXT_DETAILED_INFORMATION *_ACTIVATION_CONTEXT_DETAILED_INFORMATION *PCACTIVATION_CONTEXT_DETAILED_INFORMATIONPACTIVATION_CONTEXT_DETAILED_INFORMATIONACTIVATION_CONTEXT_DETAILED_INFORMATION_ACTIVATION_CONTEXT_DETAILED_INFORMATION_MAXVERSIONTESTED_INFO *PMAXVERSIONTESTED_INFOMAXVERSIONTESTED_INFO_MAXVERSIONTESTED_INFO_SUPPORTED_OS_INFO *PSUPPORTED_OS_INFOSUPPORTED_OS_INFO_SUPPORTED_OS_INFOconst _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATIONconst _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION *_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION *PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATIONPACTIVATION_CONTEXT_COMPATIBILITY_INFORMATIONACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATIONconst _COMPATIBILITY_CONTEXT_ELEMENTconst _COMPATIBILITY_CONTEXT_ELEMENT *_COMPATIBILITY_CONTEXT_ELEMENT *PCCOMPATIBILITY_CONTEXT_ELEMENTPCOMPATIBILITY_CONTEXT_ELEMENTCOMPATIBILITY_CONTEXT_ELEMENT_COMPATIBILITY_CONTEXT_ELEMENTACTCTX_COMPATIBILITY_ELEMENT_TYPEACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWNACTCTX_COMPATIBILITY_ELEMENT_TYPE_OSACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATIONACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTEDconst _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATIONconst _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION *_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION *PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATIONPACTIVATION_CONTEXT_RUN_LEVEL_INFORMATIONACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATIONACTCTX_REQUESTED_RUN_LEVELACTCTX_RUN_LEVEL_UNSPECIFIEDACTCTX_RUN_LEVEL_AS_INVOKERACTCTX_RUN_LEVEL_HIGHEST_AVAILABLEACTCTX_RUN_LEVEL_REQUIRE_ADMINACTCTX_RUN_LEVEL_NUMBERSconst _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATIONconst _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION *_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION *PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATIONPACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATIONACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATIONconst ASSEMBLY_FILE_DETAILED_INFORMATIONconst ASSEMBLY_FILE_DETAILED_INFORMATION *_ASSEMBLY_FILE_DETAILED_INFORMATION *PCASSEMBLY_FILE_DETAILED_INFORMATIONPASSEMBLY_FILE_DETAILED_INFORMATIONASSEMBLY_FILE_DETAILED_INFORMATION_ASSEMBLY_FILE_DETAILED_INFORMATIONconst _ACTIVATION_CONTEXT_QUERY_INDEXconst _ACTIVATION_CONTEXT_QUERY_INDEX *_ACTIVATION_CONTEXT_QUERY_INDEX *PCACTIVATION_CONTEXT_QUERY_INDEXPACTIVATION_CONTEXT_QUERY_INDEXACTIVATION_CONTEXT_QUERY_INDEX_ACTIVATION_CONTEXT_QUERY_INDEXACTIVATION_CONTEXT_INFO_CLASS_ACTIVATION_CONTEXT_INFO_CLASSActivationContextBasicInformationActivationContextDetailedInformationAssemblyDetailedInformationInActivationContextFileInformationInAssemblyOfAssemblyInActivationContextRunlevelInformationInActivationContextCompatibilityInformationInActivationContextActivationContextManifestResourceNameMaxActivationContextInfoClassAssemblyDetailedInformationInActivationContxtFileInformationInAssemblyOfAssemblyInActivationContxtPSECURE_MEMORY_CACHE_CALLBACKPFLS_CALLBACK_FUNCTIONWAITORTIMERCALLBACKAPC_CALLBACK_FUNCTIONWORKERCALLBACKFUNCWAITORTIMERCALLBACKFUNC_HEAP_OPTIMIZE_RESOURCES_INFORMATION *PHEAP_OPTIMIZE_RESOURCES_INFORMATIONHEAP_OPTIMIZE_RESOURCES_INFORMATION_HEAP_OPTIMIZE_RESOURCES_INFORMATIONHEAP_INFORMATION_CLASS_HEAP_INFORMATION_CLASSHeapCompatibilityInformationHeapEnableTerminationOnCorruptionHeapOptimizeResourcesHeapTag_EXCEPTION_POINTERS *PVECTORED_EXCEPTION_HANDLERPAPCFUNC_RTL_CONDITION_VARIABLE *PRTL_CONDITION_VARIABLERTL_CONDITION_VARIABLE_RTL_CONDITION_VARIABLE_RTL_SRWLOCK *PRTL_SRWLOCKRTL_SRWLOCK_RTL_SRWLOCK_RTL_CRITICAL_SECTION *PRTL_CRITICAL_SECTIONRTL_CRITICAL_SECTION_RTL_CRITICAL_SECTION_DEBUG *PRTL_RESOURCE_DEBUGRTL_RESOURCE_DEBUGRTL_CRITICAL_SECTION_DEBUG_RTL_CRITICAL_SECTION_DEBUG_RTL_CRITICAL_SECTIONPRTL_CRITICAL_SECTION_DEBUG_RTL_SYSTEM_GLOBAL_DATA_ID *PRTL_SYSTEM_GLOBAL_DATA_IDRTL_SYSTEM_GLOBAL_DATA_ID_RTL_SYSTEM_GLOBAL_DATA_IDGlobalDataIdUnknownGlobalDataIdRngSeedVersionGlobalDataIdInterruptTimeGlobalDataIdTimeZoneBiasGlobalDataIdImageNumberLowGlobalDataIdImageNumberHighGlobalDataIdTimeZoneIdGlobalDataIdNtMajorVersionGlobalDataIdNtMinorVersionGlobalDataIdSystemExpirationDateGlobalDataIdKdDebuggerEnabledGlobalDataIdCyclesPerYieldGlobalDataIdSafeBootModeGlobalDataIdLastSystemRITEventTickCountGlobalDataIdConsoleSharedDataFlagsGlobalDataIdNtSystemRootDriveGlobalDataIdQpcShiftGlobalDataIdQpcBypassEnabledGlobalDataIdQpcDataGlobalDataIdQpcBiasconst IMAGE_POLICY_METADATAconst IMAGE_POLICY_METADATA *_IMAGE_POLICY_METADATA *PCIMAGE_POLICY_METADATAIMAGE_POLICY_METADATA_IMAGE_POLICY_METADATAconst IMAGE_POLICY_ENTRYconst IMAGE_POLICY_ENTRY *_IMAGE_POLICY_ENTRY *PCIMAGE_POLICY_ENTRYIMAGE_POLICY_ENTRY_IMAGE_POLICY_ENTRYIMAGE_POLICY_ID_IMAGE_POLICY_IDImagePolicyIdNoneImagePolicyIdEtwImagePolicyIdDebugImagePolicyIdCrashDumpImagePolicyIdCrashDumpKeyImagePolicyIdCrashDumpKeyGuidImagePolicyIdParentSdImagePolicyIdParentSdRevImagePolicyIdSvnImagePolicyIdDeviceIdImagePolicyIdCapabilityImagePolicyIdScenarioIdImagePolicyIdMaximumIMAGE_POLICY_ENTRY_TYPE_IMAGE_POLICY_ENTRY_TYPEImagePolicyEntryTypeNoneImagePolicyEntryTypeBoolImagePolicyEntryTypeInt8ImagePolicyEntryTypeUInt8ImagePolicyEntryTypeInt16ImagePolicyEntryTypeUInt16ImagePolicyEntryTypeInt32ImagePolicyEntryTypeUInt32ImagePolicyEntryTypeInt64ImagePolicyEntryTypeUInt64ImagePolicyEntryTypeAnsiStringImagePolicyEntryTypeUnicodeStringImagePolicyEntryTypeOverrideImagePolicyEntryTypeMaximum_CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG *PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIGCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG_CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIGCORRELATION_VECTOR *PCORRELATION_VECTORCORRELATION_VECTOR_NV_MEMORY_RANGE *PNV_MEMORY_RANGENV_MEMORY_RANGE_NV_MEMORY_RANGEOS_DEPLOYEMENT_STATE_VALUES_OS_DEPLOYEMENT_STATE_VALUESOS_DEPLOYMENT_STANDARDOS_DEPLOYMENT_COMPACTRTL_UMS_SCHEDULER_ENTRY_POINT *PRTL_UMS_SCHEDULER_ENTRY_POINTRTL_UMS_SCHEDULER_ENTRY_POINT_RTL_UMS_SCHEDULER_REASON *PRTL_UMS_SCHEDULER_REASONRTL_UMS_SCHEDULER_REASON_RTL_UMS_SCHEDULER_REASONUmsSchedulerStartupUmsSchedulerThreadBlockedUmsSchedulerThreadYield_RTL_UMS_THREAD_INFO_CLASS *PRTL_UMS_THREAD_INFO_CLASSRTL_UMS_THREAD_INFO_CLASS_RTL_UMS_THREAD_INFO_CLASSUmsThreadInvalidInfoClassUmsThreadUserContextUmsThreadPriorityUmsThreadAffinityUmsThreadTebUmsThreadIsSuspendedUmsThreadIsTerminatedUmsThreadMaxInfoClassLPOSVERSIONINFOEX_OSVERSIONINFOEXA *POSVERSIONINFOEXOSVERSIONINFOEX_OSVERSIONINFOEXW *PRTL_OSVERSIONINFOEXWRTL_OSVERSIONINFOEXWLPOSVERSIONINFOEXWPOSVERSIONINFOEXWOSVERSIONINFOEXW_OSVERSIONINFOEXWLPOSVERSIONINFOEXAPOSVERSIONINFOEXAOSVERSIONINFOEXA_OSVERSIONINFOEXALPOSVERSIONINFO_OSVERSIONINFOA *POSVERSIONINFOOSVERSIONINFO_OSVERSIONINFOW *PRTL_OSVERSIONINFOWRTL_OSVERSIONINFOWLPOSVERSIONINFOWPOSVERSIONINFOWOSVERSIONINFOW_OSVERSIONINFOWLPOSVERSIONINFOAPOSVERSIONINFOAOSVERSIONINFOA_OSVERSIONINFOA_MESSAGE_RESOURCE_DATA *PMESSAGE_RESOURCE_DATAMESSAGE_RESOURCE_DATA_MESSAGE_RESOURCE_DATA_MESSAGE_RESOURCE_BLOCK *PMESSAGE_RESOURCE_BLOCKMESSAGE_RESOURCE_BLOCK_MESSAGE_RESOURCE_BLOCK_MESSAGE_RESOURCE_ENTRY *PMESSAGE_RESOURCE_ENTRYMESSAGE_RESOURCE_ENTRY_MESSAGE_RESOURCE_ENTRY_RTL_BARRIER *PRTL_BARRIERRTL_BARRIER_RTL_BARRIER_RTL_RUN_ONCE *PRTL_RUN_ONCERTL_RUN_ONCE_RTL_RUN_ONCEPSLIST_HEADERSLIST_HEADER_SLIST_HEADER_SLIST_ENTRY *PSLIST_ENTRYSLIST_ENTRY_SLIST_ENTRY_UNWIND_HISTORY_TABLE *PUNWIND_HISTORY_TABLEUNWIND_HISTORY_TABLE_UNWIND_HISTORY_TABLE_ENTRY *PUNWIND_HISTORY_TABLE_ENTRYIMAGE_COR20_HEADER *PIMAGE_COR20_HEADERIMAGE_COR20_HEADERReplacesCorHdrNumericDefinesCOMIMAGE_FLAGS_ILONLYCOMIMAGE_FLAGS_32BITREQUIREDCOMIMAGE_FLAGS_IL_LIBRARYCOMIMAGE_FLAGS_STRONGNAMESIGNEDCOMIMAGE_FLAGS_NATIVE_ENTRYPOINTCOMIMAGE_FLAGS_TRACKDEBUGDATACOMIMAGE_FLAGS_32BITPREFERRED131072COR_VERSION_MAJOR_V2COR_VERSION_MAJORCOR_VERSION_MINORCOR_DELETED_NAME_LENGTHCOR_VTABLEGAP_NAME_LENGTHNATIVE_TYPE_MAX_CBCOR_ILMETHOD_SECT_SMALL_MAX_DATASIZE0xFFIMAGE_COR_MIH_METHODRVAIMAGE_COR_MIH_EHRVAIMAGE_COR_MIH_BASICBLOCKCOR_VTABLE_32BITCOR_VTABLE_64BITCOR_VTABLE_FROM_UNMANAGEDCOR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAINCOR_VTABLE_CALL_MOST_DERIVEDIMAGE_COR_EATJ_THUNK_SIZEMAX_CLASS_NAMEMAX_PACKAGE_NAMEIMPORT_OBJECT_NAME_TYPEIMPORT_OBJECT_ORDINALIMPORT_OBJECT_NAMEIMPORT_OBJECT_NAME_NO_PREFIXIMPORT_OBJECT_NAME_UNDECORATEIMPORT_OBJECT_NAME_EXPORTASIMPORT_OBJECT_TYPEIMPORT_OBJECT_CODEIMPORT_OBJECT_DATAIMPORT_OBJECT_CONSTIMPORT_OBJECT_HEADER_ImageArchitectureEntry *PIMAGE_ARCHITECTURE_ENTRYIMAGE_ARCHITECTURE_ENTRY_ImageArchitectureEntry_ImageArchitectureHeader *PIMAGE_ARCHITECTURE_HEADERIMAGE_ARCHITECTURE_HEADER_ImageArchitectureHeader_NON_PAGED_DEBUG_INFO *PNON_PAGED_DEBUG_INFONON_PAGED_DEBUG_INFO_NON_PAGED_DEBUG_INFO_IMAGE_SEPARATE_DEBUG_HEADER *PIMAGE_SEPARATE_DEBUG_HEADERIMAGE_SEPARATE_DEBUG_HEADER_IMAGE_SEPARATE_DEBUG_HEADER_IMAGE_FUNCTION_ENTRY64 *PIMAGE_FUNCTION_ENTRY64IMAGE_FUNCTION_ENTRY64_IMAGE_FUNCTION_ENTRY64_IMAGE_FUNCTION_ENTRY *PIMAGE_FUNCTION_ENTRYIMAGE_FUNCTION_ENTRY_IMAGE_FUNCTION_ENTRY_IMAGE_DEBUG_MISC *PIMAGE_DEBUG_MISCIMAGE_DEBUG_MISC_IMAGE_DEBUG_MISC_FPO_DATA *PFPO_DATAFPO_DATA_FPO_DATA_IMAGE_COFF_SYMBOLS_HEADER *PIMAGE_COFF_SYMBOLS_HEADERIMAGE_COFF_SYMBOLS_HEADER_IMAGE_COFF_SYMBOLS_HEADER_IMAGE_DEBUG_DIRECTORY *PIMAGE_DEBUG_DIRECTORYIMAGE_DEBUG_DIRECTORY_IMAGE_DEBUG_DIRECTORY_IMAGE_ENCLAVE_IMPORT *PIMAGE_ENCLAVE_IMPORTIMAGE_ENCLAVE_IMPORT_IMAGE_ENCLAVE_IMPORTPIMAGE_ENCLAVE_CONFIG_IMAGE_ENCLAVE_CONFIG64 *IMAGE_ENCLAVE_CONFIGPIMAGE_ENCLAVE_CONFIG64IMAGE_ENCLAVE_CONFIG64_IMAGE_ENCLAVE_CONFIG64_IMAGE_ENCLAVE_CONFIG32 *PIMAGE_ENCLAVE_CONFIG32IMAGE_ENCLAVE_CONFIG32_IMAGE_ENCLAVE_CONFIG32PIMAGE_RUNTIME_FUNCTION_ENTRY_IMAGE_RUNTIME_FUNCTION_ENTRY *IMAGE_RUNTIME_FUNCTION_ENTRYPIMAGE_AMD64_RUNTIME_FUNCTION_ENTRYIMAGE_AMD64_RUNTIME_FUNCTION_ENTRYPIMAGE_IA64_RUNTIME_FUNCTION_ENTRYIMAGE_IA64_RUNTIME_FUNCTION_ENTRY_PIMAGE_RUNTIME_FUNCTION_ENTRY_IMAGE_RUNTIME_FUNCTION_ENTRY_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRYIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRYIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRYIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY *PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRYIMAGE_ARM64_RUNTIME_FUNCTION_ENTRYARM64_FNPDATA_CRPdataCrUnchainedPdataCrUnchainedSavedLrPdataCrChainedWithPacPdataCrChainedARM64_FNPDATA_FLAGSPdataRefToFullXdataPdataPackedUnwindFunctionPdataPackedUnwindFragment_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY *PIMAGE_ARM_RUNTIME_FUNCTION_ENTRYIMAGE_ARM_RUNTIME_FUNCTION_ENTRY_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY_IMAGE_CE_RUNTIME_FUNCTION_ENTRY *PIMAGE_CE_RUNTIME_FUNCTION_ENTRYIMAGE_CE_RUNTIME_FUNCTION_ENTRY_IMAGE_CE_RUNTIME_FUNCTION_ENTRY_IMAGE_HOT_PATCH_HASHES *PIMAGE_HOT_PATCH_HASHESIMAGE_HOT_PATCH_HASHES_IMAGE_HOT_PATCH_HASHES_IMAGE_HOT_PATCH_BASE *PIMAGE_HOT_PATCH_BASEIMAGE_HOT_PATCH_BASE_IMAGE_HOT_PATCH_BASE_IMAGE_HOT_PATCH_INFO *PIMAGE_HOT_PATCH_INFOIMAGE_HOT_PATCH_INFO_IMAGE_HOT_PATCH_INFOPIMAGE_LOAD_CONFIG_DIRECTORY_IMAGE_LOAD_CONFIG_DIRECTORY64 *IMAGE_LOAD_CONFIG_DIRECTORYPIMAGE_LOAD_CONFIG_DIRECTORY64IMAGE_LOAD_CONFIG_DIRECTORY64_IMAGE_LOAD_CONFIG_DIRECTORY64_IMAGE_LOAD_CONFIG_DIRECTORY32 *PIMAGE_LOAD_CONFIG_DIRECTORY32IMAGE_LOAD_CONFIG_DIRECTORY32_IMAGE_LOAD_CONFIG_DIRECTORY32IMAGE_BDD_DYNAMIC_RELOCATION *_IMAGE_BDD_DYNAMIC_RELOCATION *PIMAGE_BDD_DYNAMIC_RELOCATIONIMAGE_BDD_DYNAMIC_RELOCATION_IMAGE_BDD_DYNAMIC_RELOCATIONIMAGE_BDD_INFO *_IMAGE_BDD_INFO *PIMAGE_BDD_INFOIMAGE_BDD_INFO_IMAGE_BDD_INFOIMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION *_IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION *PIMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATIONIMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION_IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION__unaligned IMAGE_FUNCTION_OVERRIDE_HEADER__unaligned IMAGE_FUNCTION_OVERRIDE_HEADER *_IMAGE_FUNCTION_OVERRIDE_HEADER *PIMAGE_FUNCTION_OVERRIDE_HEADERIMAGE_FUNCTION_OVERRIDE_HEADER_IMAGE_FUNCTION_OVERRIDE_HEADER__unaligned IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION__unaligned IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION *_IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION *PIMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATIONIMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION_IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION__unaligned IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION__unaligned IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION *_IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION *PIMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATIONIMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION_IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION__unaligned IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION__unaligned IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION *_IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION *PIMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATIONIMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION_IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION__unaligned IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER__unaligned IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER *_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER *PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADERIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER__unaligned IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER__unaligned IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER *_IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER *PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADERIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER_IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADERPIMAGE_DYNAMIC_RELOCATION_V2_IMAGE_DYNAMIC_RELOCATION64_V2 *IMAGE_DYNAMIC_RELOCATION_V2PIMAGE_DYNAMIC_RELOCATION_IMAGE_DYNAMIC_RELOCATION64 *IMAGE_DYNAMIC_RELOCATIONPIMAGE_DYNAMIC_RELOCATION64_V2IMAGE_DYNAMIC_RELOCATION64_V2_IMAGE_DYNAMIC_RELOCATION64_V2_IMAGE_DYNAMIC_RELOCATION32_V2 *PIMAGE_DYNAMIC_RELOCATION32_V2IMAGE_DYNAMIC_RELOCATION32_V2_IMAGE_DYNAMIC_RELOCATION32_V2PIMAGE_DYNAMIC_RELOCATION64IMAGE_DYNAMIC_RELOCATION64_IMAGE_DYNAMIC_RELOCATION64_IMAGE_DYNAMIC_RELOCATION32 *PIMAGE_DYNAMIC_RELOCATION32IMAGE_DYNAMIC_RELOCATION32_IMAGE_DYNAMIC_RELOCATION32_IMAGE_DYNAMIC_RELOCATION_TABLE *PIMAGE_DYNAMIC_RELOCATION_TABLEIMAGE_DYNAMIC_RELOCATION_TABLE_IMAGE_DYNAMIC_RELOCATION_TABLE_IMAGE_LOAD_CONFIG_CODE_INTEGRITY *PIMAGE_LOAD_CONFIG_CODE_INTEGRITYIMAGE_LOAD_CONFIG_CODE_INTEGRITY_IMAGE_LOAD_CONFIG_CODE_INTEGRITY_IMAGE_RESOURCE_DATA_ENTRY *PIMAGE_RESOURCE_DATA_ENTRYIMAGE_RESOURCE_DATA_ENTRY_IMAGE_RESOURCE_DATA_ENTRY_IMAGE_RESOURCE_DIR_STRING_U *PIMAGE_RESOURCE_DIR_STRING_UIMAGE_RESOURCE_DIR_STRING_U_IMAGE_RESOURCE_DIR_STRING_U_IMAGE_RESOURCE_DIRECTORY_STRING *PIMAGE_RESOURCE_DIRECTORY_STRINGIMAGE_RESOURCE_DIRECTORY_STRING_IMAGE_RESOURCE_DIRECTORY_STRING_IMAGE_RESOURCE_DIRECTORY_ENTRY *PIMAGE_RESOURCE_DIRECTORY_ENTRYIMAGE_RESOURCE_DIRECTORY_ENTRY_IMAGE_RESOURCE_DIRECTORY_ENTRY_IMAGE_RESOURCE_DIRECTORY *PIMAGE_RESOURCE_DIRECTORYIMAGE_RESOURCE_DIRECTORY_IMAGE_RESOURCE_DIRECTORYconst IMAGE_DELAYLOAD_DESCRIPTORconst IMAGE_DELAYLOAD_DESCRIPTOR *_IMAGE_DELAYLOAD_DESCRIPTOR *PCIMAGE_DELAYLOAD_DESCRIPTORPIMAGE_DELAYLOAD_DESCRIPTORIMAGE_DELAYLOAD_DESCRIPTOR_IMAGE_DELAYLOAD_DESCRIPTOR_IMAGE_BOUND_FORWARDER_REF *PIMAGE_BOUND_FORWARDER_REFIMAGE_BOUND_FORWARDER_REF_IMAGE_BOUND_FORWARDER_REF_IMAGE_BOUND_IMPORT_DESCRIPTOR *PIMAGE_BOUND_IMPORT_DESCRIPTORIMAGE_BOUND_IMPORT_DESCRIPTOR_IMAGE_BOUND_IMPORT_DESCRIPTOR__unaligned IMAGE_IMPORT_DESCRIPTOR__unaligned IMAGE_IMPORT_DESCRIPTOR *_IMAGE_IMPORT_DESCRIPTOR *PIMAGE_IMPORT_DESCRIPTORIMAGE_IMPORT_DESCRIPTOR_IMAGE_IMPORT_DESCRIPTORPIMAGE_TLS_DIRECTORY_IMAGE_TLS_DIRECTORY64 *IMAGE_TLS_DIRECTORYPIMAGE_THUNK_DATA_IMAGE_THUNK_DATA64 *IMAGE_THUNK_DATAIMAGE_TLS_DIRECTORY32 *_IMAGE_TLS_DIRECTORY32 *PIMAGE_TLS_DIRECTORY32IMAGE_TLS_DIRECTORY32_IMAGE_TLS_DIRECTORY32IMAGE_TLS_DIRECTORY64 *PIMAGE_TLS_DIRECTORY64IMAGE_TLS_DIRECTORY64_IMAGE_TLS_DIRECTORY64PIMAGE_TLS_CALLBACKIMAGE_THUNK_DATA32 *_IMAGE_THUNK_DATA32 *PIMAGE_THUNK_DATA32IMAGE_THUNK_DATA32_IMAGE_THUNK_DATA32IMAGE_THUNK_DATA64 *PIMAGE_THUNK_DATA64IMAGE_THUNK_DATA64_IMAGE_THUNK_DATA64_IMAGE_IMPORT_BY_NAME *PIMAGE_IMPORT_BY_NAMEIMAGE_IMPORT_BY_NAME_IMAGE_IMPORT_BY_NAME_IMAGE_EXPORT_DIRECTORY *PIMAGE_EXPORT_DIRECTORYIMAGE_EXPORT_DIRECTORY_IMAGE_EXPORT_DIRECTORY_IMAGE_ARCHIVE_MEMBER_HEADER *PIMAGE_ARCHIVE_MEMBER_HEADERIMAGE_ARCHIVE_MEMBER_HEADER_IMAGE_ARCHIVE_MEMBER_HEADER__unaligned IMAGE_BASE_RELOCATION__unaligned IMAGE_BASE_RELOCATION *_IMAGE_BASE_RELOCATION *PIMAGE_BASE_RELOCATIONIMAGE_BASE_RELOCATION_IMAGE_BASE_RELOCATION__unaligned IMAGE_LINENUMBER__unaligned IMAGE_LINENUMBER *_IMAGE_LINENUMBER *PIMAGE_LINENUMBERIMAGE_LINENUMBER_IMAGE_LINENUMBER__unaligned IMAGE_RELOCATION__unaligned IMAGE_RELOCATION *_IMAGE_RELOCATION *PIMAGE_RELOCATIONIMAGE_RELOCATION_IMAGE_RELOCATIONIMAGE_AUX_SYMBOL_TYPEIMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF__unaligned IMAGE_AUX_SYMBOL_EX__unaligned IMAGE_AUX_SYMBOL_EX *_IMAGE_AUX_SYMBOL_EX *PIMAGE_AUX_SYMBOL_EXIMAGE_AUX_SYMBOL_EX_IMAGE_AUX_SYMBOL_EX__unaligned IMAGE_AUX_SYMBOL__unaligned IMAGE_AUX_SYMBOL *_IMAGE_AUX_SYMBOL *PIMAGE_AUX_SYMBOLIMAGE_AUX_SYMBOL_IMAGE_AUX_SYMBOL__unaligned IMAGE_AUX_SYMBOL_TOKEN_DEF__unaligned IMAGE_AUX_SYMBOL_TOKEN_DEF *IMAGE_AUX_SYMBOL_TOKEN_DEF *PIMAGE_AUX_SYMBOL_TOKEN_DEFIMAGE_AUX_SYMBOL_TOKEN_DEF__unaligned IMAGE_SYMBOL_EX__unaligned IMAGE_SYMBOL_EX *_IMAGE_SYMBOL_EX *PIMAGE_SYMBOL_EXIMAGE_SYMBOL_EX_IMAGE_SYMBOL_EX__unaligned IMAGE_SYMBOL__unaligned IMAGE_SYMBOL *_IMAGE_SYMBOL *PIMAGE_SYMBOLIMAGE_SYMBOL_IMAGE_SYMBOL_IMAGE_SECTION_HEADER *PIMAGE_SECTION_HEADERIMAGE_SECTION_HEADER_IMAGE_SECTION_HEADERANON_OBJECT_HEADER_BIGOBJANON_OBJECT_HEADER_V2ANON_OBJECT_HEADERPIMAGE_NT_HEADERS_IMAGE_NT_HEADERS64 *IMAGE_NT_HEADERS_IMAGE_ROM_HEADERS *PIMAGE_ROM_HEADERSIMAGE_ROM_HEADERS_IMAGE_ROM_HEADERS_IMAGE_NT_HEADERS *PIMAGE_NT_HEADERS32IMAGE_NT_HEADERS32_IMAGE_NT_HEADERSPIMAGE_NT_HEADERS64IMAGE_NT_HEADERS64_IMAGE_NT_HEADERS64PIMAGE_OPTIONAL_HEADER_IMAGE_OPTIONAL_HEADER64 *IMAGE_OPTIONAL_HEADERPIMAGE_OPTIONAL_HEADER64IMAGE_OPTIONAL_HEADER64_IMAGE_OPTIONAL_HEADER64_IMAGE_ROM_OPTIONAL_HEADER *PIMAGE_ROM_OPTIONAL_HEADERIMAGE_ROM_OPTIONAL_HEADER_IMAGE_ROM_OPTIONAL_HEADER_IMAGE_OPTIONAL_HEADER *PIMAGE_OPTIONAL_HEADER32IMAGE_OPTIONAL_HEADER32_IMAGE_OPTIONAL_HEADER_IMAGE_DATA_DIRECTORY *PIMAGE_DATA_DIRECTORYIMAGE_DATA_DIRECTORY_IMAGE_DATA_DIRECTORY_IMAGE_FILE_HEADER *PIMAGE_FILE_HEADERIMAGE_FILE_HEADER_IMAGE_FILE_HEADER_IMAGE_VXD_HEADER *PIMAGE_VXD_HEADERIMAGE_VXD_HEADER_IMAGE_VXD_HEADER_IMAGE_OS2_HEADER *PIMAGE_OS2_HEADERIMAGE_OS2_HEADER_IMAGE_OS2_HEADER_IMAGE_DOS_HEADER *PIMAGE_DOS_HEADERIMAGE_DOS_HEADER_IMAGE_DOS_HEADERPSYSTEM_BATTERY_STATESYSTEM_BATTERY_STATEPSYSTEM_POWER_CAPABILITIESSYSTEM_POWER_CAPABILITIES_HIBERFILE_BUCKET *PHIBERFILE_BUCKETHIBERFILE_BUCKET_HIBERFILE_BUCKET_HIBERFILE_BUCKET_SIZE *PHIBERFILE_BUCKET_SIZEHIBERFILE_BUCKET_SIZE_HIBERFILE_BUCKET_SIZEHiberFileBucket1GBHiberFileBucket2GBHiberFileBucket4GBHiberFileBucket8GBHiberFileBucket16GBHiberFileBucket32GBHiberFileBucketUnlimitedHiberFileBucketMax_ADMINISTRATOR_POWER_POLICY *PADMINISTRATOR_POWER_POLICYADMINISTRATOR_POWER_POLICY_ADMINISTRATOR_POWER_POLICYPPROCESSOR_PERFSTATE_POLICYPROCESSOR_PERFSTATE_POLICY_PROCESSOR_POWER_POLICY *PPROCESSOR_POWER_POLICYPROCESSOR_POWER_POLICY_PROCESSOR_POWER_POLICY_PROCESSOR_POWER_POLICY_INFO *PPROCESSOR_POWER_POLICY_INFOPROCESSOR_POWER_POLICY_INFO_PROCESSOR_POWER_POLICY_INFOPPROCESSOR_IDLESTATE_POLICYPROCESSOR_IDLESTATE_POLICYPPROCESSOR_IDLESTATE_INFOPROCESSOR_IDLESTATE_INFO_SYSTEM_POWER_POLICY *PSYSTEM_POWER_POLICYSYSTEM_POWER_POLICY_SYSTEM_POWER_POLICYPSYSTEM_POWER_LEVELSYSTEM_POWER_LEVELPPOWER_ACTION_POLICYPOWER_ACTION_POLICYPPPM_THERMAL_POLICY_EVENTPPM_THERMAL_POLICY_EVENTPPPM_THERMALCHANGE_EVENTPPM_THERMALCHANGE_EVENTPPPM_IDLESTATE_EVENTPPM_IDLESTATE_EVENTPPPM_PERFSTATE_DOMAIN_EVENTPPM_PERFSTATE_DOMAIN_EVENTPPPM_PERFSTATE_EVENTPPM_PERFSTATE_EVENTPPPM_IDLE_ACCOUNTING_EXPPM_IDLE_ACCOUNTING_EXPPPM_IDLE_STATE_ACCOUNTING_EXPPM_IDLE_STATE_ACCOUNTING_EXPPPM_IDLE_STATE_BUCKET_EXPPM_IDLE_STATE_BUCKET_EXPPPM_IDLE_ACCOUNTINGPPM_IDLE_ACCOUNTINGPPPM_IDLE_STATE_ACCOUNTINGPPM_IDLE_STATE_ACCOUNTINGPPPM_WMI_PERF_STATES_EXPPM_WMI_PERF_STATES_EXPPPM_WMI_PERF_STATESPPM_WMI_PERF_STATESPPPM_WMI_PERF_STATEPPM_WMI_PERF_STATEPPPM_WMI_IDLE_STATES_EXPPM_WMI_IDLE_STATES_EXPPPM_WMI_IDLE_STATESPPM_WMI_IDLE_STATESPPPM_WMI_IDLE_STATEPPM_WMI_IDLE_STATEPPPM_WMI_LEGACY_PERFSTATEPPM_WMI_LEGACY_PERFSTATEPBATTERY_REPORTING_SCALEBATTERY_REPORTING_SCALEPOWER_SETTING_ALTITUDE *PPOWER_SETTING_ALTITUDEPOWER_SETTING_ALTITUDEALTITUDE_GROUP_POLICYALTITUDE_USERALTITUDE_RUNTIME_OVERRIDEALTITUDE_PROVISIONINGALTITUDE_OEM_CUSTOMIZATIONALTITUDE_INTERNAL_OVERRIDEALTITUDE_OS_DEFAULT_POWER_PLATFORM_INFORMATION *PPOWER_PLATFORM_INFORMATIONPOWER_PLATFORM_INFORMATION_POWER_PLATFORM_INFORMATION_POWER_PLATFORM_ROLE *PPOWER_PLATFORM_ROLEPOWER_PLATFORM_ROLE_POWER_PLATFORM_ROLEPlatformRoleUnspecifiedPlatformRoleDesktopPlatformRoleMobilePlatformRoleWorkstationPlatformRoleEnterpriseServerPlatformRoleSOHOServerPlatformRoleAppliancePCPlatformRolePerformanceServerPlatformRoleSlatePlatformRoleMaximum_APPLICATIONLAUNCH_SETTING_VALUE *PAPPLICATIONLAUNCH_SETTING_VALUEAPPLICATIONLAUNCH_SETTING_VALUE_APPLICATIONLAUNCH_SETTING_VALUEPNOTIFY_USER_POWER_SETTINGNOTIFY_USER_POWER_SETTINGPSET_POWER_SETTING_VALUESET_POWER_SETTING_VALUESYSTEM_POWER_CONDITIONPoAcPoDcPoHotPoConditionMaximum_RESUME_PERFORMANCE *PRESUME_PERFORMANCERESUME_PERFORMANCE_RESUME_PERFORMANCE_POWER_MONITOR_INVOCATION *PPOWER_MONITOR_INVOCATIONPOWER_MONITOR_INVOCATION_POWER_MONITOR_INVOCATIONPOWER_MONITOR_REQUEST_TYPE_POWER_MONITOR_REQUEST_TYPEMonitorRequestTypeOffMonitorRequestTypeOnAndPresentMonitorRequestTypeToggleOnPOWER_MONITOR_REQUEST_REASONMonitorRequestReasonUnknownMonitorRequestReasonPowerButtonMonitorRequestReasonRemoteConnectionMonitorRequestReasonScMonitorpowerMonitorRequestReasonUserInputMonitorRequestReasonAcDcDisplayBurstMonitorRequestReasonUserDisplayBurstMonitorRequestReasonPoSetSystemStateMonitorRequestReasonSetThreadExecutionStateMonitorRequestReasonFullWakeMonitorRequestReasonSessionUnlockMonitorRequestReasonScreenOffRequestMonitorRequestReasonIdleTimeoutMonitorRequestReasonPolicyChangeMonitorRequestReasonSleepButtonMonitorRequestReasonLidMonitorRequestReasonBatteryCountChangeMonitorRequestReasonGracePeriodMonitorRequestReasonPnPMonitorRequestReasonDPMonitorRequestReasonSxTransitionMonitorRequestReasonSystemIdleMonitorRequestReasonNearProximityMonitorRequestReasonThermalStandbyMonitorRequestReasonResumePdcMonitorRequestReasonResumeS4MonitorRequestReasonTerminalMonitorRequestReasonPdcSignalMonitorRequestReasonAcDcDisplayBurstSuppressedMonitorRequestReasonSystemStateEnteredMonitorRequestReasonWinrtMonitorRequestReasonUserInputKeyboardMonitorRequestReasonUserInputMouseMonitorRequestReasonUserInputTouchpadMonitorRequestReasonUserInputPenMonitorRequestReasonUserInputAccelerometer35MonitorRequestReasonUserInputHidMonitorRequestReasonUserInputPoUserPresent37MonitorRequestReasonUserInputSessionSwitchMonitorRequestReasonUserInputInitializationMonitorRequestReasonPdcSignalWindowsMobilePwrNotifMonitorRequestReasonPdcSignalWindowsMobileShellMonitorRequestReasonPdcSignalHeyCortanaMonitorRequestReasonPdcSignalHolographicShellMonitorRequestReasonPdcSignalFingerprintMonitorRequestReasonDirectedDripsMonitorRequestReasonDimMonitorRequestReasonBuiltinPanel47MonitorRequestReasonDisplayRequiredUnDimMonitorRequestReasonBatteryCountChangeSuppressedMonitorRequestReasonResumeModernStandby50MonitorRequestReasonTerminalInitMonitorRequestReasonPdcSignalSensorsHumanPresenceMonitorRequestReasonBatteryPreCriticalMonitorRequestReasonUserInputTouch54MonitorRequestReasonMax_POWER_IDLE_RESILIENCY *PPOWER_IDLE_RESILIENCYPOWER_IDLE_RESILIENCY_POWER_IDLE_RESILIENCY_POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES *PPOWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICESPOWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES_POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES_POWER_SESSION_WINLOGON *PPOWER_SESSION_WINLOGONPOWER_SESSION_WINLOGON_POWER_SESSION_WINLOGON_POWER_SESSION_RIT_STATE *PPOWER_SESSION_RIT_STATEPOWER_SESSION_RIT_STATE_POWER_SESSION_RIT_STATE_POWER_SESSION_TIMEOUTS *PPOWER_SESSION_TIMEOUTSPOWER_SESSION_TIMEOUTS_POWER_SESSION_TIMEOUTS_POWER_SESSION_CONNECT *PPOWER_SESSION_CONNECTPOWER_SESSION_CONNECT_POWER_SESSION_CONNECT_POWER_USER_PRESENCE *PPOWER_USER_PRESENCEPOWER_USER_PRESENCE_POWER_USER_PRESENCEenum <unnamed> *PPOWER_USER_PRESENCE_TYPEPOWER_USER_PRESENCE_TYPEUserNotPresentUserPresentUserUnknownPOWER_INFORMATION_LEVELSystemPowerPolicyAcSystemPowerPolicyDcVerifySystemPolicyAcVerifySystemPolicyDcSystemPowerCapabilitiesSystemBatteryStateSystemPowerStateHandlerProcessorStateHandlerSystemPowerPolicyCurrentAdministratorPowerPolicySystemReserveHiberFileProcessorInformationSystemPowerInformationProcessorStateHandler2LastWakeTimeLastSleepTimeSystemExecutionStateSystemPowerStateNotifyHandlerProcessorPowerPolicyAcProcessorPowerPolicyDcVerifyProcessorPowerPolicyAcVerifyProcessorPowerPolicyDcProcessorPowerPolicyCurrentSystemPowerStateLoggingSystemPowerLoggingEntrySetPowerSettingValueNotifyUserPowerSettingPowerInformationLevelUnused0SystemMonitorHiberBootPowerOffSystemVideoStateTraceApplicationPowerMessageTraceApplicationPowerMessageEndProcessorPerfStatesProcessorIdleStatesProcessorCapSystemWakeSourceSystemHiberFileInformationTraceServicePowerMessageProcessorLoadPowerShutdownNotificationMonitorCapabilitiesSessionPowerInitSessionDisplayStatePowerRequestCreatePowerRequestActionGetPowerRequestListProcessorInformationExNotifyUserModeLegacyPowerEventGroupParkProcessorIdleDomainsWakeTimerListSystemHiberFileSizeProcessorIdleStatesHvProcessorPerfStatesHvProcessorPerfCapHvProcessorSetIdleLogicalProcessorIdlingUserPresencePowerSettingNotificationNameGetPowerSettingValue59IdleResiliencySessionRITStateSessionConnectNotification62SessionPowerCleanupSessionLockStateSystemHiberbootStatePlatformInformationPdcInvocationMonitorInvocationFirmwareTableInformationRegisteredSetShutdownSelectedTimeSuspendResumeInvocationPlmPowerRequestCreateScreenOffCsDeviceNotification74PlatformRoleLastResumePerformanceDisplayBurstExitLatencySamplingPercentageRegisterSpmPowerSettingsPlatformIdleStatesProcessorIdleVeto81PlatformIdleVetoSystemBatteryStatePreciseThermalEventPowerRequestActionInternal85BatteryDeviceStatePowerInformationInternal87ThermalStandbySystemHiberFileTypePhysicalPowerButtonPressQueryPotentialDripsConstraintEnergyTrackerCreateEnergyTrackerQueryUpdateBlackBoxRecorderSessionAllowExternalDmaDevicesSendSuspendResumeNotificationBlackBoxRecorderDirectAccessBufferPowerInformationLevelMaximumCM_Power_Data_s *PCM_POWER_DATACM_POWER_DATACM_Power_Data_s_POWER_REQUEST_TYPE *PPOWER_REQUEST_TYPEPOWER_REQUEST_TYPE_POWER_REQUEST_TYPEPowerRequestDisplayRequiredPowerRequestSystemRequiredPowerRequestAwayModeRequiredPowerRequestExecutionRequiredLATENCY_TIMELT_DONT_CARELT_LOWEST_LATENCYPEXECUTION_STATEEXECUTION_STATE_USER_ACTIVITY_PRESENCE *PUSER_ACTIVITY_PRESENCEUSER_ACTIVITY_PRESENCE_USER_ACTIVITY_PRESENCEPowerUserPresentPowerUserNotPresentPowerUserInactivePowerUserMaximumPowerUserInvalid_MONITOR_DISPLAY_STATE *PMONITOR_DISPLAY_STATEMONITOR_DISPLAY_STATE_MONITOR_DISPLAY_STATEPowerMonitorOffPowerMonitorOnPowerMonitorDim_DEVICE_POWER_STATE *PDEVICE_POWER_STATEDEVICE_POWER_STATE_DEVICE_POWER_STATEPowerDeviceUnspecifiedPowerDeviceD0PowerDeviceD1PowerDeviceD2PowerDeviceD3PowerDeviceMaximumPPOWER_ACTIONPOWER_ACTIONPowerActionNonePowerActionReservedPowerActionSleepPowerActionHibernatePowerActionShutdownPowerActionShutdownResetPowerActionShutdownOffPowerActionWarmEjectPowerActionDisplayOff_SYSTEM_POWER_STATE *PSYSTEM_POWER_STATESYSTEM_POWER_STATE_SYSTEM_POWER_STATEPowerSystemUnspecifiedPowerSystemWorkingPowerSystemSleeping1PowerSystemSleeping2PowerSystemSleeping3PowerSystemHibernatePowerSystemShutdownPowerSystemMaximum_NETWORK_APP_INSTANCE_EA *PNETWORK_APP_INSTANCE_EANETWORK_APP_INSTANCE_EA_NETWORK_APP_INSTANCE_EA_SHUFFLE_FILE_DATA *PSHUFFLE_FILE_DATASHUFFLE_FILE_DATA_SHUFFLE_FILE_DATA_REARRANGE_FILE_DATA32 *PREARRANGE_FILE_DATA32REARRANGE_FILE_DATA32_REARRANGE_FILE_DATA32_REARRANGE_FILE_DATA *PREARRANGE_FILE_DATAREARRANGE_FILE_DATA_REARRANGE_FILE_DATA_SHARED_VIRTUAL_DISK_SUPPORT *PSHARED_VIRTUAL_DISK_SUPPORTSHARED_VIRTUAL_DISK_SUPPORT_SHARED_VIRTUAL_DISK_SUPPORTSharedVirtualDiskHandleState_SharedVirtualDiskHandleStateSharedVirtualDiskHandleStateNoneSharedVirtualDiskHandleStateFileSharedSharedVirtualDiskHandleStateHandleSharedSharedVirtualDiskSupportType_SharedVirtualDiskSupportTypeSharedVirtualDisksUnsupportedSharedVirtualDisksSupportedSharedVirtualDiskSnapshotsSupportedSharedVirtualDiskCDPSnapshotsSupported_SCRUB_DATA_OUTPUT *PSCRUB_DATA_OUTPUTSCRUB_DATA_OUTPUT_SCRUB_DATA_OUTPUT_SCRUB_PARITY_EXTENT_DATA *PSCRUB_PARITY_EXTENT_DATASCRUB_PARITY_EXTENT_DATA_SCRUB_PARITY_EXTENT_DATA_SCRUB_PARITY_EXTENT *PSCRUB_PARITY_EXTENTSCRUB_PARITY_EXTENT_SCRUB_PARITY_EXTENT_SCRUB_DATA_INPUT *PSCRUB_DATA_INPUTSCRUB_DATA_INPUT_SCRUB_DATA_INPUT_REPARSE_GUID_DATA_BUFFER *PREPARSE_GUID_DATA_BUFFERREPARSE_GUID_DATA_BUFFER_REPARSE_GUID_DATA_BUFFER_FILE_SEGMENT_ELEMENT *PFILE_SEGMENT_ELEMENTFILE_SEGMENT_ELEMENT_FILE_SEGMENT_ELEMENT_FILE_NOTIFY_FULL_INFORMATION *PFILE_NOTIFY_FULL_INFORMATIONFILE_NOTIFY_FULL_INFORMATION_FILE_NOTIFY_FULL_INFORMATION_FILE_NOTIFY_EXTENDED_INFORMATION *PFILE_NOTIFY_EXTENDED_INFORMATIONFILE_NOTIFY_EXTENDED_INFORMATION_FILE_NOTIFY_EXTENDED_INFORMATION_FILE_NOTIFY_INFORMATION *PFILE_NOTIFY_INFORMATIONFILE_NOTIFY_INFORMATION_FILE_NOTIFY_INFORMATION_FILE_ID_128 *PFILE_ID_128FILE_ID_128_FILE_ID_128_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION *PMEMORY_PARTITION_DEDICATED_MEMORY_INFORMATIONMEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION_MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE *PMEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTEMEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE_MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTELPENCLAVE_TARGET_FUNCTIONENCLAVE_TARGET_FUNCTION *PENCLAVE_TARGET_FUNCTIONENCLAVE_TARGET_FUNCTION_ENCLAVE_INIT_INFO_VBS *PENCLAVE_INIT_INFO_VBSENCLAVE_INIT_INFO_VBS_ENCLAVE_INIT_INFO_VBS_ENCLAVE_INIT_INFO_VBS_BASIC *PENCLAVE_INIT_INFO_VBS_BASICENCLAVE_INIT_INFO_VBS_BASIC_ENCLAVE_INIT_INFO_VBS_BASIC_ENCLAVE_LOAD_DATA_VBS_BASIC *PENCLAVE_LOAD_DATA_VBS_BASICENCLAVE_LOAD_DATA_VBS_BASIC_ENCLAVE_LOAD_DATA_VBS_BASIC_ENCLAVE_CREATE_INFO_VBS_BASIC *PENCLAVE_CREATE_INFO_VBS_BASICENCLAVE_CREATE_INFO_VBS_BASIC_ENCLAVE_CREATE_INFO_VBS_BASIC_ENCLAVE_CREATE_INFO_VBS *PENCLAVE_CREATE_INFO_VBSENCLAVE_CREATE_INFO_VBS_ENCLAVE_CREATE_INFO_VBS_ENCLAVE_INIT_INFO_SGX *PENCLAVE_INIT_INFO_SGXENCLAVE_INIT_INFO_SGX_ENCLAVE_INIT_INFO_SGX_ENCLAVE_CREATE_INFO_SGX *PENCLAVE_CREATE_INFO_SGXENCLAVE_CREATE_INFO_SGX_ENCLAVE_CREATE_INFO_SGXMEM_SECTION_EXTENDED_PARAMETER_TYPE *PMEM_SECTION_EXTENDED_PARAMETER_TYPEMEM_SECTION_EXTENDED_PARAMETER_TYPEMemSectionExtendedParameterInvalidTypeMemSectionExtendedParameterUserPhysicalFlagsMemSectionExtendedParameterNumaNodeMemSectionExtendedParameterSigningLevelMemSectionExtendedParameterMax_MEM_DEDICATED_ATTRIBUTE_TYPE *PMEM_DEDICATED_ATTRIBUTE_TYPEMEM_DEDICATED_ATTRIBUTE_TYPE_MEM_DEDICATED_ATTRIBUTE_TYPEMemDedicatedAttributeReadBandwidthMemDedicatedAttributeReadLatencyMemDedicatedAttributeWriteBandwidthMemDedicatedAttributeWriteLatencyMemDedicatedAttributeMaxMEM_EXTENDED_PARAMETER *PMEM_EXTENDED_PARAMETERMEM_EXTENDED_PARAMETERMEM_EXTENDED_PARAMETER_TYPE *PMEM_EXTENDED_PARAMETER_TYPEMEM_EXTENDED_PARAMETER_TYPEMemExtendedParameterInvalidTypeMemExtendedParameterAddressRequirementsMemExtendedParameterNumaNodeMemExtendedParameterPartitionHandleMemExtendedParameterUserPhysicalHandleMemExtendedParameterAttributeFlagsMemExtendedParameterImageMachineMemExtendedParameterMax_MEM_ADDRESS_REQUIREMENTS *PMEM_ADDRESS_REQUIREMENTSMEM_ADDRESS_REQUIREMENTS_MEM_ADDRESS_REQUIREMENTS_CFG_CALL_TARGET_INFO *PCFG_CALL_TARGET_INFOCFG_CALL_TARGET_INFO_CFG_CALL_TARGET_INFO_MEMORY_BASIC_INFORMATION64 *PMEMORY_BASIC_INFORMATION64MEMORY_BASIC_INFORMATION64_MEMORY_BASIC_INFORMATION64_MEMORY_BASIC_INFORMATION32 *PMEMORY_BASIC_INFORMATION32MEMORY_BASIC_INFORMATION32_MEMORY_BASIC_INFORMATION32_MEMORY_BASIC_INFORMATION *PMEMORY_BASIC_INFORMATIONMEMORY_BASIC_INFORMATION_MEMORY_BASIC_INFORMATION_XSTATE_CONFIGURATION *PXSTATE_CONFIGURATIONXSTATE_CONFIGURATION_XSTATE_CONFIGURATION_XSTATE_FEATURE *PXSTATE_FEATUREXSTATE_FEATURE_XSTATE_FEATURESYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION_SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION *PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATIONSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION_SYSTEM_POOL_ZEROING_INFORMATION *PSYSTEM_POOL_ZEROING_INFORMATIONSYSTEM_POOL_ZEROING_INFORMATION_SYSTEM_POOL_ZEROING_INFORMATION_SYSTEM_CPU_SET_INFORMATION *PSYSTEM_CPU_SET_INFORMATIONSYSTEM_CPU_SET_INFORMATION_SYSTEM_CPU_SET_INFORMATION_CPU_SET_INFORMATION_TYPE *PCPU_SET_INFORMATION_TYPECPU_SET_INFORMATION_TYPE_CPU_SET_INFORMATION_TYPECpuSetInformation_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EXSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX_GROUP_RELATIONSHIP *PGROUP_RELATIONSHIPGROUP_RELATIONSHIP_GROUP_RELATIONSHIP_PROCESSOR_GROUP_INFO *PPROCESSOR_GROUP_INFOPROCESSOR_GROUP_INFO_PROCESSOR_GROUP_INFO_CACHE_RELATIONSHIP *PCACHE_RELATIONSHIPCACHE_RELATIONSHIP_CACHE_RELATIONSHIP_NUMA_NODE_RELATIONSHIP *PNUMA_NODE_RELATIONSHIPNUMA_NODE_RELATIONSHIP_NUMA_NODE_RELATIONSHIP_PROCESSOR_RELATIONSHIP *PPROCESSOR_RELATIONSHIPPROCESSOR_RELATIONSHIP_PROCESSOR_RELATIONSHIP_SYSTEM_LOGICAL_PROCESSOR_INFORMATION *PSYSTEM_LOGICAL_PROCESSOR_INFORMATIONSYSTEM_LOGICAL_PROCESSOR_INFORMATION_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_CACHE_DESCRIPTOR *PCACHE_DESCRIPTORCACHE_DESCRIPTOR_CACHE_DESCRIPTORPROCESSOR_CACHE_TYPE_PROCESSOR_CACHE_TYPECacheUnifiedCacheInstructionCacheDataCacheTraceLOGICAL_PROCESSOR_RELATIONSHIP_LOGICAL_PROCESSOR_RELATIONSHIPRelationProcessorCoreRelationNumaNodeRelationCacheRelationProcessorPackageRelationGroupRelationProcessorDieRelationNumaNodeExRelationProcessorModuleRelationAll_FIRMWARE_TYPE *PFIRMWARE_TYPEFIRMWARE_TYPE_FIRMWARE_TYPEFirmwareTypeUnknownFirmwareTypeBiosFirmwareTypeUefiFirmwareTypeMax_SERVERSILO_BASIC_INFORMATION *PSERVERSILO_BASIC_INFORMATIONSERVERSILO_BASIC_INFORMATION_SERVERSILO_BASIC_INFORMATION_SERVERSILO_STATE *PSERVERSILO_STATESERVERSILO_STATE_SERVERSILO_STATESERVERSILO_INITINGSERVERSILO_STARTEDSERVERSILO_SHUTTING_DOWNSERVERSILO_TERMINATINGSERVERSILO_TERMINATED_SILOOBJECT_BASIC_INFORMATION *PSILOOBJECT_BASIC_INFORMATIONSILOOBJECT_BASIC_INFORMATION_SILOOBJECT_BASIC_INFORMATIONJOBOBJECTINFOCLASS_JOBOBJECTINFOCLASSJobObjectBasicAccountingInformationJobObjectBasicLimitInformationJobObjectBasicProcessIdListJobObjectBasicUIRestrictionsJobObjectSecurityLimitInformationJobObjectEndOfJobTimeInformationJobObjectAssociateCompletionPortInformationJobObjectBasicAndIoAccountingInformationJobObjectExtendedLimitInformationJobObjectJobSetInformationJobObjectGroupInformationJobObjectNotificationLimitInformationJobObjectLimitViolationInformationJobObjectGroupInformationExJobObjectCpuRateControlInformationJobObjectCompletionFilterJobObjectCompletionCounterJobObjectReserved1InformationJobObjectReserved2InformationJobObjectReserved3InformationJobObjectReserved4InformationJobObjectReserved5InformationJobObjectReserved6InformationJobObjectReserved7InformationJobObjectReserved8InformationJobObjectReserved9InformationJobObjectReserved10InformationJobObjectReserved11InformationJobObjectReserved12InformationJobObjectReserved13InformationJobObjectReserved14InformationJobObjectNetRateControlInformationJobObjectNotificationLimitInformation2JobObjectLimitViolationInformation2JobObjectCreateSiloJobObjectSiloBasicInformationJobObjectReserved15InformationJobObjectReserved16InformationJobObjectReserved17InformationJobObjectReserved18InformationJobObjectReserved19InformationJobObjectReserved20InformationJobObjectReserved21InformationJobObjectReserved22InformationJobObjectReserved23InformationJobObjectReserved24InformationJobObjectReserved25InformationJobObjectReserved26InformationJobObjectReserved27InformationMaxJobObjectInfoClass_JOBOBJECT_IO_ATTRIBUTION_INFORMATION *PJOBOBJECT_IO_ATTRIBUTION_INFORMATIONJOBOBJECT_IO_ATTRIBUTION_INFORMATION_JOBOBJECT_IO_ATTRIBUTION_INFORMATION_JOBOBJECT_IO_ATTRIBUTION_STATS *PJOBOBJECT_IO_ATTRIBUTION_STATSJOBOBJECT_IO_ATTRIBUTION_STATS_JOBOBJECT_IO_ATTRIBUTION_STATSJOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGSJOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLEJOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLEJOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGSJOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V1JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVEJOB_OBJECT_IO_RATE_CONTROL_FLAGSJOB_OBJECT_IO_RATE_CONTROL_ENABLEJOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUMEJOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL0x4JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP0x8JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGSJOB_OBJECT_IO_RATE_CONTROL_ENABLE |
                                             JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUMEJOB_OBJECT_IO_RATE_CONTROL_ENABLE |
                                             JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME |
                                             JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALLJOB_OBJECT_IO_RATE_CONTROL_ENABLE |
                                             JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME |
                                             JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL |
                                             JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAPJOBOBJECT_NET_RATE_CONTROL_INFORMATIONJOB_OBJECT_NET_RATE_CONTROL_FLAGSJOB_OBJECT_NET_RATE_CONTROL_ENABLEJOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTHJOB_OBJECT_NET_RATE_CONTROL_DSCP_TAGJOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS0x7_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION *PJOBOBJECT_CPU_RATE_CONTROL_INFORMATIONJOBOBJECT_CPU_RATE_CONTROL_INFORMATION_JOBOBJECT_CPU_RATE_CONTROL_INFORMATIONJOBOBJECT_LIMIT_VIOLATION_INFORMATION_2_JOBOBJECT_LIMIT_VIOLATION_INFORMATION *PJOBOBJECT_LIMIT_VIOLATION_INFORMATIONJOBOBJECT_LIMIT_VIOLATION_INFORMATION_JOBOBJECT_LIMIT_VIOLATION_INFORMATIONJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION *PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATIONJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL *PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVALJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL_JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVALToleranceIntervalShortToleranceIntervalMediumToleranceIntervalLong_JOBOBJECT_RATE_CONTROL_TOLERANCE *PJOBOBJECT_RATE_CONTROL_TOLERANCEJOBOBJECT_RATE_CONTROL_TOLERANCE_JOBOBJECT_RATE_CONTROL_TOLERANCEToleranceLowToleranceMediumToleranceHigh_JOBOBJECT_JOBSET_INFORMATION *PJOBOBJECT_JOBSET_INFORMATIONJOBOBJECT_JOBSET_INFORMATION_JOBOBJECT_JOBSET_INFORMATION_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATIONJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION_JOBOBJECT_ASSOCIATE_COMPLETION_PORT *PJOBOBJECT_ASSOCIATE_COMPLETION_PORTJOBOBJECT_ASSOCIATE_COMPLETION_PORT_JOBOBJECT_ASSOCIATE_COMPLETION_PORT_JOBOBJECT_END_OF_JOB_TIME_INFORMATION *PJOBOBJECT_END_OF_JOB_TIME_INFORMATIONJOBOBJECT_END_OF_JOB_TIME_INFORMATION_JOBOBJECT_END_OF_JOB_TIME_INFORMATION_JOBOBJECT_SECURITY_LIMIT_INFORMATION *PJOBOBJECT_SECURITY_LIMIT_INFORMATIONJOBOBJECT_SECURITY_LIMIT_INFORMATION_JOBOBJECT_SECURITY_LIMIT_INFORMATION_JOBOBJECT_BASIC_UI_RESTRICTIONS *PJOBOBJECT_BASIC_UI_RESTRICTIONSJOBOBJECT_BASIC_UI_RESTRICTIONS_JOBOBJECT_BASIC_UI_RESTRICTIONS_JOBOBJECT_BASIC_PROCESS_ID_LIST *PJOBOBJECT_BASIC_PROCESS_ID_LISTJOBOBJECT_BASIC_PROCESS_ID_LIST_JOBOBJECT_BASIC_PROCESS_ID_LIST_JOBOBJECT_EXTENDED_LIMIT_INFORMATION *PJOBOBJECT_EXTENDED_LIMIT_INFORMATIONJOBOBJECT_EXTENDED_LIMIT_INFORMATION_JOBOBJECT_EXTENDED_LIMIT_INFORMATION_JOBOBJECT_BASIC_LIMIT_INFORMATION *PJOBOBJECT_BASIC_LIMIT_INFORMATIONJOBOBJECT_BASIC_LIMIT_INFORMATION_JOBOBJECT_BASIC_LIMIT_INFORMATION_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATIONJOBOBJECT_BASIC_ACCOUNTING_INFORMATION_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION_PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY *PPROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICYPROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY_PROCESS_MITIGATION_ACTIVATION_CONTEXT_TRUST_POLICY_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY *PPROCESS_MITIGATION_REDIRECTION_TRUST_POLICYPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY *PPROCESS_MITIGATION_USER_POINTER_AUTH_POLICYPROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY *PPROCESS_MITIGATION_USER_SHADOW_STACK_POLICYPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY *PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICYPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_PROCESS_MITIGATION_CHILD_PROCESS_POLICY *PPROCESS_MITIGATION_CHILD_PROCESS_POLICYPROCESS_MITIGATION_CHILD_PROCESS_POLICY_PROCESS_MITIGATION_CHILD_PROCESS_POLICY_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICYPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICYPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_PROCESS_MITIGATION_IMAGE_LOAD_POLICY *PPROCESS_MITIGATION_IMAGE_LOAD_POLICYPROCESS_MITIGATION_IMAGE_LOAD_POLICY_PROCESS_MITIGATION_IMAGE_LOAD_POLICY_PROCESS_MITIGATION_FONT_DISABLE_POLICY *PPROCESS_MITIGATION_FONT_DISABLE_POLICYPROCESS_MITIGATION_FONT_DISABLE_POLICY_PROCESS_MITIGATION_FONT_DISABLE_POLICY_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICYPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICYPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICYPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY *PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICYPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICYPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY *PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICYPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY_PROCESS_MITIGATION_SEHOP_POLICY *PPROCESS_MITIGATION_SEHOP_POLICYPROCESS_MITIGATION_SEHOP_POLICY_PROCESS_MITIGATION_SEHOP_POLICY_PROCESS_MITIGATION_DEP_POLICY *PPROCESS_MITIGATION_DEP_POLICYPROCESS_MITIGATION_DEP_POLICY_PROCESS_MITIGATION_DEP_POLICY_PROCESS_MITIGATION_ASLR_POLICY *PPROCESS_MITIGATION_ASLR_POLICYPROCESS_MITIGATION_ASLR_POLICY_PROCESS_MITIGATION_ASLR_POLICY_PROCESS_MITIGATION_POLICY *PPROCESS_MITIGATION_POLICYPROCESS_MITIGATION_POLICY_PROCESS_MITIGATION_POLICYProcessDEPPolicyProcessASLRPolicyProcessDynamicCodePolicyProcessStrictHandleCheckPolicyProcessSystemCallDisablePolicyProcessMitigationOptionsMaskProcessExtensionPointDisablePolicyProcessControlFlowGuardPolicyProcessSignaturePolicyProcessFontDisablePolicyProcessImageLoadPolicyProcessSystemCallFilterPolicyProcessPayloadRestrictionPolicyProcessChildProcessPolicyProcessSideChannelIsolationPolicyProcessUserShadowStackPolicyProcessRedirectionTrustPolicyProcessUserPointerAuthPolicyProcessSEHOPPolicyProcessActivationContextTrustPolicyMaxProcessMitigationPolicy_HARDWARE_COUNTER_TYPE *PHARDWARE_COUNTER_TYPEHARDWARE_COUNTER_TYPE_HARDWARE_COUNTER_TYPEPMCCounterMaxHardwareCounterTypeIO_COUNTERS *_IO_COUNTERS *PIO_COUNTERSIO_COUNTERS_IO_COUNTERS_QUOTA_LIMITS_EX *PQUOTA_LIMITS_EXQUOTA_LIMITS_EX_QUOTA_LIMITS_EX_RATE_QUOTA_LIMIT *PRATE_QUOTA_LIMITRATE_QUOTA_LIMIT_RATE_QUOTA_LIMIT_QUOTA_LIMITS *PQUOTA_LIMITSQUOTA_LIMITS_QUOTA_LIMITS_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION *PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATIONPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE *PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGEPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE_PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION *PPROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATIONPROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION_PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION_PROCESS_DYNAMIC_EH_CONTINUATION_TARGET *PPROCESS_DYNAMIC_EH_CONTINUATION_TARGETPROCESS_DYNAMIC_EH_CONTINUATION_TARGET_PROCESS_DYNAMIC_EH_CONTINUATION_TARGET_COMPONENT_FILTER *PCOMPONENT_FILTERCOMPONENT_FILTER_COMPONENT_FILTER_UMS_CREATE_THREAD_ATTRIBUTES *PUMS_CREATE_THREAD_ATTRIBUTESUMS_CREATE_THREAD_ATTRIBUTES_UMS_CREATE_THREAD_ATTRIBUTES_NT_TIB64 *PNT_TIB64NT_TIB64_NT_TIB64_NT_TIB32 *PNT_TIB32NT_TIB32_NT_TIB32PNT_TIB_NT_TIBEXCEPTION_REGISTRATION_RECORD *_EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORDEXCEPTION_REGISTRATION_RECORD_EXCEPTION_REGISTRATION_RECORD_JOB_SET_ARRAY *PJOB_SET_ARRAYJOB_SET_ARRAY_JOB_SET_ARRAY_SECURITY_CAPABILITIES *LPSECURITY_CAPABILITIESPSECURITY_CAPABILITIESSECURITY_CAPABILITIES_SECURITY_CAPABILITIES_SE_IMAGE_SIGNATURE_TYPE *PSE_IMAGE_SIGNATURE_TYPESE_IMAGE_SIGNATURE_TYPE_SE_IMAGE_SIGNATURE_TYPESeImageSignatureNoneSeImageSignatureEmbeddedSeImageSignatureCacheSeImageSignatureCatalogCachedSeImageSignatureCatalogNotCachedSeImageSignatureCatalogHintSeImageSignaturePackageCatalogSeImageSignaturePplMitigatedBYTE *PSE_SIGNING_LEVELSE_SIGNING_LEVELPSECURITY_INFORMATIONSECURITY_INFORMATION_SE_IMPERSONATION_STATE *PSE_IMPERSONATION_STATESE_IMPERSONATION_STATE_SE_IMPERSONATION_STATE_SECURITY_QUALITY_OF_SERVICE *PSECURITY_QUALITY_OF_SERVICESECURITY_QUALITY_OF_SERVICE_SECURITY_QUALITY_OF_SERVICEBOOLEAN *PSECURITY_CONTEXT_TRACKING_MODESECURITY_CONTEXT_TRACKING_MODE_CLAIM_SECURITY_ATTRIBUTES_INFORMATION *PCLAIM_SECURITY_ATTRIBUTES_INFORMATIONCLAIM_SECURITY_ATTRIBUTES_INFORMATION_CLAIM_SECURITY_ATTRIBUTES_INFORMATION_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 *PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1_CLAIM_SECURITY_ATTRIBUTE_V1 *PCLAIM_SECURITY_ATTRIBUTE_V1CLAIM_SECURITY_ATTRIBUTE_V1_CLAIM_SECURITY_ATTRIBUTE_V1_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE *PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUECLAIM_SECURITY_ATT 
'  k $    